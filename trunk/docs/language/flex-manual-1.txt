Flex文件的组成

Flex文件由三个部分组成。或者说三个段。三个段之间用两个“%%”分隔。

定义(definitions)
%%
规则(rules)
%%
用户代码(user code)


1. 定义段(definitions section)

定义段包含着一些简单名字的定义(name definitions)，旨在简化扫描器的规范。定义名字的方法如下:

name definition

名字可以由字母或下划线开头，后跟零个或多个字母、数字、下划线、或短横线。名字的定义则从其后的第一个非空白字符(non-white-space)开始直到行尾。下面是一个例子，定义了一个名字DIGIT，其定义就是指一个数字，如下所示：

DIGIT [0-9]

当在后面引用这个名字时，用一对花括号({})括住该名字即可。它会被括展成一对圆括号括住的该名字的定义,即:

{name} 括展成 (definition)

例如：

{DIGIT}+"."{DIGIT}*

就等价于：

([0-9])+"."([0-9])*


还可以加入启动条件(start conditions)的声明。顾名思义，启动条件就如同“C”语言中的条件编译一样，根据指定的启动条件去激活一条规则，并用这条规则去匹配读入的字符。关于启动条件，后面还有更详细的介绍。
规则段(rules section)

规则由模式(pattern)和动作(action)两个部分组成。模式就是一个正则表达式，FLEX加入了一些自己的扩展。而动作一般就是一些“C”语句。模式一定要位于一行的开头处，不能有缩进。而动作的开头一定要与模式在同一行。

模式采用正则表达式来书写。正则表达式大致可以分为如下几类（从上到下，优先级依次递减）：


（1）单字符匹配


    *

      ‘x’ 

匹配字符x。


    *

      ‘.’

匹配任意一个字符（字节），除了换行符。


    *

      ‘[xyz]’

匹配一个字符，这个字符是方括号中给出的字符类中的一个。


    *

      ‘[abj-oZ]’

匹配一个字符，这个字符是方括号中给出的字符类中的一个。与上一方式的区别是指定字符类时用到了一个范围表示：j-o，这表示按照26个英文字母的顺序，从字母j开始一直到字母o共6个字母。


这里减号（-）表示范围，因此如果减号本身也要作为一个匹配字符时，最好用转义字符（\）去除其特殊含义。


由于花括号（{}）在模式中用来引用名字，以及作为模式后操作的首尾界定符，因此如果要在字符类中匹配花括号，必须用转义字符（\）去除其特殊含义。

下面这个例子定义了一个所有可打印字符的字符类：

[[:alnum:][:blank:]]\t+\-*/&!_'?@^`~$\\()%|.;[\]\{\}:,#<>=]


    *

      ‘[^A-Z]’

匹配一个字符，这个字符不可以是方括号中给出的字符类中的字符。在方括号内开始处的特殊符号（^）表示否定。


当字符^不在字符类的开始处时，并不具有特殊含义，而是一个普通字符。


    *

      ‘[^A-Z\n]’

匹配一个字符，这个字符不可以是方括号中给出的字符类中的字符。与上一方式的不同在于，这里多了一个换行符，也就是说所匹配的字符不能是26个大写字母，也不能是换行符。


（2）模式重复多次的匹配


    *

      ‘r*’

r是一个正则表达式，特殊字符`*'表示0个或多个。因此这个模式表示匹配0个或多个r。


    *

      ‘r+’

r是一个正则表达式，特殊字符`+'表示1个或多个。因此这个模式表示匹配1个或多个r。


    *

      ‘r?’

r是一个正则表达式，特殊字符`?'表示0个或1个。因此这个模式表示匹配0个或1个r。（从另一个角度看，就是说模式r是可选的）


    *

      ‘r{2,5}’

r是一个正则表达式，{2,5}表示2个到5个。因此这个模式表示匹配2个到5个r。也就是说可以匹配`rr'，`rrr'，`rrrr'，`rrrrr'四种重复的模式。


    *

      ‘r{2,}’

r是一个正则表达式，{2,}省略了第二个数字，表示至少2个，不设上限。因此这个模式表示匹配2个及以上个r。也就是说至少可以匹配`rr'，还可以匹配`rrr'，`rrrr'等无限多种重复的模式。


    *

      ‘r{4}’

r是一个正则表达式，{4}只有一个数字，表示4个。因此这个模式确切地匹配4个r，即`rrrr'。


（3）名字替换


    *

      ‘{name}’

这里name就是在前面的定义段给出的名字。这个模式将用这个名字的定义来匹配。


（4）平凡（plain）文本串的匹配


    *

      ‘“[xyz]\″foo”’

这个模式用来确切地匹配文本串：[xyz]\″foo。注意最外层的单引号所包含的是整个模式表达式，也就是说，当希望匹配字串[xyz]\″foo时，在书写规则时该字串必须用双引号括住。


（5）匹配特殊的单个字符


    *

      ‘\x’

当x是一个`a'，`b'，`f'，`n'，`r'，`t'或`v'时，它就解释为ANSI-C中的\x。否则就仍然作为一个普通字符x（一般用于诸如`*'字符的转义字符）。


    *

      ‘\0’

匹配一个NUL字符（ASCII码值为0）。


    *

      ‘\123’

匹配一个字符，其值用八进制表示为123。


    *

      ‘\x2a’

匹配一个字符，其值用十六进制表示为2a。


（6）组合模式匹配


    *

      ‘(r)’

匹配规则表达式r，圆括号可以提高其优先级。


    *

      ‘rs’

匹配规则表达式r，其后紧跟着表达式s。这称为联接（concatenation）。


    *

      ‘r|s’

或者匹配规则表达式r，或者匹配表达式s。


    *

      ‘r/s’

匹配模式r，但是要求其后经跟着模式s。当需要判断本次匹配是否为“最长匹配（longest match）时，模式s匹配的文本也会被包括进来，但完成判断后开始执行对应的动作（action）之前，这些文本会被返还给输入。所以动作（action）只能看到模式r匹配到的文本。这种模式类型叫做尾部上下文（trailing context）。（有些‘r/s’组合是flex不能识别的；请参看后面“deficiencies/bugs”一节中的“dangerous trailing context”的内容。）


    *

      ‘^r’

匹配模式r，但是这个模式只出现在一行的开始处。也就是说，刚开始扫描时遇到的，或者说在刚扫描完一个换行后紧接着遇到的。


    *

      ‘r$’

匹配模式r，但是这个模式只在一行的尾部。也就是说，该模式就出现在换行之前。这个模式等价于“r/\n”。


注意，flex中的“换行（newline）”的概念，就是C编译器中所使用的“\n”，flex也采用同样的符号和解释。在一些DOS系统中，可能必须由你自己滤除输入中的“\r”，或者明确地在模式中写成“r/\r\n”来代替“r$”。（为什么呢？因为在unix系统中换行是用一个字节表示的，即“\n”，最初C语言是unix的孪生兄弟，因此也采用相同的定义。）


（7）有启动条件（Start Condition）的模式匹配


    *

      ‘<s>r’

匹配模式r，但需要启动条件s（后面后关于启动条件的讨论）。模式‘<s1,s2,s3>r’是类似的，匹配模式r，只要有三个启动条件s1，s2，s3中的任一个即可。（启动条件简单来说，类似于C语言中的条件编译，满足了某个条件才启动这个模式参与匹配，否则不会启动该模式参与匹配。）


    *

      ‘<*>r’

匹配模式r，在任何启动条件下都参与匹配，即使是排斥性的条件。


（8）文件尾匹配


    *

      ‘<<EOF>>’

匹配文件尾，即遇到了文件尾部。一般说来，都应该在模式中加入文件尾模式。这样可以有机会在文件扫描完成时增加一些额外的处理。


    *

      ‘<s1,s2><<EOF>>’

在有启动条件s1或者s2的情况下，匹配文件尾部。


用户代码段（user code）

所有用户代码都被原样拷贝到文件“lex.yy.c”中。

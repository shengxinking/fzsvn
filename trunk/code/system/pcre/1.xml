<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="zh-cn"><head>


<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link title="new" rel="stylesheet" href="gentoo-2008.0-handbook-x86_files/main.css" type="text/css">
<link rel="shortcut icon" href="http://www.gentoo.org/favicon.ico" type="image/x-icon">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.gentoo.org/search/www-gentoo-org.xml" title="Gentoo Website">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.gentoo.org/search/forums-gentoo-org.xml" title="Gentoo Forums">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.gentoo.org/search/bugs-gentoo-org.xml" title="Gentoo Bugzilla">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.gentoo.org/search/packages-gentoo-org.xml" title="Gentoo Packages">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.gentoo.org/search/archives-gentoo-org.xml" title="Gentoo List Archives">
<title>Gentoo Linux x86手册 — Gentoo Linux文档</title>
</head><body style="margin: 0px;" bgcolor="#ffffff"><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#45347b" height="125" valign="top"><a href="http://www.gentoo.org/"><img src="gentoo-2008.0-handbook-x86_files/gtop-www.jpg" alt="Gentoo Logo" border="0"></a></td></tr>
<tr><td colspan="1" align="right" bgcolor="#ffffff" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr>
<td class="content" align="left" valign="top" width="99%">
<h1>Gentoo Linux x86手册</h1>
<p>内容:</p>
<ul>
<li>
<b><a href="#book_part1">安装Gentoo</a></b><br>
在这部分中，你将学习如何在你的系统中安装Gentoo。
<ol>
<li>
<b><a href="#book_part1_chap1">关于如何安装Gentoo Linux</a></b><br>
本章介绍了本手册所讲解的安装方式。
</li>
<li>
<b><a href="#book_part1_chap2">选择合适的安装方式</a></b><br>
你可以用许多方法安装Gentoo。本章讲解怎样用最小安装光盘安装Gentoo，尽管使用安装程序LiveCD也是可以的。
</li>
<li>
<b><a href="#book_part1_chap3">配置网络</a></b><br>
要下载最新的源代码，你要先设置好网络。
</li>
<li>
<b><a href="#book_part1_chap4">准备磁盘</a></b><br>
为了能够安装Gentoo，你必须创建所需的分区。本章讲解如何给磁盘分区以备后用。
</li>
<li>
<b><a href="#book_part1_chap5">安装Gentoo安装文件</a></b><br>
我们使用一个stage3文件来安装Gentoo。在这一章里我们将教你如何解压缩stage3文件和配置Portage。
</li>
<li>
<b><a href="#book_part1_chap6">安装Gentoo基本系统</a></b><br>
安装并配置完stage3以后，你就会有一个可用的Gentoo基本系统了。这一章将教你如何达到这一状态。
</li>
<li>
<b><a href="#book_part1_chap7">配置内核</a></b><br>
Linux内核是每个发行版的核心。本章节将解释如何配置您自己的内核。
</li>
<li>
<b><a href="#book_part1_chap8">配置系统</a></b><br>
你需要编辑一些重要的配置文件。在这一章中将对这些重要的配置文件作概述，并且介绍如何配置它们。
</li>
<li>
<b><a href="#book_part1_chap9">安装必要的系统工具
</a></b><br>
在这一章中我们将帮助你选择并安装一些重要的工具。
</li>
<li>
<b><a href="#book_part1_chap10">配置引导程序</a></b><br>
x86架构存在几种引导程序。它们中的每一种都有自己的配置方法。我们会一步步来告诉你怎样根据你的需求配置一个引导程序。
</li>
<li>
<b><a href="#book_part1_chap11">结束Gentoo的安装</a></b><br>
您几乎已经完成了。接下来我们只需要为您的系统创建一个（或更多）用户就可以了。
</li>
<li>
<b><a href="#book_part1_chap12">下一步该做什么？</a></b><br>
现在你已经拥有了你自己的Gentoo操作系统了，但是下一步该做什么呢？
</li>
</ol>
</li>
<li>
<b><a href="#book_part2">使用Gentoo</a></b><br>
学习如何使用Gentoo：安装软件、更改变量、改变Portage行为方式等等。
<ol>
<li>
<b><a href="#book_part2_chap1">Portage入门</a></b><br>
本章节阐述了一些“简单”的步骤，这些步骤是用户要维护自己系统中的软件所必须知道的。
</li>
<li>
<b><a href="#book_part2_chap2">USE标记</a></b><br>
USE标记是Gentoo非常重要的一部分。在本章里，你将学习设定USE标记以及了解USE标记如何影响你的系统构建。
</li>
<li>
<b><a href="#book_part2_chap3">Portage特性
</a></b><br>
学习Portage所拥有的特性，比如对分布式编译的支持，以及ccache等等。
</li>
<li>
<b><a href="#book_part2_chap4">初始化脚本</a></b><br>
Gentoo使用一种特殊的初始化脚本格式，有很多特色，包括由依赖关系驱动的决定和虚拟初始化脚本。本章会解释所有这些特色以及如何与这些脚本打交道。
</li>
<li>
<b><a href="#book_part2_chap5">环境变量
</a></b><br>
使用Gentoo你可以很容易地管理系统的环境变量。本章将教你如何去做，并描述一些常用的变量。
</li>
</ol>
</li>
<li>
<b><a href="#book_part3">使用Portage</a></b><br>
“使用Portage”深入全面介绍了Gentoo的软件管理工具Portage的功能。
<ol>
<li>
<b><a href="#book_part3_chap1">文件和目录</a></b><br>
当你想要深入了解Portage的时候，你需要知道它将文件和数据放在了什么地方。
</li>
<li>
<b><a href="#book_part3_chap2">通过变量来配置</a></b><br>
Portage所有的设置都可以通过不同的变量来完成，你可以设置在配置文件中或者设置成一个环境变量。
</li>
<li>
<b><a href="#book_part3_chap3">使用多个软件分支</a></b><br>
Gentoo根据软件的稳定性和架构支持将它们划分在不同的分支中。“使用多个软件分支”告诉你这些分支是如何配置的以及如何在个别情况下使用其他分支的软件。
</li>
<li>
<b><a href="#book_part3_chap4">Portage附加工具</a></b><br>
您可以通过Portage提供的一些附加工具为您的Gentoo旅程带来更多的快乐。通过下文的阅读你会学会如何使用dispatch-conf和其他的一些工具。
</li>
<li>
<b><a href="#book_part3_chap5">改造Portage树</a></b><br>
“改造Portage树”提供给你一些关于如何使用你自己的Portage树，如何只同步你想要的分类，加入自己的软件包等等的心得技巧。
</li>
</ol>
</li>
<li>
<b><a href="#book_part4">Gentoo网络配置</a></b><br>一份全面的Gentoo网络指南。<ol>
<li>
<b><a href="#book_part4_chap1">新手上路</a></b><br>
本指南可让你的网卡在大多数通用环境下迅速设置好并运行起来
</li>
<li>
<b><a href="#book_part4_chap2">高级配置</a></b><br>
这里，我们将学习这些配置是如何起作用的——对于将来学习模块化网络来说，这是必不可少的知识。
</li>
<li>
<b><a href="#book_part4_chap3">模块化网络</a></b><br>
Gentoo为您提供了灵活的网络支持——本节将告诉你怎样选择不同的DHCP客户端程序，如何配置网络的绑定和桥接以及配置VLAN等等相关的知识。
</li>
<li>
<b><a href="#book_part4_chap4">无线网络</a></b><br>
配置无线网络并不是一件简单的事情。希望我们能让您的无线网络正常工作。
</li>
<li>
<b><a href="#book_part4_chap5">附加功能</a></b><br>
如果你喜欢冒险的感觉，你可以在网络中加上自己的功能。
</li>
<li>
<b><a href="#book_part4_chap6">网络管理</a></b><br>
本章是为笔记本电脑用户和频繁切换网络的用户准备的。
</li>
</ol>
</li>
</ul>
<a name="book_part1"></a><h2>A. 安装Gentoo</h2>
<a name="book_part1_chap1"></a><h3>1. 关于如何安装Gentoo Linux</h3>
<p class="chaphead"><a name="book_part1_chap1__chap1"></a><span class="chapnum">1.a. </span>介绍</p>
<p class="secthead"><a name="book_part1_chap1__chap1_sect1">欢迎！</a></p>
<p>
首先，<span class="emphasis">欢迎</span>使用Gentoo。你将进入一个多选择和高性能的世界。Gentoo就意味着选择。当你安装Gentoo时，你将会清楚的了解到——你能够选择怎样编译软件，如何安装Gentoo，以及使用哪种系统日志程序等等。
</p>
<p>
Gentoo是一个快速和现代化的元发行版，拥有简洁灵活的设计理念。Gentoo基于自由软件构建，它不会对用户隐瞒任何底层细节。Portage是
Gentoo使用的软件包管理系统，由于它是使用Python语言编写的，因此你可以轻松地查看和修改源代码。Gentoo的软件包系统使用的是源代码
（尽管也包含对预编译的软件包的支持），配置Gentoo使用的也都是标准的文本文件。换句话说就是，开放无处不在。
</p>
<p>
希望您能明白的一点是Gentoo的根本在于<span class="emphasis">选择</span>，这一点非常重要。我们会尽力做到不强加给用户任何东西，如果你觉得被强迫安装了任何你不喜欢的东西，请请提交一个<a href="http://bugs.gentoo.org/">bug报告</a>。
</p>
<p class="secthead"><a name="book_part1_chap1__chap1_sect2">安装的步骤有哪些？</a></p>
<p>
Gentoo的安装可以被分成10个步骤，从第2章到第11章，每一步都会令系统进入一个新的状态：
</p>
<ul>
<li>
  第一步后，你已准备就绪，可以安装Gentoo了
</li>
<li>
  第二步后，你已为安装Gentoo准备好了网络连接
</li>
<li>
  第三步后，你的硬盘已初始化完毕，等待Gentoo的安装
</li>
<li>
  第四步后，你的安装环境已经准备好了，并准备chroot到一个新的系统环境中
</li>
<li>
  第五步后，一些核心的软件包安装完毕，这在所有的Gentoo安装中都是相同的
</li>
<li>
  第六步后，你已经编译好了你的Linux内核
</li>
<li>
  第七步后，你已经写好绝大多数的Gentoo系统配置文件
</li>
<li>
  第八步后，必要的系统工具（你可以从列表中选择）已经安装完毕
</li>
<li>
  第九步后，你选择的启动引导程序已经安装配置好了，并且你已经登录了你新的Gentoo系统中
</li>
<li>
  第十步后，你就可以在你的Gentoo linux系统中探索了
</li>
</ul>
<p>
当你面临某个选择时，我们会尽力为你解释它的利弊。我们首先会介绍一个默认的选项，这在标题中会以“默认：”标识出来。剩下的则会被标注为：“备选：”千万<span class="emphasis">不要</span>认为默认选项是我们推荐的，这只是我们认为绝大多数用户会采用的。
</p>
<p>
有时候你也可以做一些可选的步骤。这样的步骤会被标注为“可选：”，当然这些步骤对于安装Gentoo来说就不是必须的。然而，有些可选的步骤依赖于你之前所做出的决定。我们将会在你需要做这样决定以及可选步骤出现的时候提醒你。
</p>
<p class="secthead"><a name="book_part1_chap1__chap1_sect3">我有哪些选择？</a></p>
<p>
你可以通过很多不同的方法来安装Gentoo。你可以下载我们的安装光盘安装，可以从一个已有的系统上安装，可以从一张可引导光盘上安装（比如Knoppix），也可以从网络启动环境或从一张恢复软盘上安装等等。
</p>
<p>
这份文档讲解了如何使用Gentoo安装光盘或者在某些情况下使用网络启动来安装Gentoo。这种安装方式假设你想要使用最新的软件包。如果你想要进行无网络安装，你应该阅读<a href="http://www.gentoo.org/doc/zh_cn/handbook/2008.0/">Gentoo 2008.0手册</a>，那里面包含无网络安装指南。
</p>
<p>
请注意，如果你打算用GRP（Gentoo参考平台，一套供即时使用的预编译软件包），你<span class="emphasis">一定</span>要依照<a href="http://www.gentoo.org/doc/zh_cn/handbook/2008.0/">Gentoo 2008.0手册</a>来安装。
</p>
<p>
关于其他安装方法请参考我们的<a href="http://www.gentoo.org/doc/zh_cn/altinstall.xml">其他安装指南</a>。我们还提供了<a href="http://www.gentoo.org/doc/zh_cn/gentoo-x86-tipsntricks.xml">Gentoo安装技巧和窍门</a>，也值得一读。如果你觉得本安装指南太过详细，你还可以使用我们<a href="http://www.gentoo.org/doc/zh_cn/index.xml">文档资源</a>中的可用于你的硬件架构的快速安装手册。
</p>
<p>
你也有这些选择：你可以从头编译整个系统，或使用Gentoo预编译软件包以在很短时间内便装好一个可用的系统。当然，你也可以使用折中的方案，从已完成一半的系统开始安装。
</p>
<p class="secthead"><a name="book_part1_chap1__chap1_sect4">碰到问题？</a></p>
<p>
如果你在安装过程中（或是在安装文档中）碰到问题，请到<a href="http://bugs.gentoo.org/">bug追踪系统</a>检查这是否是已知的bug。如果没有，请创建一个bug报告，然后我们来解决它。大家不要害怕负责解决（你的）bug的开发人员，他们通常是不会吃人的。
</p>
<p>需要注意的是，虽然你当前阅读的文档是针对某一特定的硬件架构的，但是它还是会包含对其他平台架构的引用。这是因为Gentoo手册中的绝大部分的
源代码是对所有硬件架构都适用的（目的是减少重复劳动和节省有限的开发资源)。我们会努力把这种负面影响减少到最小以避免混淆。
</p>
<p>如果你不能确定你的问题是否是一个使用者问题（尽管你已经仔细地阅读了文档但仍然出了错）还是一个软件问题（尽管我们已经仔细地测试了安装步骤/文
档但仍然出了错），我们欢迎你到irc.freenode.net的#gentoo（英文）或是#gentoo-cn（中文）提问。当然，如果你有其他方
面的关于Gentoo的问题，我们也欢迎:)
</p>
<p>
如果你有关于Gentoo的问题，请到我们的<a href="http://www.gentoo.org/doc/zh_cn/">Gentoo文档</a>查看<a href="http://www.gentoo.org/doc/zh_cn/faq.xml">常见问题</a>。你也可以浏览我们<a href="http://forums.gentoo.org/">论坛</a>中的<a href="http://forums.gentoo.org/viewforum.php?f=40">FAQs</a>。如果你还是无法找到答案，那么就去irc.freenode.net中我们的#gentoo频道寻找吧，我们中的一些狂热者会一直呆在IRC里的:-)
</p>
<a name="book_part1_chap2"></a><h3>2. 选择合适的安装方式</h3>
<p class="chaphead"><a name="book_part1_chap2__chap1"></a><span class="chapnum">2.a. </span>硬件需求</p>
<p class="secthead"><a name="book_part1_chap2__chap1_sect1">介绍</a></p>
<p>
在开始之前，我们首先列出安装Gentoo的硬件需求。
</p>
<p class="secthead"><a name="book_part1_chap2__chap1_sect2">硬件需求</a></p>
<table class="ntable">
<tbody><tr>
 <td class="tableinfo"></td>
 <th class="infohead" style="text-align: left;"><b>最小光盘</b></th>
 <th class="infohead" style="text-align: left;"><b>LiveCD</b></th>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>CPU</b></th>
  <td class="tableinfo">i486或更新</td>
  <td class="tableinfo">
<b>i686</b>或更新</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>内存</b></th>
  <td class="tableinfo">64MB</td>
  <td class="tableinfo">256MB</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>硬盘空间</b></th>
  <td class="tableinfo" colspan="2">1.5GB(不包括交换分区)</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>交换分区</b></th>
  <td class="tableinfo" colspan="2">至少256MB</td>
</tr>
</tbody></table>
<p class="chaphead"><a name="book_part1_chap2__chap2"></a><span class="chapnum">2.b. </span>Gentoo安装光盘</p>
<p class="secthead"><a name="book_part1_chap2__chap2_sect1">介绍</a></p>
<p>
<span class="emphasis">Gentoo安装光盘</span>是<span class="emphasis">可启动</span>的光盘，它含有一个完整的Gentoo环境，允许你从光盘启动Linux。在启动过程中，它们会自动检测你的硬件并加载相应的驱动程序。这些光盘是由Gentoo开发者维护的。
</p>
<p>
所有的安装光盘都允许你启动、设置网络、初始化硬盘分区和从因特网上开始安装Gentoo。我们目前提供两种安装光盘，它们都同样适合安装Gentoo，只要你想通过网络安装并使用最新的软件包。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
如果你想在无网络条件下安装Gentoo或是想进行自动安装，请参考<a href="http://www.gentoo.org/doc/zh_cn/handbook/2008.0/">Gentoo 2008.0手册</a>里的说明。
</p></td></tr></tbody></table>
<p>
我们目前提供的安装光盘是：
</p>
<ul>
  <li>
    Gentoo<span class="emphasis">最小</span>安装光盘，一个小而精简的可启动光盘，它只能引导系统，准备网络和进行Gentoo的安装。
  </li>
  <li>
    Gentoo<span class="emphasis">安装程序LiveCD</span>包含了你安装Gentoo所需要的一切东西。它提供了一个图形化的环境，包括能够自动进行安装的图形界面程序和文本界面程序，当然，还有针对你的硬件构架的安装指南。
  </li>
</ul>
<p>
为了让你更好的做出选择，我们列出了每种安装光盘的优点和缺点。
</p>
<p class="secthead"><a name="book_part1_chap2__chap2_sect2">Gentoo最小安装光盘</a></p>
<p>
这个最小安装光盘名叫<span class="code" dir="ltr">install-x86-minimal-2008.0.iso</span>。大小只有57MB。你可以用它安装Gentoo，但是<span class="emphasis">只能</span>用于有网络的环境。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>最小安装光盘</b></th>
  <th class="infohead" style="text-align: left;"><b>优点及缺点</b></th>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>+</b></th>
  <td class="tableinfo">最小的下载量</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>-</b></th>
  <td class="tableinfo">
    不包含stage3、portage快照、预编译软件包，因此不适合无网络安装
  </td>
</tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap2__chap2_sect3">Gentoo安装程序LiveCD</a></p>
<p>
这个安装程序LiveCD名叫<span class="code" dir="ltr">livecd-i686-installer-2008.0-r1.iso</span>，大小为655MB。你可以用它来安装Gentoo，即使在是无网络的环境中也可以，比如万一你在其他电脑上安装Gentoo就用的着了。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>安装程序LiveCD</b></th>
  <th class="infohead" style="text-align: left;"><b>优点及缺点</b></th>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>+</b></th>
  <td class="tableinfo">
    包含所有你需要的任何东西。你甚至可以进行无网络安装。
  </td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>-</b></th>
  <td class="tableinfo">下载量大</td>
</tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap2__chap2_sect4">Stage3</a></p>
<p>stage3是一个含有最小Gentoo环境的压缩包，适合按照手册继续安装Gentoo。以前，Gentoo手册介绍了使用3种stage的安装
方法。虽然Gentoo仍然提供stage1和stage2，但在官方的安装指南中只使用stage3。如果你对stage1和stage2感兴趣，请阅
读Gentoo FAQ中的<a href="http://www.gentoo.org/doc/en/faq.xml#stage12">如何使用stage1或stage2安装Gentoo？</a>
</p>
<p>
Stage3不包含在LiveCD中，你可以从任何一个<a href="http://www.gentoo.org/main/en/mirrors.xml">Gentoo官方镜像</a>的<span class="path" dir="ltr">releases/x86/2008.0/stages/</span>目录里下载。
</p>
<p class="chaphead"><a name="book_part1_chap2__chap3"></a><span class="chapnum">2.c. </span>下载刻录并从安装光盘启动</p>
<p class="secthead"><a name="book_part1_chap2__chap3_sect1">下载和刻录安装光盘</a></p>
<p>
你已经选择使用了一种Gentoo安装光盘。我们从下载和刻录你选择的安装光盘开始。前面我们提到过几种安装光盘，那你怎样找到它们呢？
</p>
<p>
你可以从我们任何一个<a href="http://www.gentoo.org/main/en/mirrors.xml">镜像</a>下载。这些安装光盘位于<span class="path" dir="ltr">releases/x86/2008.0/installcd/</span>目录里。
</p>
<p>
在那个目录里你可以找到一些ISO文件，这些都是你可以在CD-R上刻录的光盘镜像。
</p>
<p>
如果你想知道文件是否在下载过程中损坏，你可以检查它的MD5校验和，并和我们提供的MD5校验和（如<span class="path" dir="ltr">install-x86-minimal-2008.0.iso.DIGESTS</span>）进行比较。你可以使用Linux和Unix下的<span class="code" dir="ltr">md5sum</span>工具或者Windows下的<a href="http://www.etree.org/md5com.html">md5sum</a>来检查它的MD5校验和。
</p>
<p>
另外一种检查下载文件的完整性的方法是使用GnuPG来验证我们提供的数字签名（这个文件以<span class="path" dir="ltr">.asc</span>结尾）。下载签名文件。并获得公钥：
</p>
<a name="book_part1_chap2__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 获得公钥</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">gpg --keyserver subkeys.pgp.net --recv-keys 17072058</span>
</pre></td></tr>
</tbody></table>
<p>
现在验证签名：
</p>
<a name="book_part1_chap2__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 验证数字签名</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">gpg --verify &lt;签名文件&gt; &lt;下载的iso&gt;</span>
</pre></td></tr>
</tbody></table>
<p>
要刻录这些下载的ISO文件，你必须选择raw方式刻录。具体方法取决于你所选择的刻录软件。这里我们将讨论<span class="code" dir="ltr">cdrecord</span>和<span class="code" dir="ltr">K3B</span>;更多的信息可以在<a href="http://www.gentoo.org/doc/en/faq.xml#isoburning">Gentoo FAQ</a>里找到。
</p>
<ul>
  <li>
    使用cdrecord，你只需简单的输入<span class="code" dir="ltr">cdrecord dev=/dev/hdc &lt;下载的iso 文件&gt;</span>（用你的CD-RW设备的路径来代替<span class="path" dir="ltr">/dev/hdc</span>）。
  </li>
  <li>
    使用K3B，选择<span class="code" dir="ltr">Tools</span> &gt; <span class="code" dir="ltr">Burn CD Image</span>。然后你可以在“Image to Burn”区域定位你的ISO文件。最后点击<span class="code" dir="ltr">Start</span>。
  </li>
</ul>
<p class="secthead"><a name="book_part1_chap2__chap3_sect2">启动安装光盘</a></p>
<p>
安装光盘刻录好后，就可以用来启动了。从光驱中取出所有的光盘，重启系统并进入BIOS。根据你的BIOS的不同一般是敲击DEL键，F1键或者ESC键
就可以了。在BIOS里面，更改启动顺序以使光驱的启动在硬盘启动之前。这个选项一般在“CMOS
Setup”里。如果你不这样做的话，你的系统重启后将只从硬盘启动，而忽略光驱。
</p>
<p>
现在把LiveCD放入光驱中并重新启动电脑。你会看到一个启动提示符。按回车键以使用默认选项来开始启动过程，或者用自定义的启动选项来启动，具体来说是指定一个内核并加上想要的启动选项，然后再按回车键。
</p>
<p>
指定一个内核？是的，我们在安装光盘上提供了几个内核。默认的是<span class="code" dir="ltr">gentoo</span>。其他的内核对应特定硬件的需要，带<span class="code" dir="ltr">-nofb</span>的表示的禁用了用framebuffer。
</p>
<p>
下面你可以看到一个对已有内核的简述：
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>内核</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo">gentoo</td>
  <td class="tableinfo">默认的2.6内核带有对多CPU的支持</td>
</tr>

<tr>
  <td class="tableinfo">gentoo-nofb</td>
  <td class="tableinfo">与<span class="code" dir="ltr">gentoo</span>相同，但是不支持framebuffer</td>
</tr>
<tr>
  <td class="tableinfo">memtest86</td>
  <td class="tableinfo">检测内存错误</td>
</tr>
</tbody></table>
<p>
你也可以使用内核选项。他们代表了一些你可以激活或取消的设置。
</p>
<p>
<font color="#ff0000"><b>硬件选项：</b></font>
</p>
<dl>
<dt>acpi=on</dt>
<dd>
  加载对ACPI的支持，在启动光盘的同时启动acpid后台程序。这个选项只有
  在你的系统需要ACPI才能正常运行的情况下才需要。启用超线程的支持
  这个选项不是必需的。
</dd>
<dt>acpi=off</dt>
<dd>
  完全关闭ACPI。这在一些比较老的系统上有用，同时也是使用高级电源管
  理（APM）的必要选项。这也将关闭对你的处理器的超线程的支持。
</dd>
<dt>console=X</dt>
<dd>
  这个选项可以设置光盘的串口访问。第一个选项是设备，在x86上通常为
  ttyS0，后面可以跟其他选项并用逗号分隔。默认选项为9600,8,n,1。
</dd>
<dt>dmraid=X</dt>
<dd>
  这个选项用于向设备映射器RAID子系统传递参数。传递的参数必须包含
  在引号内。
</dd>
<dt>doapm</dt>
<dd>
  这个选项加载高级电源管理（APM）驱动支持。这需要你同时使用acpi=off
  选项。
</dd>
<dt>dopcmcia</dt>
<dd>
  这个选项加载了对PCMCIA和Cardbus硬件的支持，也使得pcmcia卡的
  cardmgr能够在光盘启动的时候运行起来。这个选项只有在从
  PCMCIA/Cardbus设备启动的时候才需要。
</dd>
<dt>doscsi</dt>
<dd>
  这个选项加载对大部分SCSI控制器的支持。在大多数USB设备启动的时候
  也需要这个选项，因为USB设备使用内核中的SCSI子系统。
</dd>
<dt>sda=stroke</dt>
<dd>
  这个选项允许你对整个硬盘进行分区，即使你的BIOS不能处理大硬盘。
  此选项仅使用在使用旧BIOS的机器上。使用时把sda替换为需要这个选项
  的设备。
</dd>
<dt>ide=nodma</dt>
<dd>
  此选项强制关闭内核中的DMA，一些IDE和CDROM驱动需要这个选项。如果
  你的系统在读取IDE接口的光驱的时候遇到麻烦，可以尝试一下此选项。
  此选项同时也将关闭hdparm的默认设置。
</dd>
<dt>noapic</dt>
<dd>
  此选项关闭了在一些新主板上存在的高级可编程中断控制器。它在一些旧
  的硬件上会引发一些问题。
</dd>
<dt>nodetect</dt>
<dd>
  此选项降会关闭光盘会做的所有自动检测，包括设备检测和DHCP探测。这
  在调试有问题的光盘或驱动的时候有用。
</dd>
<dt>nodhcp</dt>
<dd>
  此选项将禁止在检测到的网卡上进行DHCP探测。这对仅有静态地址的网络
  很有用。
</dd>
<dt>nodmraid</dt>
<dd>
  关闭了设备映射RAID的支持，例如用于板载IDE/SATA RAID的控制器。
</dd>
<dt>nofirewire</dt>
<dd>
  此选项关闭了Firewire模块加载。这个选项只有在你的Firewire硬件导致
  光盘启动出现问题的时候才需要。
</dd>
<dt>nogpm</dt>
<dd>
  此选项关闭了gpm控制台鼠标支持。
</dd>
<dt>nohotplug</dt>
<dd>
  此选项关闭启动时对热插拔（hotplug）和冷插拔（coldplug）启动脚本的加
  载。这个选项在调试失败的光盘和驱动的时候有用。
</dd>
<dt>nokeymap</dt>
<dd>
  此选项禁止了键盘布局选择。
</dd>
<dt>nolapic</dt>
<dd>
  此选项关闭了在单处理器内核上的本地APIC。
</dd>
<dt>nosata</dt>
<dd>
  此选项关闭了对串行ATA（SATA）模块的加载。当你的系统的SATA子系统有
  问题的时候，此选项有用。
</dd>
<dt>nosmp</dt>
<dd>
  此选项关闭了在支持SMP（对称式多处理）的内核中的SMP功能。这个选项用
  于调试在特定的驱动和主板上与SMP相关的问题。
</dd>
<dt>nosound</dt>
<dd>
  此选项关闭了声音支持和音量的设置。这个选项在声音支持出现问题的系
  统上有用。
</dd>
<dt>nousb</dt>
<dd>
  此选项关闭了USB模块的自动加载。这个选项在调试USB问题时有用。
</dd>
<dt>slowusb</dt>
<dd>
  这个选项在启动过程中增加一些额外的暂停，主要是为了一些慢速USB
  CDROM，例如IBM BladeCenter的。
</dd>
</dl>
<p>
<font color="#ff0000"><b>卷/设备管理：</b></font>
</p>
<dl>
<dt>doevms</dt>
<dd>
  此选项打开了对IBM的可插拔EVMS（企业卷管理系统）的支持。这个选项与
  lvm同时使用并不安全。
</dd>
<dt>dolvm</dt>
<dd>
  此选项打开对Linux逻辑卷管理（lvm2）的支持。这个选项与evms同时使用
  并不安全。
</dd>
</dl>
<p>
<font color="#ff0000"><b>其他选项：</b></font>
</p>
<dl>
<dt>debug</dt>
<dd>
  启用调试代码。这个选项会在屏幕上显示很多数据，可能会很凌乱。
</dd>
<dt>docache</dt>
<dd>
  此选项把光盘中整个运行部分缓存到内存中，你就可以umount /mnt/cdrom
  然后mount另一个CDROM。此选项要求你至少有两倍于CDROM的可用内存。
</dd>
<dt>doload=X</dt>
<dd>
  此选项使得初始内存盘加载任何列出的及其依赖的模块。把X替换成模
  块名称。多个模块可以用一个逗号分隔的列表来指定。
</dd>
<dt>dosshd</dt>
<dd>
  启动sshd，对于无人职守安装有用
</dd>
<dt>passwd=foo</dt>
<dd>
  将foo设置为root用户密码；若使用dosshd必须使用此选项，否则我们会
  将root密码设为随机值。
</dd>
<dt>noload=X</dt>
<dd>
  此选项使得初始内存盘跳过那些指定的可能引起问题的模块。语法同
  doload。
</dd>
<dt>nonfs</dt>
<dd>
  启动是不启动portmap/nfsmount。
</dd>
<dt>nox</dt>
<dd>
  此选项使得一个支持X的LiveCD不自动启动X，而是启动到命令行模式。
</dd>
<dt>scandelay</dt>
<dd>
  此选项使光盘在启动过程的特定部分暂停10秒，以允许那些初始化比较慢的
  设备能够被使用。
</dd>
<dt>scandelay=X</dt>
<dd>
  此选项允许你在启动过程的特定部分指定暂停指定的秒数，以允许那些
  初始化比较慢的设备能够被使用。把X替换成暂停的秒数。
</dd>
</dl>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
本CD将会先检查“no*”选项，然后再检查“do*”选项，所以你可以以你指定的顺序来覆盖任意选项。
</p></td></tr></tbody></table>
<p>
现在引导你的光盘，选择一个内核（如果你不喜欢默认的<span class="code" dir="ltr">gentoo</span>内核）和启动选项。例如：我们给你演示如何以<span class="code" dir="ltr">dopcmcia</span>内核参数启动<span class="code" dir="ltr">gentoo</span>内核：
</p>
<a name="book_part1_chap2__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 启动一个安装光盘</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>boot: <span class="code-input">gentoo dopcmcia</span>
</pre></td></tr>
</tbody></table>
<p>然后你看到一个启动画面和一个进度条。如果你正在把Gentoo安装到一个使用非US键盘的电脑中，你必须立刻按下Alt-F1键切换到冗长模式
下，然后按提示信息来做。如果10秒钟内没有选择，系统会以默认的键盘布局（US键盘）继续启动过程。一旦启动完成，你将会自动以“root”超级用户身
份登录这个“Live” Gentoo
Linux。在当前终端里你将会有个root提示符（#），你可以通过按Alt-F2、Alt-F3和Alt-F4切换到其他的终端，按Alt-F1回到
你开始的那个终端。
</p>
<p>
现在从<a href="#hardware">额外硬件配置</a>继续
</p>
<p class="secthead"><a name="hardware"></a><a name="book_part1_chap2__chap3_sect3">额外硬件配置</a></p>
<p>
当安装光盘启动时，它会尝试检测所有的硬件设备和加载准确的内核模块来支持这些硬件。绝大多数情况下，它会做的很好。但是，有些情况下，它可能没有自动加载你需要的内核模块。如果PCI自动检测错过了你系统里的一些硬件，你需要手动为它们加载相应的内核模块。
</p>
<p>
在下一个例子中，我们尝试加载<span class="code" dir="ltr">8139too</span>模块（支持某种网卡）：
</p>
<a name="book_part1_chap2__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 加载内核模块</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">modprobe 8139too</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="useraccounts"></a><a name="book_part1_chap2__chap3_sect4">可选：用户帐号</a></p>
<p>
如果你打算为其他人提供你安装环境的访问权限，或者你不想以root帐号的身份（因为安全原因）使用<span class="code" dir="ltr">irssi</span>聊天的话，你需要创建必要的用户帐号，并改变root用户的密码。
</p>
<p>
使用<span class="code" dir="ltr">passwd</span>命令来修改root用户密码：
</p>
<a name="book_part1_chap2__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: 修改root用户密码</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">passwd</span>
New password: <span class="code-comment">（输入新密码）</span>
Re-enter password: <span class="code-comment">（再次输入密码）</span>
</pre></td></tr>
</tbody></table>
<p>
要创建用户帐号，首先输入他们的信息，再输入他的密码。我们可以使用<span class="code" dir="ltr">useradd</span>和<span class="code" dir="ltr">passwd</span>来完成。在下个的例子中，我们创建一个名为“john”的用户。
</p>
<a name="book_part1_chap2__chap3_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.6: 创建一个新用户</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">useradd -m -G users john</span>
# <span class="code-input">passwd john</span>
New password: <span class="code-comment">（输入john的密码）</span>
Re-enter password: <span class="code-comment">（再次输入john的密码）</span>
</pre></td></tr>
</tbody></table>
<p>
你可以使用su从root用户切换到新建的用户：
</p>
<a name="book_part1_chap2__chap3_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.7: 切换用户</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">su - john</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap2__chap3_sect5">可选：在安装时查看文档</a></p>
<p>
如果你想在安装的时候查看Gentoo手册（不管是光盘中的还是在线的），请确认你已经创建好了一个用户帐号（请查看<a href="#useraccounts">可选：用户帐号</a>）。然后按<span class="code" dir="ltr">Alt-F2</span>打开一个新的终端并登录进入。
</p>
<p>
如果你想查看光盘里的文档，你可以立即运行<span class="code" dir="ltr">links</span>来阅读：
</p>
<a name="book_part1_chap2__chap3_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.8: 查看光盘里的文档</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">links /mnt/cdrom/docs/html/index.html</span>
</pre></td></tr>
</tbody></table>
<p>
不过，首选的还是在线查看Gentoo手册，因为它比光盘里提供的要新。你也可以使用<span class="code" dir="ltr">links</span>阅读它，但是必须在完成<span class="emphasis">配置网络</span>这一章后才行（否则你不能到因特网上查看文档）：
</p>
<a name="book_part1_chap2__chap3_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.9: 查看在线文档</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">links http://www.gentoo.org/doc/zh_cn/handbook/handbook-x86.xml</span>
</pre></td></tr>
</tbody></table>
<p>
你可以按<span class="code" dir="ltr">Alt-F1</span>来回到原来的终端。
</p>
<p class="secthead"><a name="book_part1_chap2__chap3_sect6">可选：启动SSH服务</a></p>
<p>
如果你想在安装Gentoo的过程中允许别的用户登录你的电脑（可能是因为别的用户愿意帮助你安装Gentoo，甚至是代你安装），你需要为他们创建用户帐号，甚至提供root用户密码（<span class="emphasis">只有</span>在你<b>完全信任</b>这位用户的情况下才行）。
</p>
<p>
执行下面的命令来启动SSH服务：
</p>
<a name="book_part1_chap2__chap3_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.10: 启动SSH服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/sshd start</span>
</pre></td></tr>
</tbody></table>
<p>
在使用sshd之前，你必须设置好你的网络。请从<a href="#book_part1_chap3">配置网络</a>一章继续。
</p>
<a name="book_part1_chap3"></a><h3>3. 配置网络</h3>
<p class="chaphead"><a name="book_part1_chap3__chap1"></a><span class="chapnum">3.a. </span>自动网络检测</p>
<p class="secthead"><a name="book_part1_chap3__chap1_sect1">能够自动检测到么？</a></p>
<p>
如果你的系统接入一个拥有DHCP服务器的以太网，那么很可能网络配置已经自动设置好了。如果是这样，你就可以利用到安装盘中的许多网络命令，如<span class="code" dir="ltr">ssh</span>，<span class="code" dir="ltr">scp</span>，<span class="code" dir="ltr">ping</span>，<span class="code" dir="ltr">irssi</span>，<span class="code" dir="ltr">wget</span>和<span class="code" dir="ltr">links</span>。
</p>
<p>
如果网络已经为你配置好了，<span class="code" dir="ltr">/sbin/ifconfig</span>命令就能列出lo以外的一些网卡的信息，如eth0：
</p>
<a name="book_part1_chap3__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 一个正常工作的网络配置的/sbin/ifconfig命令输出</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/sbin/ifconfig</span>
<span class="code-comment">（……）</span>
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800 
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap3__chap1_sect2">可选：配置网络代理</a></p>
<p>
如果你是通过代理访问网络，就要在安装过程中设置代理信息。设置代理很容易：只要定义一个包含代理服务器信息的变量即可。
</p>
<p>
通常情况下只要将这个变量定义为代理服务器主机名。作为例子，我们假定代理名叫<span class="code" dir="ltr">proxy.gentoo.org</span>，端口为<span class="code" dir="ltr">8080</span>。
</p>
<a name="book_part1_chap3__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 定义代理服务器</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（如果代理传输HTTP数据）</span>
# <span class="code-input">export http_proxy="http://proxy.gentoo.org:8080"</span>
<span class="code-comment">（如果代理传输FTP数据）</span>
# <span class="code-input">export ftp_proxy="ftp://proxy.gentoo.org:8080"</span>
<span class="code-comment">（如果代理传输RSYNC数据）</span>
# <span class="code-input">export RSYNC_PROXY="proxy.gentoo.org:8080"</span>
</pre></td></tr>
</tbody></table>
<p>
如果代理要求用户名和密码，请使用以下格式的变量：
</p>
<a name="book_part1_chap3__chap1_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.3: 添加用户名/密码到代理变量</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>http://<span class="code-input">用户名</span>:<span class="code-input">密码</span>@proxy.gentoo.org:8080
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap3__chap1_sect3">测试网络</a></p>
<p>
ping一下你的ISP提供的DNS服务器（可于<span class="path" dir="ltr">/etc/resolv.conf</span>中找到）和一个任选的网站，以确定数据包传到了网上、DNS域名解析正常，等等。
</p>
<a name="book_part1_chap3__chap1_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.4: 进一步测试网络</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ping -c 3 www.gentoo.org</span>
</pre></td></tr>
</tbody></table>
<p>
如果现在你的网络可用了，就可以略过本章的余下部分，进入下一章<a href="#book_part1_chap4">预备磁盘</a>。如果没有，请接下去阅读。
</p>
<p class="chaphead"><a name="book_part1_chap3__chap2"></a><span class="chapnum">3.b. </span>自动网络配置</p>
<p>
如果网络没有马上配置好，一些安装介质允许你使用<span class="code" dir="ltr">net-setup</span>（普通或无线网络），<span class="code" dir="ltr">pppoe-setup</span>（ADSL用户）或<span class="code" dir="ltr">pptp</span>（PPTP用户——x86、amd64、alpha、ppc和ppc64平台可用）来继续配置。
</p>
<p>
如果你的安装介质没有提供这些工具或者你的网络还是不能运行，请阅读<a href="#book_part1_chap3__chap3">手动配置网络</a>。
</p>
<ul>
  <li>
    普通以太网用户请继续阅读<a href="#net-setup">默认：使用net-setup</a> 
  </li>
  <li>
    ADSL用户请继续阅读<a href="#ppp">备选：使用PPP</a> 
  </li>
  <li>
    PPTP用户请继续阅读<a href="#pptp">备选：使用PPTP</a> 
  </li>
</ul>
<p class="secthead"><a name="net-setup"></a><a name="book_part1_chap3__chap2_sect2">默认：使用net-setup</a></p>
<p>
如果网络没有自动配置好，最简单的配置方法是执行<span class="code" dir="ltr">net-setup</span>脚本：
</p>
<a name="book_part1_chap3__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 执行net-setup脚本</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">net-setup eth0</span>
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">net-setup</span>会问你一些关于你的网络环境的问题。全部回答完之后，你就能拥有一个正常工作的网络连接。按照前面叙述的方法测试一下网络连接。如果测试结果正常，恭喜！现在你已准备好开始安装Gentoo了。略过本章的余下部分并进入<a href="#book_part1_chap4">预备磁盘</a>。
</p>
<p>
如果网络还不能配置好，请继续阅读<a href="#book_part1_chap3__chap3">手动配置网络</a>。
</p>
<p class="secthead"><a name="ppp"></a><a name="book_part1_chap3__chap2_sect3">备选：使用PPP</a></p>
<p>
假如你通过PPPoE连接internet，安装盘（所有版本）中包含的<span class="code" dir="ltr">ppp</span>工具会让事情变得简单。使用所提供的<span class="code" dir="ltr">pppoe-setup</span>脚本来配置网络。它会提示你输入一些信息，包括连接到你的adsl调制解调器的网络设备、用户名和密码、DNS服务器的IP以及是否需要一个基本的防火墙。
</p>
<a name="book_part1_chap3__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 使用ppp</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">pppoe-setup</span>
# <span class="code-input">pppoe-start</span>
</pre></td></tr>
</tbody></table>
<p>
如果配置出错了，请仔细检查<span class="path" dir="ltr">/etc/ppp/pap-secrets</span>或<span class="path" dir="ltr">/etc/ppp/chap-secrets</span>，确保你在其中输入的用户名和密码无误，并确定使用了正确的以太网设备。如果网络设备不存在，必须加载适当的网络模块。这种情况下你应该继续阅读<a href="#book_part1_chap3__chap3">手动配置网络</a>，我们在其中解释了如何加载适当的网络模块。
</p>
<p>
如果一切正常，请继续阅读<a href="#book_part1_chap4">预备磁盘</a>。
</p>
<p class="secthead"><a name="pptp"></a><a name="book_part1_chap3__chap2_sect4">备选：使用PPTP</a></p>
<p>
如果你需要支持PPTP连接，可以使用我们的安装光盘中所提供的<span class="code" dir="ltr">pptpclient</span>。不过你必须首先确定配置没有问题。编辑<span class="path" dir="ltr">/etc/ppp/pap-secrets</span>或<span class="path" dir="ltr">/etc/ppp/chap-secrets</span>使其中包含正确的用户名/密码对：
</p>
<a name="book_part1_chap3__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 编辑/etc/ppp/chap-secrets</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/ppp/chap-secrets</span>
</pre></td></tr>
</tbody></table>
<p>
然后如果有必要，调整一下<span class="path" dir="ltr">/etc/ppp/options.pptp</span>。
</p>
<a name="book_part1_chap3__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 编辑/etc/ppp/options.pptp</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/ppp/options.pptp</span>
</pre></td></tr>
</tbody></table>
<p>
当做好了所有的配置，就请执行<span class="code" dir="ltr">pptp</span>（跟随一些不能在<span class="path" dir="ltr">options.pptp</span>中设置的选项）来连接服务器：
</p>
<a name="book_part1_chap3__chap2_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.5: 连接到一个“拨入”服务器</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">pptp &lt;服务器ip&gt;</span>
</pre></td></tr>
</tbody></table>
<p>
现在请继续阅读<a href="#book_part1_chap4">预备磁盘</a>。
</p>
<p class="chaphead"><a name="book_part1_chap3__chap3"></a><span class="chapnum">3.c. </span>手动配置网络</p>
<p class="secthead"><a name="book_part1_chap3__chap3_sect1">加载适当的网络模块</a></p>
<p>
安装光盘在启动时，会尝试检测所有硬件设备并加载适当的内核模块（驱动程序）以支持你的硬件。绝大多数情况下，它都做得非常好。尽管如此，某些情况下它还是可能无法自动载入你需要的内核模块。
</p>
<p>
如果<span class="code" dir="ltr">net-setup</span>或<span class="code" dir="ltr">pppoe-setup</span>执行失败，那么很可能是没有一下子找到你的网卡。这意味着你将不得不手动加载适当的内核模块。
</p>
<p>
要找出我们为网络提供了哪些内核模块，请使用<span class="code" dir="ltr">ls</span>：
</p>
<a name="book_part1_chap3__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 搜索所提供的模块</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ls /lib/modules/`uname -r`/kernel/drivers/net</span>
</pre></td></tr>
</tbody></table>
<p>
如果找到了你的网卡的驱动程序，请使用<span class="code" dir="ltr">modprobe</span>来加载这个内核模块：
</p>
<a name="book_part1_chap3__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 使用modprobe加载一个内核模块</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（作为一个例子，我们载入pcnet32模块）</span>
# <span class="code-input">modprobe pcnet32</span>
</pre></td></tr>
</tbody></table>
<p>
现在用<span class="code" dir="ltr">ifconfig</span>检查一下是否检测到你的网卡了。成功检测到的网卡会输出类似下面这样的信息：
</p>
<a name="book_part1_chap3__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 测试网卡是否可用，成功</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ifconfig eth0</span>
eth0      Link encap:Ethernet  HWaddr FE:FD:00:00:00:00  
          BROADCAST NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
</pre></td></tr>
</tbody></table>
<p>
不过如果你得到如下错误信息，说明没有检测到网卡。
</p>
<a name="book_part1_chap3__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 测试网卡是否可用，失败</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ifconfig eth0</span>
eth0: error fetching interface information: Device not found
</pre></td></tr>
</tbody></table>
<p>
如果你的系统中存在多块网卡，分别名为<span class="emphasis">eth0</span>、<span class="emphasis">eth1</span>等等。确保你想要使用的那张网卡没有问题，并在阅读本文整篇文章时都记得使用它正确的名字。我们假定使用的是<span class="emphasis">eth0</span>这张网卡。
</p>
<p>
假如你现在拥有一张成功检测到的网卡，可以再试一试<span class="code" dir="ltr">net-setup</span>或<span class="code" dir="ltr">pppoe-setup</span>（现在应该能正常使用了）。不过对于用户中的喜欢刨根究底的人，我们会为你解释如何通过手动配置网络。
</p>
<p>
基于你的网络设置，请从以下列表中选择相应的章节继续：
</p>
<ul>
  <li>
<a href="#install-dhcp">使用DHCP</a>自动获取IP</li>
  <li>
    <a href="#wireless">预备无线网络接入</a>如果你有一张无线网卡
  </li>
  <li>
    <a href="#network_term">理解网络术语</a>解释了你需要了解哪些关于网络方面的知识
  </li>
  <li>
    <a href="#ifconfig_route">使用ifconfig和route</a>解释了如何手动设置你的网络
  </li>
</ul>
<p class="secthead"><a name="install-dhcp"></a><a name="book_part1_chap3__chap3_sect2">使用DHCP</a></p>
<p>
DHCP（动态主机配置协议）可以让你自动获得网络信息（IP地址、子网掩码、广播地址、网关以及域名服务器等）。只有在你的网络中拥有一台DHCP服务器时才能获得（或者你的网络服务提供商提供DHCP服务）。执行<span class="code" dir="ltr">dhcpcd</span>使网络接口自动获得这些信息：
</p>
<a name="book_part1_chap3__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: 使用dhcpcd</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">dhcpcd eth0</span>
<span class="code-comment">一些网络管理员要求你使用DHCP服务器所提供的主机名和域名。</span>
<span class="code-comment">这种情况下请用</span>
# <span class="code-input">dhcpcd -HD eth0</span>
</pre></td></tr>
</tbody></table>
<p>
如果工作正常（尝试ping一些互联网上的服务器，比如<a href="http://www.google.com/">Google</a>），那么你就完全准备好继续下一步了。略过本章的余下部分并继续阅读<a href="#book_part1_chap4">预备磁盘</a>。
</p>
<p class="secthead"><a name="wireless"></a><a name="book_part1_chap3__chap3_sect3">预备无线网络接入</a></p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
<span class="code" dir="ltr">iwconfig</span>命令仅在x86、amd64和ppc安装光盘中提供。不过在其他情况下，你仍可以按照<a href="ftp://ftp.linux-wlan.org/pub/linux-wlan-ng/README">linux-wlan-ng项目</a>的介绍，来使无线扩展运作起来。
</p></td></tr></tbody></table>
<p>
如果你正在使用一张无线（802.11）网卡，那么在继续任何一步之前你需要先配好无线设置。要查看当前的无线网卡设置，可以使用<span class="code" dir="ltr">iwconfig</span>。执行<span class="code" dir="ltr">iwconfig</span>会显示以下类似信息：
</p>
<a name="book_part1_chap3__chap3_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.6: 显示当前无线设置</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">iwconfig eth0</span>
eth0      IEEE 802.11-DS  ESSID:"GentooNode"                                   
          Mode:Managed  Frequency:2.442GHz  Access Point: 00:09:5B:11:CC:F2    
          Bit Rate:11Mb/s   Tx-Power=20 dBm   Sensitivity=0/65535               
          Retry limit:16   RTS thr:off   Fragment thr:off                       
          Power Management:off                                                  
          Link Quality:25/10  Signal level:-51 dBm  Noise level:-102 dBm        
          Rx invalid nwid:5901 Rx invalid crypt:0 Rx invalid frag:0 Tx          
          excessive retries:237 Invalid misc:350282 Missed beacon:84            
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
一些无线网卡的设备名可能为<span class="code" dir="ltr">wlan0</span>或<span class="code" dir="ltr">ra0</span>，而不是<span class="code" dir="ltr">eth0</span>。执行不带任何命令行参数的<span class="code" dir="ltr">iwconfig</span>以确定正确的设备名。
</p></td></tr></tbody></table>
<p>对大多数用户来说，可能只有两处设置需要重点修改，即ESSID（亦称无线网络名）或WEP密钥。如果前面列出的ESSID和AP地址正是你的无线
AP的ESSID和地址，并且你不使用WEP，那么你的无线网络已工作正常。如果你需要修改你的ESSID或添加一个WEP密钥，可以参照下列命令：
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果你的无线网络使用的是WPA或者WPA2，你将需要使用<span class="code" dir="ltr">wpa_supplicant</span>。欲获取更多有关在Gentoo Linux里配置无线网络的信息，请阅读Gentoo手册中的<a href="#book_part4_chap4">无线网络</a>一章。
</p></td></tr></tbody></table>
<a name="book_part1_chap3__chap3_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.7: 修改ESSID和/或添加WEP密钥</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（这里设置网络名为“GentooNode”）</span>
# <span class="code-input">iwconfig eth0 essid GentooNode</span>

<span class="code-comment">（这里设置一个十六进制WEP密钥）</span>
# <span class="code-input">iwconfig eth0 key 1234123412341234abcd</span>

<span class="code-comment">（这里设置一个ASCII密钥——以"s:"作为前缀)</span>
# <span class="code-input">iwconfig eth0 key s:某密钥</span>
</pre></td></tr>
</tbody></table>
<p>
然后可以使用<span class="code" dir="ltr">iwconfig</span>再次确认你的无线设置。一旦你配好无线设置，就可以继续配置下一节（<a href="#network_term">理解网络术语</a>）所述的IP级别的网络选项，或者可以使用前面所述的<span class="code" dir="ltr">net-setup</span>工具。
</p>
<p class="secthead"><a name="network_term"></a><a name="book_part1_chap3__chap3_sect4">理解网络术语</a></p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果你知道IP地址、广播地址、子网掩码和域名服务器，那你就可以略过本节并继续阅读<a href="#ifconfig_route">使用ifconfig和route</a>。
</p></td></tr></tbody></table>
<p>
如果以上所做的全部失败，你将不得不手动配置你的网络。这其实一点也不难。不过，你需要熟悉一些网络术语，才能配置好网络令自己满意。读完本节之后，你将了解到什么是<span class="emphasis">网关</span>，<span class="emphasis">子网掩码</span>是作什么用的，<span class="emphasis">广播地址</span>是如何形成的，以及为什么需要<span class="emphasis">域名服务器</span>。
</p>
<p>
在一个网络中，所有主机都通过IP地址（互联网协议地址）来识别。一个这种地址是由四个0到255之间的整数组合成的。嗯，至少我们是这样认识它的。实际上，一个IP地址由32个比特（0和1）组成。让我们看一个例子：
</p>
<a name="book_part1_chap3__chap3_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.8: IP地址的一个例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>IP地址（整数）：   192.168.0.2
IP地址（位）：     11000000 10101000 00000000 00000010
                   -------- -------- -------- --------
                      192      168       0        2
</pre></td></tr>
</tbody></table>
<p>
在所有可访问到的网络里，这样的IP地址跟主机是一一对应的（比如你能够连接到的每台主机必须拥有一个唯一的IP地址）。为了区别一个网络内部和外部的主机，IP地址被分为两个部分：<span class="emphasis">网络</span>部分和<span class="emphasis">主机</span>部分。
</p>
<p>
<span class="emphasis">子网掩码</span>用来描述这种区分，它由一系列的1跟随着一系列的0组成。IP中映射在1上的部分为网络部分，另一部分为主机部分。照例，子网掩码可以描述为IP地址的形式。
</p>
<a name="book_part1_chap3__chap3_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.9: 区分网络/主机的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>IP地址：        192      168      0         2
              11000000 10101000 00000000 00000010
子网掩码：    11111111 11111111 11111111 00000000
                 255      255     255        0
             +--------------------------+--------+
                      网络                 主机
</pre></td></tr>
</tbody></table>
<p>
也就是说，192.168.0.14仍是我们的例子网络中的成员，而192.168.1.2就不是了。
</p>
<p>
<span class="emphasis">广播</span>地址是一个跟你的网络在同一个网段的IP地址，只是它的主机部分全部为1。你的网络中所有的主机都监听这个IP地址。它真正的用途是用来广播数据包。
</p>
<a name="book_part1_chap3__chap3_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.10: 广播地址</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>IP地址：      192      168      0         2
            11000000 10101000 00000000 00000010
广播：      11000000 10101000 00000000 11111111
               192      168      0        255
           +--------------------------+--------+
                     网络                主机
</pre></td></tr>
</tbody></table>
<p>
为了能在互联网上冲浪，你必须知道是哪台主机在共享Internet连接。这台主机称为<span class="emphasis">网关</span>。由于它是一台普通主机，所以它有一个普通的IP地址（比如192.168.0.1）。
</p>
<p>
前面我们陈述了每台主机拥有它自己的IP地址。为了能够通过域名（而不是IP地址）连到这台主机，你需要一种服务，以将一个域名（如<span class="emphasis">dev.gentoo.org</span>）翻译成一个IP地址（如<span class="emphasis">64.5.62.82</span>）。这种服务称为域名服务。你必须在<span class="path" dir="ltr">/etc/resolv.conf</span>中定义必要的<span class="emphasis">域名服务器</span>以享用这种服务。
</p>
<p>
某些情况下，你的网关也作为域名服务器提供服务。否则就必须加入ISP提供的域名服务器。
</p>
<p>
总结一下，继续下一步之前你需要了解下列知识：
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>网络名词</b></th>
  <th class="infohead" style="text-align: left;"><b>范例</b></th>
</tr>
<tr>
  <td class="tableinfo">你的IP地址</td>
  <td class="tableinfo">192.168.0.2</td>
</tr>
<tr>
  <td class="tableinfo">子网掩码</td>
  <td class="tableinfo">255.255.255.0</td>
</tr>
<tr>
  <td class="tableinfo">广播</td>
  <td class="tableinfo">192.168.0.255</td>
</tr>
<tr>
  <td class="tableinfo">网关</td>
  <td class="tableinfo">192.168.0.1</td>
</tr>
<tr>
  <td class="tableinfo">域名服务器</td>
  <td class="tableinfo">195.130.130.5, 195.130.130.133</td>
</tr>
</tbody></table>
<p class="secthead"><a name="ifconfig_route"></a><a name="book_part1_chap3__chap3_sect5">使用ifconfig和route</a></p>
<p>
设置网络包括三个步骤。首先我们使用<span class="code" dir="ltr">ifconfig</span>为自己设置一个IP地址。然后使用<span class="code" dir="ltr">route</span>设置到网关的路由。最后我们通过将域名服务器的IP写入<span class="path" dir="ltr">/etc/resolv.conf</span>来结束整个过程。
</p>
<p>
为了设置一个IP地址，你需要先获得你的IP地址、广播地址和子网掩码。然后执行以下命令，用你的IP地址、广播地址和子网掩码分别替代<span class="code" dir="ltr">${IP地址}</span>、<span class="code" dir="ltr">${广播}</span>和<span class="code" dir="ltr">${子网掩码}</span>。
</p>
<a name="book_part1_chap3__chap3_pre11"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.11: 使用ifconfig</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ifconfig eth0 ${IP地址} broadcast ${广播} netmask ${子网掩码} up</span>
</pre></td></tr>
</tbody></table>
<p>
现在使用<span class="code" dir="ltr">route</span>设置路由。用你的网关IP地址代替<span class="code" dir="ltr">${网关}</span>：
</p>
<a name="book_part1_chap3__chap3_pre12"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.12: 使用route</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">route add default gw ${网关}</span>
</pre></td></tr>
</tbody></table>
<p>
现在用你喜欢的编辑器（我们的例子中使用<span class="code" dir="ltr">nano</span>）打开<span class="path" dir="ltr">/etc/resolv.conf</span>：
</p>
<a name="book_part1_chap3__chap3_pre13"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.13: 创建/etc/resolv.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/resolv.conf</span>
</pre></td></tr>
</tbody></table>
<p>
现在使用下面的模板填写你的域名服务器。注意用适当的域名服务器地址替换<span class="code" dir="ltr">${域名服务器1}</span>和<span class="code" dir="ltr">${域名服务器2}</span>。
</p>
<a name="book_part1_chap3__chap3_pre14"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.14: /etc/resolv.conf模板</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>nameserver ${域名服务器1}
nameserver ${域名服务器2}
</pre></td></tr>
</tbody></table>
<p>
这就是全部了。现在通过ping一些互联网上的服务器（比如<a href="http://www.google.com/">Google</a>）来测试一下你的网络。如果一切正常，那就恭喜了。你现在已准备好开始安装Gentoo了。接下来请继续阅读<a href="#book_part1_chap4">预备磁盘</a>。
</p>
<a name="book_part1_chap4"></a><h3>4. 准备磁盘</h3>
<p class="chaphead"><a name="book_part1_chap4__chap1"></a><span class="chapnum">4.a. </span>块设备介绍</p>
<p class="secthead"><a name="blockdevicesdesc"></a><a name="book_part1_chap4__chap1_sect1">块设备</a></p>
<p>
我们要好好了解下Gentoo Linux以及普通Linux中有关磁盘方面的知识，包括Linux文件系统、分区和块设备。然后，一旦你熟悉了磁盘和文件的方方面面，我们将会指导你设置分区和文件系统，为你安装Gentoo Linux做好准备。
</p>
<p>
一开始我们先介绍<span class="emphasis">块设备</span>。最有名的块设备可能就是Linux系统中表示第一个IDE硬盘的<span class="path" dir="ltr">/dev/sda</span>。SCSI硬盘和Serial ATA硬盘都是<span class="path" dir="ltr">/dev/sda</span>。如果你正在使用内核里新的libata架构，即便IDE硬盘也会是<span class="path" dir="ltr">/dev/sd*</span>。如果你用的是旧的设备架构，你的第一个IDE硬盘将是<span class="path" dir="ltr">/dev/hda</span>。
</p>
<p>
上面介绍的块设备代表磁盘的抽象接口。用户程序可以使用这些块设备来与你的磁盘进行交互，而不用理会你的驱动器到底是IDE、SCSI还是其他的。程序可以把磁盘当作一系列连续的、可随机访问的512字节大小的块来访问。
</p>
<p class="secthead"><a name="book_part1_chap4__chap1_sect2">分区</a></p>
<p>
尽管在理论上可以使用一整块磁盘来安装你的Linux系统，但是在实际中几乎从不这样做。相反，整个磁盘块设备被分割成更小、更容易管理的块设备。在x86系统中，这些被称作<span class="emphasis">分区</span>。
</p>
<p>
分区有三种类型：<span class="emphasis">主分区</span>，<span class="emphasis">扩展分区</span>和<span class="emphasis">逻辑分区</span>。
</p>
<p>
<span class="emphasis">主分区</span>是把自己的信息储存在MBR（主引导记录）中的分区。由于MBR非常小（512个字节），所以仅可以定义4个主分区（例如，<span class="path" dir="ltr">/dev/sda1</span>到<span class="path" dir="ltr">/dev/sda4</span>）。
</p>
<p>
扩展分区是一种特殊的主分区（意味着扩展分区必须是4个可能的主分区之一），它包含着更多的分区。这种分区最初并不存在，但是由于4个主分区太少了，为了能划分更多的分区，在保持向后的兼容性的前提下扩展分区诞生了。
</p>
<p>
<span class="emphasis">逻辑分区</span>是在扩展分区内部的分区。它们的定义不在MBR中，而是在扩展分区中。
</p>
<p class="secthead"><a name="book_part1_chap4__chap1_sect3">高级存储</a></p>
<p>
此x86安装光盘提供了对EVMS和LVM2的支持。EVMS和LVM2提高了你的分区设置的灵活性。在安装指南中，我们将把精力集中在“常规”分区上，但是了解一下我们支持EVMS和LVM2也是有好处的。
</p>
<p class="chaphead"><a name="book_part1_chap4__chap2"></a><span class="chapnum">4.b. </span>设计分区方案</p>
<p class="secthead"><a name="book_part1_chap4__chap2_sect1">默认分区方案</a></p>
<p>
如果你没有兴趣为你的系统设计分区方案，你可以使用我们在本手册中使用的方案：
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>分区</b></th>
  <th class="infohead" style="text-align: left;"><b>文件系统</b></th>
  <th class="infohead" style="text-align: left;"><b>大小</b></th>
  <th class="infohead" style="text-align: left;"><b>说明</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="path" dir="ltr">/dev/sda1</span></td>
  <td class="tableinfo">ext2</td>
  <td class="tableinfo">32M</td>
  <td class="tableinfo">启动分区</td>
</tr>
<tr>
  <td class="tableinfo"><span class="path" dir="ltr">/dev/sda2</span></td>
  <td class="tableinfo">(swap)</td>
  <td class="tableinfo">512M</td>
  <td class="tableinfo">交换分区</td>
</tr>
<tr>
  <td class="tableinfo"><span class="path" dir="ltr">/dev/sda3</span></td>
  <td class="tableinfo">ext3</td>
  <td class="tableinfo">剩余磁盘</td>
  <td class="tableinfo">根分区</td>
</tr>
</tbody></table>
<p>
如果你想知道一个分区应该多大，或者你需要多少个分区，继续阅读。否则请阅读<a href="#fdisk">使用fdisk来为你的磁盘分区</a>来给你的磁盘分区。
</p>
<p class="secthead"><a name="book_part1_chap4__chap2_sect2">多少和多大？</a></p>
<p>
分区的数目主要根据你的系统环境来决定。例如，如果你有很多用户，你可能更希望把你的<span class="path" dir="ltr">/home</span>目录独立出来，因为这样做可以增加安全性，备份起来也更容易。如果你安装Gentoo用来做邮件服务器，你的<span class="path" dir="ltr">/var</span>目录应该独立出来，因为邮件都存储在<span class="path" dir="ltr">/var</span>目录中。选择一个好的文件系统将最大限度地提高你的系统性能。游戏服务器应该把<span class="path" dir="ltr">/opt</span>目录独立出来，因为大多数游戏服务端软件都安装在那。理由也与<span class="path" dir="ltr">/home</span>目录类似：安全与备份。你一定要使<span class="path" dir="ltr">/usr </span>目录保持足够大：因为它将不仅包含大部分应用程序，而且Portage树本身就需要大约500M空间，这还不包括存储在其中的各种源代码包。
</p>
<p>
正如你所看到的，这完全取决于你想要达到什么目的。独立的分区或卷有以下优点：
</p>
<ul>
<li>
  你可以为每一个分区或卷选择最佳性能的文件系统
</li>
<li>
  如果一个有问题的工具不停地向一个分区或卷写文件，也不会把你整个系统的可用空间都用完
</li>
<li>
  如果需要，可以减少文件系统检测的时间，因为多个检测可以并行的进行（尽管这个优势在多磁盘系统上比多分区系统上更为明显）
</li>
<li>
  通过对一些分区的进行只读、nosuid（忽略setuid位）、noexec（忽略可执行位）等方式挂载，安全性会大大增强
</li>
</ul>
<p>
然而，多分区系统有一大缺点：如果配置的不合理，可能导致系统中一个分区有很大的空闲空间，而另一个没有空闲空间了。SCSI和SATA还有15个分区的限制。
</p>
<p>
作为分区的例子，我们向你示范一个用于演示的有20GB磁盘的笔记本（包含网站服务器、邮件服务器、gnome……）：
</p>
<a name="book_part1_chap4__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 文件系统使用实例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">df -h</span>
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/sda5     ext3    509M  132M  351M  28% /
/dev/sda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/sda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/sda8     ext3   1011M  483M  477M  51% /opt
/dev/sda9     ext3    2.0G  607M  1.3G  32% /var
/dev/sda1     ext2     51M   17M   31M  36% /boot
/dev/sda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<span class="code-comment">（留作它用的未分配空间：2GB）</span>
</pre></td></tr>
</tbody></table>
<p>
这里的<span class="path" dir="ltr">/usr</span>快满了（使用了83%），但是一旦所有的软件都安装好了，<span class="path" dir="ltr">/usr</span>目录就不会如此的增长了。尽管分配给<span class="path" dir="ltr">/var</span>目录的空间看似过多了，但是要记住，Portage默认使用这个分区来编译软件包。如果你想使你的<span class="path" dir="ltr">/var</span>目录保持一个合理的大小，如1GB，你需要更改<span class="path" dir="ltr">/etc/make.conf </span>文件中的<span class="code" dir="ltr">PORTAGE_TMPDIR</span>来指定一个拥有足够的空闲空间的分区，用以编译诸如OpenOffice这样巨大的软件包。
</p>
<p class="chaphead"><a name="fdisk"></a><a name="book_part1_chap4__chap3"></a><span class="chapnum">4.c. </span>使用fdisk来为你的磁盘分区</p>
<p>
下面来解释如何创建前面说明的那个示例分区布局，即：
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>分区</b></th>
  <th class="infohead" style="text-align: left;"><b>说明</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="path" dir="ltr">/dev/sda1</span></td>
  <td class="tableinfo">启动分区</td>
</tr>
<tr>
  <td class="tableinfo"><span class="path" dir="ltr">/dev/sda2</span></td>
  <td class="tableinfo">交换分区</td>
</tr>
<tr>
  <td class="tableinfo"><span class="path" dir="ltr">/dev/sda3</span></td>
  <td class="tableinfo">根分区</td>
</tr>
</tbody></table>
<p>
根据你自己的喜好来改变分区布局。
</p>
<p class="secthead"><a name="book_part1_chap4__chap3_sect2">查看当前分区布局</a></p>
<p>
<span class="code" dir="ltr">fdisk</span>是一个流行且强大的工具，用来把你的磁盘划分为分区。启动你磁盘上<span class="code" dir="ltr">fdisk</span>程序（在示例中，我们使用<span class="path" dir="ltr">/dev/sda</span>）：
</p>
<a name="book_part1_chap4__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 启动fdisk</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">fdisk /dev/sda</span>
</pre></td></tr>
</tbody></table>
<p>
一旦启动到fdisk中，你将看到如下提示：
</p>
<a name="book_part1_chap4__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: fdisk提示</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): 
</pre></td></tr>
</tbody></table>
<p>
键入<span class="code" dir="ltr">p</span>来显示你的磁盘的当前分区配置：
</p>
<a name="book_part1_chap4__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 分区配置示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">p</span>

Disk /dev/sda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1        14    105808+  83  Linux
/dev/sda2            15        49    264600   82  Linux swap
/dev/sda3            50        70    158760   83  Linux
/dev/sda4            71      2184  15981840    5  Extended
/dev/sda5            71       209   1050808+  83  Linux
/dev/sda6           210       348   1050808+  83  Linux
/dev/sda7           349       626   2101648+  83  Linux
/dev/sda8           627       904   2101648+  83  Linux
/dev/sda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre></td></tr>
</tbody></table>
<p>
这个磁盘配置包含了7个Linux文件系统（每个对应于列表中名为“Linux”的分区）及一个交换分区（列表中的“Linux swap”）。
</p>
<p class="secthead"><a name="book_part1_chap4__chap3_sect3">删除所有分区</a></p>
<p>
首先，我们将把磁盘上的所有分区删除。键入<span class="code" dir="ltr">d</span>来删除一个分区。例如，要删除存在的<span class="path" dir="ltr">/dev/sda1</span>：
</p>
<a name="book_part1_chap4__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 删除分区</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">d</span>
Partition number (1-4): <span class="code-input">1</span>
</pre></td></tr>
</tbody></table>
<p>
该分区就会被列入删除计划。如果你键入<span class="code" dir="ltr">p</span>，它也不会再出现了，然而除非你保存了所做的修改，否则它并没有被真正删除。如果你犯了一个错误，想不保存修改并退出，立刻键入<span class="code" dir="ltr">q</span>并回车，你分区就不会被删除。
</p>
<p>
现在，假设你真的想删除你系统中的所有分区，键入<span class="code" dir="ltr">p</span>来显示分区列表，然后键入<span class="code" dir="ltr">d</span>和要删除的分区的数字，并重复此过程。最后，当分区表中什么也没有的时候你就可以结束了：
</p>
<a name="book_part1_chap4__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: 空的分区表</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre></td></tr>
</tbody></table>
<p>
现在，内存中的分区表是空的，我们就可以创建分区了。我们将使用前面讨论过的那个默认的分区布局。当然，如果你不想要相同的分区方案就不要按照下面的指令来做！
</p>
<p class="secthead"><a name="book_part1_chap4__chap3_sect4">创建启动分区</a></p>
<p>
首先，我们创建一个小一点的启动分区。键入<span class="code" dir="ltr">n</span>创建一个新分区，然后键入<span class="code" dir="ltr">p</span>来选择一个主分区，接下来键入<span class="code" dir="ltr">1</span>选择第一个主分区。当提示输入第一个柱面的时候，敲回车键。当提示输入最后一个柱面的时候，输入<span class="code" dir="ltr">+32M</span>，来创建一个32M大小的分区：
</p>
<a name="book_part1_chap4__chap3_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.6: 创建启动分区</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">n</span>
Command action
  e   extended
  p   primary partition (1-4)
<span class="code-input">p</span>
Partition number (1-4): <span class="code-input">1</span>
First cylinder (1-3876, default 1): <span class="code-comment">（按回车）</span>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <span class="code-input">+32M</span>
</pre></td></tr>
</tbody></table>
<p>
现在，当你键入<span class="code" dir="ltr">p</span>时，你应该看到如下的分区输出：
</p>
<a name="book_part1_chap4__chap3_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.7: 已创建的启动分区</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">p</span>

Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/sda1          1        14    105808+  83  Linux
</pre></td></tr>
</tbody></table>
<p>
我们需要把这个分区设置成可启动的。键入<span class="code" dir="ltr">a</span>来给分区添加启动标志，然后键入<span class="code" dir="ltr">1</span>。如果你再次按<span class="code" dir="ltr">p</span>键，你就会注意到，在“Boot”那一列有个<span class="path" dir="ltr">*</span>。
</p>
<p class="secthead"><a name="book_part1_chap4__chap3_sect5">创建交换分区</a></p>
<p>
我们现在来创建交换分区。键入<span class="code" dir="ltr">n</span>创建一个新分区，然后键入<span class="code" dir="ltr">p</span>来告诉fdisk你创建的是主分区。接着输入<span class="code" dir="ltr">2</span>来创建第2个主分区，在本例中是<span class="path" dir="ltr">/dev/sda2</span>。当提示输入第一个柱面的时候，直接敲回车。当提示输入最后一个柱面的时候，输入<span class="code" dir="ltr">+512M</span>来创建一个512MB大小的分区。在这之后，键入<span class="code" dir="ltr">t</span>来设置分区类型，键入<span class="code" dir="ltr">2</span>选择你刚刚创建的那个分区，然后再输入<span class="code" dir="ltr">82</span>把分区类型设置成“Linux Swap”。完成以上这些步骤之后，键入<span class="code" dir="ltr">p</span>，应该显示一个与下面类似的分区表：
</p>
<a name="book_part1_chap4__chap3_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.8: 创建交换分区后的分区列表</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">p</span>

Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/sda1 *        1        14    105808+  83  Linux
/dev/sda2         15        81    506520   82  Linux swap
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap4__chap3_sect6">创建根分区</a></p>
<p>
最后，我们来创建根分区。键入<span class="code" dir="ltr">n</span>创建一个新分区，然后键入<span class="code" dir="ltr">p</span>来告诉fdisk你创建的是主分区。接着输入<span class="code" dir="ltr">3</span>来创建第3个主分区，在本例中是<span class="path" dir="ltr">/dev/sda3</span>。当提示输入第一个柱面的时候，直接敲回车。当提示输入最后一个柱面的时候，单击回车把你磁盘上的剩余空间创建一个分区。完成以上这些步骤之后，键入<span class="code" dir="ltr">p</span>，应该显示一个与下面类似的分区表：
</p>
<a name="book_part1_chap4__chap3_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.9: 创建根分区后的分区列表</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">p</span>

Disk /dev/sda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/sda1 *        1        14    105808+  83  Linux
/dev/sda2         15        81    506520   82  Linux swap
/dev/sda3         82      3876  28690200   83  Linux
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap4__chap3_sect7">保存分区布局</a></p>
<p>
键入<span class="code" dir="ltr">w</span>来保存分区布局并退出<span class="code" dir="ltr">fdisk</span>。
</p>
<a name="book_part1_chap4__chap3_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.10: 保存并退出fdisk</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Command (m for help): <span class="code-input">w</span>
</pre></td></tr>
</tbody></table>
<p>
现在分区已经创建完毕，你可以继续<a href="#filesystems">创建文件系统</a>。
</p>
<p class="chaphead"><a name="filesystems"></a><a name="book_part1_chap4__chap4"></a><span class="chapnum">4.d. </span>创建文件系统</p>
<p class="secthead"><a name="book_part1_chap4__chap4_sect1">介绍</a></p>
<p>
你的分区已经创建完了，现在可以在上面安装文件系统了。如果你并不介意选择何种文件系统，而且乐意使用本手册中所使用的默认设置，请阅读<a href="#filesystems-apply">在分区上应用文件系统</a>。否则，继续阅读本文来了解可用的文件系统……
</p>
<p class="secthead"><a name="filesystemsdesc"></a><a name="book_part1_chap4__chap4_sect2">文件系统</a></p>
<p>
Linux内核支持各种各样的文件系统。我们将介绍ext2、ext3、ReiserFS、XFS和JFS，因为它们是Linux系统中使用最普遍的文件系统。
</p>
<p>
<b>ext2</b>是经考验证明可靠的Linux文件系统，但是没有元数据日志，这意味这在启动系统时的ext2文件系统的日常检查相当耗时。现在相
当一部分的新一代的日志文件系统都可以非常迅速检查一致性，因此比那些非日志文件系统更受欢迎。当你启动系统碰巧遇到文件系统状态不一致时，日志文件系统
不会在那里耽搁很长时间。
</p>
<p>
<b>ext3</b>是ext2文件系统的带日志版本，提供了元数据日志模式以快速恢复数据。此外还提供了其他增强的日志模式，如完整数据日志模式和有序数据日志模式。它使用了HTree索引，在几乎所有的情况下都能保持高性能。简而言之，ext3是非常好及可靠的文件系统。
</p>
<p>
<b>JFS</b>是IBM的高性能日志文件系统。JFS是一个轻量级的、快速的和稳定的基于B+树的文件系统，在很多情况下都有很好的表现。
</p>
<p>
<b>ReiserFS</b>是基于B+树的文件系统，它有着非常全面的性能，特别时在处理很多小文件的时候，虽然会占用多一点CPU。ReiserFS相比其他文件系统显得受维护的不够。
</p>
<p>
<b>XFS</b>是一种带元数据日志的文件系统，它有一个健壮的特性集，并且对可伸缩性进行了优化。XFS似乎对各种各样的硬件问题显得不够宽容。
</p>
<p class="secthead"><a name="filesystems-apply"></a><a name="book_part1_chap4__chap4_sect3">在分区上应用文件系统</a></p>
<p>
要在分区或卷上创建文件系统，对于每种可能的文件系统都有专门的工具。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>文件系统</b></th>
  <th class="infohead" style="text-align: left;"><b>创建命令</b></th>
</tr>
<tr>
  <td class="tableinfo">ext2</td>
  <td class="tableinfo"><span class="code" dir="ltr">mke2fs</span></td>
</tr>
<tr>
  <td class="tableinfo">ext3</td>
  <td class="tableinfo"><span class="code" dir="ltr">mke2fs -j</span></td>
</tr>
<tr>
  <td class="tableinfo">reiserfs</td>
  <td class="tableinfo"><span class="code" dir="ltr">mkreiserfs</span></td>
</tr>
<tr>
  <td class="tableinfo">xfs</td>
  <td class="tableinfo"><span class="code" dir="ltr">mkfs.xfs</span></td>
</tr>
<tr>
  <td class="tableinfo">jfs</td>
  <td class="tableinfo"><span class="code" dir="ltr">mkfs.jfs</span></td>
</tr>
</tbody></table>
<p>
例如，要使启动分区（本例中的<span class="path" dir="ltr">/dev/sda1</span>）为ext2和根分区（本例中的<span class="path" dir="ltr">/dev/sda3</span>）为ext3,应该这样做：
</p>
<a name="book_part1_chap4__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 在分区上应用文件系统</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mke2fs /dev/sda1</span>
# <span class="code-input">mke2fs -j /dev/sda3</span>
</pre></td></tr>
</tbody></table>
<p>
现在在你新建的分区（或逻辑卷）上创建文件系统。
</p>
<p class="secthead"><a name="book_part1_chap4__chap4_sect4">激活交换分区</a></p>
<p>
<span class="code" dir="ltr">mkswap</span>是初始化交换分区的命令：
</p>
<a name="book_part1_chap4__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: 创建交换分区标志</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mkswap /dev/sda2</span>
</pre></td></tr>
</tbody></table>
<p>
使用<span class="code" dir="ltr">swapon</span>命令来激活交换分区：
</p>
<a name="book_part1_chap4__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: 激活交换分区</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">swapon /dev/sda2</span>
</pre></td></tr>
</tbody></table>
<p>
使用上面提到的命令来创建和激活交换分区。
</p>
<p class="chaphead"><a name="book_part1_chap4__chap5"></a><span class="chapnum">4.e. </span>挂载</p>
<p>
现在你的分区都已经初始化了，并且安装了文件系统，是时候来挂载这些分区了。使用<span class="code" dir="ltr">mount</span>命令进行挂载。别忘记为每个你创建的分区建立所需的挂载目录。作为例子，我们来挂载根分区和启动分区：
</p>
<a name="book_part1_chap4__chap5_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.1: 挂载分区</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mount /dev/sda3 /mnt/gentoo</span>
# <span class="code-input">mkdir /mnt/gentoo/boot</span>
# <span class="code-input">mount /dev/sda1 /mnt/gentoo/boot</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果你希望<span class="path" dir="ltr">/tmp</span>目录在一个独立的分区上，确保在挂载之后修改它的权限：<span class="code" dir="ltr">chmod 1777 /mnt/gentoo/tmp</span>。这同样适用于<span class="path" dir="ltr">/var/tmp</span>目录。
</p></td></tr></tbody></table>
<p>
我们还需要在<span class="path" dir="ltr">/proc</span>目录上挂载proc文件系统（内核的虚拟接口）。但是，我们首先需要把我们的文件放到分区上。
</p>
<p>
请继续阅读<a href="#book_part1_chap5">安装Gentoo安装文件</a>。
</p>
<a name="book_part1_chap5"></a><h3>5. 安装Gentoo安装文件</h3>
<p class="chaphead"><a name="book_part1_chap5__chap1"></a><span class="chapnum">5.a. </span>安装一个Stage Tarball</p>
<p class="secthead"><a name="book_part1_chap5__chap1_sect1">正确设置日期／时间</a></p>
<p>
在继续之前，你需要检查和更新系统日期／时间。未正确设置的时钟可能会在将来导致奇怪的结果！
</p>
<p>
确认当前日期／时间，请运行<span class="code" dir="ltr">date</span>：
</p>
<a name="book_part1_chap5__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 确认日期／时间</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">date</span>
Fri Mar 29 16:21:18 UTC 2005
</pre></td></tr>
</tbody></table>
<p>
如果显示的日期／时间不正确，可以使用<span class="code" dir="ltr">date MMDDhhmmYYYY</span>命令（<b>MM</b>是月，<b>DD</b>是日，<b>hh</b>是时，<b>mm</b>是分，<b>YYYY</b>是年）来更新它。在这一步，你应该使用UTC时间。稍后你可以设置你自己的时区。举个例子，设置时间为2005年3月29日16时21分：
</p>
<a name="book_part1_chap5__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 设置UTC日期／时间</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">date 032916212005</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap5__chap1_sect2">做出你的选择</a></p>
<p>
接下来，你要把<span class="emphasis">stage3</span>
tarball安装到系统。你可以选择从网上下载它，或者如果你是使用Gentoo通用安装光盘或者LiveDVD引导系统的话，也可以从光盘里拷贝一个
出来。如果你有通用安装光盘或者LiveDVD且光盘中有你需要的Stage文件的话，就直接用光盘里的吧，否则再从网上下载就是浪费带宽，因为它和网上
下载的是一样的。大多数情况下，运行命令<span class="code" dir="ltr">uname -m</span>可以告诉你哪个stage文件才是你要下载的。
</p>
<p>
最小光盘和LiveCD不包含任何stage文件，不过LiveDVD里有。
</p>
<p class="chaphead"><a name="book_part1_chap5__chap2"></a><span class="chapnum">5.b. </span>默认：使用从网上下载的Stage</p>
<p class="secthead"><a name="book_part1_chap5__chap2_sect1">下载Stage Tarball</a></p>
<p>
进入Gentoo的挂载点，也就是装Gentoo的分区挂载的地方（很可能是<span class="path" dir="ltr">/mnt/gentoo</span>）：
</p>
<a name="book_part1_chap5__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 进入Gentoo的挂载点</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">cd /mnt/gentoo</span>
</pre></td></tr>
</tbody></table>
<p>
根据你使用的安装介质不同，你有好几个工具可用来下载stage。如果有<span class="code" dir="ltr">links</span>，你可以马上连接到<a href="http://www.gentoo.org/main/en/mirrors.xml">Gentoo镜像列表</a>，然后选择一个离你最近的镜像站点来下载。
</p>
<p>
假如你没有可用的<span class="code" dir="ltr">links</span>，那你应该有<span class="code" dir="ltr">lynx</span>。如果你需要通过代理上网的，那么请export <span class="code" dir="ltr">http_proxy</span>和<span class="code" dir="ltr">ftp_proxy</span>这两个变量：
</p>
<a name="book_part1_chap5__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 为lynx设置代理信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">export http_proxy="http://proxy.server.com:port"</span>
# <span class="code-input">export ftp_proxy="http://proxy.server.com:port"</span>
</pre></td></tr>
</tbody></table>
<p>
我们现在假设你使用<span class="code" dir="ltr">links</span>。
</p>
<p>
进入<span class="path" dir="ltr">releases/x86/2008.0/</span>目录里。你将会看到所有适合你的计算机体系结构的stage文件（它们也可能放在各个独立的子体系名称的子目录里）。选择一个，然后按<span class="code" dir="ltr">D</span>来下载。下载完以后，再按<span class="code" dir="ltr">Q</span>退出浏览器。
</p>
<p>
大多数PC用户应该使用<b>stage3-i686-2008.0.tar.bz2</b> stage3文件。所有现代PC都是i686机器。如果你用的是一部旧机器，你可以检查Wikipedia上的<a href="http://en.wikipedia.org/wiki/I686">i686兼容处理器列表</a>。旧的处理器，比如Pentium，K5，K6或者Via C3以及其他类似的，需要普适性的<b>x86</b> stage3。<b>i486</b>之前的处理器不获支持。
</p>
<a name="book_part1_chap5__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 用links连接镜像列表</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">links http://www.gentoo.org/main/en/mirrors.xml</span>

<span class="code-comment">（如果links需要使用代理：）</span>
# <span class="code-input">links -http-proxy proxy.server.com:8080 http://www.gentoo.org/main/en/mirrors.xml</span>
</pre></td></tr>
</tbody></table>
<p>
确保你下载的是<b>stage3</b> tarball——使用stage1或stage2进行安装已经不再被支持。
</p>
<p>
如果你想校验所下载的stage tarball的完整性，使用<span class="code" dir="ltr">md5sum</span>然后把输出同镜像站上提供的MD5校验和对比。
</p>
<a name="book_part1_chap5__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 校验一个stage tarball的完整性</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">md5sum -c stage3-i686-2008.0.tar.bz2.DIGESTS</span>
stage3-i686-2008.0.tar.bz2: OK
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap5__chap2_sect2">解开Stage Tarball</a></p>
<p>
现在把你所下载的stage解压缩到系统里。我们使用<span class="code" dir="ltr">tar</span>命令来做，这是最简单的方法：
</p>
<a name="book_part1_chap5__chap2_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.5: 解开stage</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">tar xvjpf stage3-*.tar.bz2</span>
</pre></td></tr>
</tbody></table>
<p>
确保你使用了同样的参数（<span class="code" dir="ltr">xvjpf</span>）。<span class="code" dir="ltr">x</span>表示解开（<span class="emphasis">Extract</span>），<span class="code" dir="ltr">v</span>表示详细信息（<span class="emphasis">Verbose</span>）可以用来查看解压缩时发生了什么（可选参数），<span class="code" dir="ltr">j</span>表示使用bzip2解压缩，<span class="code" dir="ltr">p</span>表示保留权限（<span class="emphasis">Preserve permissions</span>），还有<span class="code" dir="ltr">f</span>表示我们要解开一个文件，而不是标准输入。
</p>
<p>
现在stage已经安装好，下面我们继续<a href="#installing_portage">安装Portage</a>。
</p>
<p class="chaphead"><a name="installing_portage"></a><a name="book_part1_chap5__chap3"></a><span class="chapnum">5.c. </span>安装Portage</p>
<p class="secthead"><a name="book_part1_chap5__chap3_sect1">解开一个Portage快照</a></p>
<p>
现在你得安装一个Portage的快照，它包含的一堆文件告诉Portage哪些软件可以安装，有哪些profile可用等等。
</p>
<p class="secthead"><a name="installing_from_Internet"></a><a name="book_part1_chap5__chap3_sect2">从网上下载和安装Portage快照</a></p>
<p>
进入Gentoo文件系统的挂载点（很可能是<span class="path" dir="ltr">/mnt/gentoo</span>）：
</p>
<a name="book_part1_chap5__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 进入Gentoo的挂载点</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">cd /mnt/gentoo</span>
</pre></td></tr>
</tbody></table>
<p>
打开<span class="code" dir="ltr">links</span>（或者<span class="code" dir="ltr">lynx</span>）然后到我们的<a href="http://www.gentoo.org/main/en/mirrors.xml">Gentoo镜像列表</a>。选择一个离你最近的镜像，打开<span class="path" dir="ltr">snapshots/</span>目录。然后选择最新的Portage快照（<span class="path" dir="ltr">portage-latest.tar.bz2</span>）并按<span class="code" dir="ltr">D</span>来下载它。
</p>
<a name="book_part1_chap5__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 浏览Gentoo镜像列表</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">links http://www.gentoo.org/main/en/mirrors.xml</span>
</pre></td></tr>
</tbody></table>
<p>
现在按<span class="code" dir="ltr">Q</span>来退出浏览器。你现在已经有一个Portage快照保存在<span class="path" dir="ltr">/mnt/gentoo</span>里了。
</p>
<p>
如果你想校验所下载的快照的完整性，使用<span class="code" dir="ltr">md5sum</span>然后把输出和镜像站提供的MD5校验和比较。
</p>
<a name="book_part1_chap5__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 校验Portage快照的完整性</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">md5sum -c portage-latest.tar.bz2.md5sum</span>
portage-latest.tar.bz2: OK
</pre></td></tr>
</tbody></table>
<p>
下一步，我们要把Portage快照解压缩到你的系统里。确保你使用的解压缩命令里最后一个参数是大写的<span class="code" dir="ltr">C</span>，而不是<span class="code" dir="ltr">c</span>。
</p>
<a name="book_part1_chap5__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 解开Portage快照</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">tar xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="compile_options"></a><a name="book_part1_chap5__chap4"></a><span class="chapnum">5.d. </span>配置编译选项</p>
<p class="secthead"><a name="book_part1_chap5__chap4_sect1">介绍</a></p>
<p>
你可设置一些影响Portage行为的变量来优化Gentoo。这些变量都可作为环境变量来设置（使用<span class="code" dir="ltr">export</span>），但是它们不是永久的。为了保持你的设置，Portage为你提供了<span class="path" dir="ltr">/etc/make.conf</span>，一个Portage的配置文件。这就是我们现在要编辑的文件。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
所有可能的变量都用注释形式罗列在<span class="path" dir="ltr">/mnt/gentoo/etc/make.conf.example</span>里。要成功地安装Gentoo，你只需要设置下面提到的变量。
</p></td></tr></tbody></table>
<p>
打开你喜欢的编辑器（在这个指南里我们使用<span class="code" dir="ltr">nano</span>），这样我们可以改变我们现在和之后将讨论的优化变量。
</p>
<a name="book_part1_chap5__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 打开/etc/make.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /mnt/gentoo/etc/make.conf</span>
</pre></td></tr>
</tbody></table>
<p>
你很可能已经注意到了，<span class="path" dir="ltr">make.conf.example</span>文件的结构和一般的文件一样：注释行以"#"开头，其它行使用<span class="code" dir="ltr">VARIABLE="content"</span>的语法来定义变量。<span class="path" dir="ltr">make.conf</span>文件也使用相同的语法。其中的一些变量我们接下来讨论。
</p>
<p class="secthead"><a name="book_part1_chap5__chap4_sect2">CHOST</a></p>
<p>
<span class="code" dir="ltr">CHOST</span>变量声明了你的系统的target、build和host（译
注：target定义了编译出的工具链产生的代码将运行的系统类型，只在编译工具链时有意义；build定义了本机系统类型；host定义了编译出的软件
将运行的系统类型）。这个变量应该已经被设置为正确的值了。<font color="#ff0000"><b>不要编辑它</b></font>，这可能会毁坏你的系统。如果<span class="code" dir="ltr">CHOST</span>变量看起来是不正确的，你也许使用了错误的stage3 tarball。
</p>
<p class="secthead"><a name="book_part1_chap5__chap4_sect3">CFLAGS和CXXFLAGS</a></p>
<p>
<span class="code" dir="ltr">CFLAGS</span>和<span class="code" dir="ltr">CXXFLAGS</span>变量分别定义了<span class="code" dir="ltr">gcc</span> C和C++编译器的优化标记。尽管我们通常都在这里定义，你也可以对每个软件单独定义这些优化标记以获得最好的性能。因为每个程序都是不同的。
</p>
<p>
在<span class="path" dir="ltr">make.conf</span>里你应该定义一些你认为可以使系统在<span class="emphasis">一般情况</span>下快速响应的优化标记。不要把实验性质的设置放到这个变量里来；过多的优化会使程序表现很差（崩溃，甚至更糟，不正常工作）。
</p>
<p>
我们不会解释所有可能的优化选项。如果你想搞清楚它们，请阅读<a href="http://gcc.gnu.org/onlinedocs/">GNU在线手册</a>或者是<span class="code" dir="ltr">gcc</span> info页面（<span class="code" dir="ltr">info gcc</span>——只能在可工作的Linux系统中查看）。<span class="path" dir="ltr">make.conf.example</span>本身也包含了不少信息和范例；不要忘了也看看它。
</p>
<p>
第一个设置是<span class="code" dir="ltr">-march=</span>或者<span class="code" dir="ltr">-mtune=</span>标记，它指定了目标架构的名字。可能的选项
会在<span class="path" dir="ltr">make.conf.example</span>里有说明（以注释形式出现）。
</p>
<p>
第二个是<span class="code" dir="ltr">-O</span>标记（是大写的O，而不是数字零），它是指定<span class="code" dir="ltr">gcc</span>的优化级别的标记。可能的级别有<span class="code" dir="ltr">s</span>（为优化文件大小），<span class="code" dir="ltr">0</span>（零——不优化），<span class="code" dir="ltr">1</span>、<span class="code" dir="ltr">2</span>或者<span class="code" dir="ltr">3</span>是为了获得更快速度的优化标记（每个级别都包含前一级标记的优化措施，并额外增加了一些）。<span class="code" dir="ltr">-O2</span>是推荐的默认设置。
</p>
<p>
另一个普遍使用的优化标记是<span class="code" dir="ltr">-pipe</span>（不同编译阶段通信使用管道而不是临时文件）。它对产生的代码没有任何影响。
</p>
<p>
使用<span class="code" dir="ltr">-fomit-frame-pointer</span>（它将不在寄存器里为不需要帧指针的函数保存帧指针）可能会在调试程序的时候造成严重后果！
</p>
<p>
在你定义<span class="code" dir="ltr">CFLAGS</span>和<span class="code" dir="ltr">CXXFLAGS</span>的时候，你需要把这些优化标记都合并起来。stage3文件里包含的你解压缩出来的默认值已经足够好了。下面这个例子仅仅是个例子：
</p>
<a name="book_part1_chap5__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: 定义CFLAGS和CXXFLAGS变量</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>CFLAGS="-O2 -march=i686 -pipe"
<span class="code-comment"># 两个变量使用相同的设置</span>
CXXFLAGS="${CFLAGS}"                  
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap5__chap4_sect4">MAKEOPTS</a></p>
<p>
通过使用<span class="code" dir="ltr">MAKEOPTS</span>你可以定义在安装软件的时候同时可以产生并行编译的数目。你的CPU数目加一是个不错的选择，但是这个准则并不永远都是完美的。
</p>
<a name="book_part1_chap5__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: 单CPU系统的MAKEOPTS</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>MAKEOPTS="-j2"
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap5__chap4_sect5">设置已准备好，让我们开始！</a></p>
<p>
根据你的喜好更新<span class="path" dir="ltr">/mnt/gentoo/etc/make.conf</span>并保存（<span class="code" dir="ltr">nano</span>用户可以敲<span class="code" dir="ltr">Ctrl-X</span>）。你现在准备好可以继续<a href="#book_part1_chap6">安装Gentoo基本系统</a>了。
</p>
<a name="book_part1_chap6"></a><h3>6. 安装Gentoo基本系统</h3>
<p class="chaphead"><a name="book_part1_chap6__chap1"></a><span class="chapnum">6.a. </span>Chroot</p>
<p class="secthead"><a name="book_part1_chap6__chap1_sect1">可选：选择境像站点</a></p>
<p>
为了快速下载源代码，建议你选择一个速度快的境像站点。Portage将在<span class="path" dir="ltr">make.conf</span>中查找并使用GENTOO_MIRRORS变量定义的境像列表。你也可以浏览我们的<a href="http://www.gentoo.org/main/en/mirrors.xml">镜像列表</a>来寻找一个或者多个离你最近的镜像（通常它们是最快的），不过我们提供了一个不错的工具来帮助你选择境像，它叫<span class="code" dir="ltr">mirrorselect</span>。
</p>
<a name="book_part1_chap6__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 使用mirrorselect更新GENTOO_MIRRORS变量</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffbbbb"><p class="note"><b>警告: </b>
不要选择任何IPv6的境像。我们的stage目前还不支持IPv6。
</p></td></tr></tbody></table>
<p>
另一个重要的设置就是<span class="path" dir="ltr">make.conf</span>里的SYNC设置。这个变量包含你更新Portage树（Portage下载和安装软件时需要用到的ebuild和脚本等信息的集合）时用到的rsync服务器信息。虽然你可以手动输入一个SYNC服务器地址，不过还是让<span class="code" dir="ltr">mirrorselect</span>来帮你完成更加的方便：
</p>
<a name="book_part1_chap6__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 使用mirrorselect选择rsync镜像站点</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mirrorselect -i -r -o &gt;&gt; /mnt/gentoo/etc/make.conf</span>
</pre></td></tr>
</tbody></table>
<p>
运行完<span class="code" dir="ltr">mirrorselect</span>以后，最好自己再检查一下<span class="path" dir="ltr">/mnt/gentoo/etc/make.conf</span>里的设置！
</p>
<p class="secthead"><a name="book_part1_chap6__chap1_sect2">拷贝DNS信息</a></p>
<p>
在我们进入新环境之前，还有一件事需要完成，那就是从<span class="path" dir="ltr">/etc/resolv.conf</span>拷贝DNS信息。这一步可以保证你在进入新的系统环境后还可以继续使用网络。<span class="path" dir="ltr">/etc/resolv.conf</span>包含了你网络里的域名服务器。
</p>
<a name="book_part1_chap6__chap1_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.3: 拷贝DNS信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（参数"-L"是必须的，用来确保我们拷贝的不是一个符号链接）</span>
# <span class="code-input">cp -L /etc/resolv.conf /mnt/gentoo/etc/</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap6__chap1_sect3">挂载/proc和/dev文件系统</a></p>
<p>
将<span class="path" dir="ltr">/proc</span>文件系统挂载到<span class="path" dir="ltr">/mnt/gentoo/proc</span>，这样chroot后的环境里安装时也可以获取内核提供的相关信息，然后以bind方式挂载<span class="path" dir="ltr">/dev</span>文件系统。
</p>
<a name="book_part1_chap6__chap1_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.4: 挂载/proc和/dev</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mount -t proc none /mnt/gentoo/proc</span>
# <span class="code-input">mount -o bind /dev /mnt/gentoo/dev</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap6__chap1_sect4">进入新的系统环境</a></p>
<p>
现在所有的分区都已经被初始化，基本环境也已安装完毕，现在是到了该用<span class="emphasis">chroot</span>进入新安装环境的时候了。这意味着我们从当前安装环境（安装光盘或者其他安装介质）切换到你安装的系统里（也就是被初始化的分区）。
</p>
<p>
完成chroot有三步。首先我们用<span class="code" dir="ltr">chroot</span>把根文件系统从<span class="path" dir="ltr">/</span>（安装介质里）切换到<span class="path" dir="ltr">/mnt/gentoo</span>（在你的分区里）。然后我们使用<span class="code" dir="ltr">env-update</span>来建立新的环境，也就是创建新的环境变量。最后我们用<span class="code" dir="ltr">source</span>加载这些变量。
</p>
<a name="book_part1_chap6__chap1_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.5: chroot到新环境里</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">chroot /mnt/gentoo /bin/bash</span>
# <span class="code-input">env-update</span>
&gt;&gt; Regenerating /etc/ld.so.cache...
# <span class="code-input">source /etc/profile</span>
# <span class="code-input">export PS1="(chroot) $PS1"</span>
</pre></td></tr>
</tbody></table>
<p>
祝贺你！你现在已经在你自己的Gentoo Linux环境里了。当然这离安装完成还有段时间，因为我们可以看到安装指南还剩下很多章节呢 :-)
</p>
<p class="chaphead"><a name="book_part1_chap6__chap2"></a><span class="chapnum">6.b. </span>配置Portage</p>
<p class="secthead"><a name="book_part1_chap6__chap2_sect1">更新Portage树</a></p>
<p>
你现在应该更新你的Portage树到最新版本。执行<span class="code" dir="ltr">emerge --sync</span>。
</p>
<a name="book_part1_chap6__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 更新Portage树</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --sync</span>
<span class="code-comment">(如果你在使用一个慢速终端比如一些帧缓冲或者是串口的控制台，你可以添加--quiet选项来加速这个过程:)
</span>
# <span class="code-input">emerge --sync --quiet</span>
</pre></td></tr>
</tbody></table>
<p>
如果你网络前面的防火墙的配置使得rsync请求被阻挡的话，你可以使用<span class="code" dir="ltr">emerge-webrsync</span>下载和安装一个最新的portage快照。
</p>
<p>
如果系统警告你有一个新版本的Portage可用，你可以使用<span class="code" dir="ltr">emerge --oneshot portage</span>来更新它。</p>
<p class="secthead"><a name="book_part1_chap6__chap2_sect2">选择正确的Profile</a></p>
<p>
首先，我们看一下一些小的定义。
</p>
<p>
profile是每个Gentoo系统的构造块。它不仅指定了CHOST、CFLAGS以及其他重要变量的默认值，它还把系统可用的软件版本锁定在某个范围。而这些都是由Gentoo的开发者来维护的。
</p>
<p>
以前，这个profile很少会有用户接触到。然而，有些情况下你可以决定需不需要修改profile。
</p>
<p>
你可以用下面的命令来查看当前使用的profile：
</p>
<a name="book_part1_chap6__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 验证系统profile</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ls -FGg /etc/make.profile</span>
lrwxrwxrwx  1 48 Apr  8 18:51 /etc/make.profile -&gt; ../usr/portage/profiles/default-linux/x86/2008.0
</pre></td></tr>
</tbody></table>
<p>
默认的profile会提供给你一个基于2.6版本内核的Linux系统。这是默认推荐的，但是你也可以选择另外一个profile。
</p>
<p>
系统也为某些架构提供了可用的<span class="code" dir="ltr">desktop</span>和<span class="code" dir="ltr">server</span>的子profile。请查看一下是否可以在<span class="path" dir="ltr">2008.0/</span>profile里面找到这两个子profile。你也许想看一下<span class="code" dir="ltr">desktop</span> profile的<span class="path" dir="ltr">make.defaults</span>是否适合你的需要。
</p>
<p>
看完了<span class="path" dir="ltr">/usr/portage/profiles/</span>里你的体系结构可用的profile之后，如果你愿意，你可以换一个profile。
</p>
<a name="book_part1_chap6__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 切换profile</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ln -snf /usr/portage/profiles/&lt;profile name&gt; /etc/make.profile</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
子profile <span class="code" dir="ltr">developer</span>是专为Gentoo Linux开发任务而准备的，而<span class="emphasis">不是</span>用来帮助构建一般性的开发环境的。
</p></td></tr></tbody></table>
<p class="secthead"><a name="configure_USE"></a><a name="book_part1_chap6__chap2_sect3">配置USE变量</a></p>
<p>
<span class="code" dir="ltr">USE</span>是Gentoo为用户提供的最具威力的变量之一。很多程序通过它可以选
择编译或者不编译某些可选的支持。例如，一些程序可以在编译时加入对gtk或是对qt的支持。其它的程序可以在编译时加入或不加入对于SLL的支持。有些
程序甚至可以在编译时加入对帧缓冲的支持（svgalib）以取代X11（X服务器）。
</p>
<p>
大多数的发行版会使用尽可能多的支持特性编译它们的软件包，这既增加了软件的大小也减慢了启动时间，而这些还没有算上可能会涉及到的大量依赖性问题。Gentoo可以让你自己定义软件编译的选项，而这正是<span class="code" dir="ltr">USE</span>要做的事。
</p>
<p>
在<span class="code" dir="ltr">USE</span>变量里你可以定义关键字，它被用来对应相应的编译选项。比如，<span class="emphasis">ssl</span>会让程序在它编译时加入对它的支持。<span class="emphasis">-X</span>会移除其对于X服务器的支持（注意前面的减号）。<span class="emphasis">gnome gtk -kde -qt3 -qt4</span>将会在你编译软件的时候添加对gnome（和gtk）的支持，并且移除对kde（和qt）的支持，这可以让你的系统尽可能多的为GNOME做优化。
</p>
<p>
默认的<span class="code" dir="ltr">USE</span>设置位于你profile的<span class="path" dir="ltr">make.defaults</span>文件里。你可以在符号连接<span class="path" dir="ltr">/etc/make.profile</span>所指向的目录和它所有的父目录里找到<span class="path" dir="ltr">make.defaults</span>文件。默认的<span class="code" dir="ltr">USE</span>设置是所有<span class="path" dir="ltr">make.defaults</span>文件里<span class="code" dir="ltr">USE</span>的集合。所有你放在<span class="path" dir="ltr">/etc/make.conf</span>里的<span class="code" dir="ltr">USE</span>都会根据默认设置重新计算。如果你添加了一些<span class="code" dir="ltr">USE</span>的设置，它会被增加到默认的列表里。如果你删除了一些<span class="code" dir="ltr">USE</span>设置（通过放一个减号到它前面），它将被从默认的列表里移除（如果它确实在默认列表里的话）。<span class="emphasis">绝对不</span>要改变<span class="path" dir="ltr">/etc/make.profile</span>目录里的任何东西，它会在你更新Portage的时候被覆盖掉！
</p>
<p>
关于<span class="code" dir="ltr">USE</span>的详解你可以在Gentoo手册的第二部分，<a href="#book_part2_chap2">USE标记</a>里找到。对于USE标记的详细介绍可以查看你的系统里<span class="path" dir="ltr">/usr/portage/profiles/use.desc</span>。
</p>
<a name="book_part1_chap6__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 查看可用的USE标记</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">less /usr/portage/profiles/use.desc</span>
<span class="code-comment">（你可用用方向键来滚动，按'q'键退出）</span>
</pre></td></tr>
</tbody></table>
<p>
作为一个例子，我们展示一个基于KDE的系统并带有DVD、ALSA以及光盘刻录支持的<span class="code" dir="ltr">USE</span>设置：
</p>
<a name="book_part1_chap6__chap2_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.5: 打开/etc/make.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/make.conf</span>
</pre></td></tr>
</tbody></table>
<a name="book_part1_chap6__chap2_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.6: USE设置</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>USE="-gtk -gnome qt3 qt4 kde dvd alsa cdr"
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap6__chap2_sect4">可选：glibc Locales</a></p>
<p>
在你的系统里可能只会用到一个或两个locale。你可用<span class="path" dir="ltr">/etc/locale.gen</span>来指定locale。
</p>
<a name="book_part1_chap6__chap2_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.7: 打开/etc/locale.gen</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/locale.gen</span>
</pre></td></tr>
</tbody></table>
<p>
下面这个例子中的locale同时支持英语（美国）和德语（德国）并带有字符集格式（比如UTF-8）的支持。
</p>
<a name="book_part1_chap6__chap2_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.8: 指定你的locale</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>en_US ISO-8859-1
en_US.UTF-8 UTF-8
de_DE ISO-8859-1
de_DE@euro ISO-8859-15
</pre></td></tr>
</tbody></table>
<p>
下一步我们运行<span class="code" dir="ltr">locale-gen</span>。它会产生所有你在<span class="path" dir="ltr">/etc/locale.gen</span>文件里指定的locale。
</p>
<p>
现在我们继续<a href="#book_part1_chap7">配置内核</a>。
</p>
<a name="book_part1_chap7"></a><h3>7. 配置内核</h3>
<p class="chaphead"><a name="book_part1_chap7__chap1"></a><span class="chapnum">7.a. </span>时区</p>
<p>
您首先需要选择您自己的时区，这样可以让系统知道它的位置在哪里。您可以在<span class="path" dir="ltr">/usr/share/zoneinfo</span>中找到您所在的时区，然后把它复制到<span class="path" dir="ltr">/etc/localtime</span>。请不要使用<span class="path" dir="ltr">/usr/share/zoneinfo/Etc/GMT*</span>下的时区，因为它们“名不副实”。例如，<span class="path" dir="ltr">GMT-8</span>事实上是GMT+8区。
</p>
<a name="book_part1_chap7__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 设置时区信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ls /usr/share/zoneinfo</span>
<span class="code-comment">（假设您要用GMT）</span>
# <span class="code-input">cp /usr/share/zoneinfo/GMT /etc/localtime</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part1_chap7__chap2"></a><span class="chapnum">7.b. </span>安装源码</p>
<p class="secthead"><a name="book_part1_chap7__chap2_sect1">选择内核</a></p>
<p>
Linux内核是所有发行版的核心。它位于用户程序和系统硬件之间。Gentoo提供给我们几个可选的内核源码。完整的清单参见<a href="http://www.gentoo.org/doc/en/gentoo-kernel.xml">Gentoo内核指南</a>。
</p>
<p>
对于x86架构的系统来说，我们有<span class="code" dir="ltr">gentoo-sources</span>（包含增加了额外功能的补丁）。
</p>
<p>
选择你的内核源代码并使用<span class="code" dir="ltr">emerge</span>来安装。
</p>
<a name="book_part1_chap7__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装内核源码</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge gentoo-sources</span>
</pre></td></tr>
</tbody></table>
<p>
当您查看<span class="path" dir="ltr">/usr/src</span>时，您将会看到一个叫做<span class="path" dir="ltr">linux</span>的符号链接指向您安装的内核源码。在我们这个例子中，安装的源码指向<span class="code" dir="ltr">gentoo-sources-2.6.24-r5</span>。您的版本可能有所不同，所以请你记住这一点。
</p>
<a name="book_part1_chap7__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 查看内核源码符号链接</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ls -l /usr/src/linux</span>
lrwxrwxrwx    1 root   root    12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.6.24-r5
</pre></td></tr>
</tbody></table>
<p>
现在，我们开始配置和编译您的内核。您可以用<span class="code" dir="ltr">genkernel</span>来做这件事。这将会建立一个和安装光盘所用的内核类似的通用内核。不过我们将首先说明如何手动配置一个内核，因为这是优化您系统环境的最佳方法。
</p>
<p>
如果您希望手动配置您的内核，点击<a href="#manual">默认：手动配置</a>。如果您希望使用<span class="code" dir="ltr">genkernel</span>，您可以阅读<a href="#genkernel">备选：使用genkernel</a>。
</p>
<p class="chaphead"><a name="manual"></a><a name="book_part1_chap7__chap3"></a><span class="chapnum">7.c. </span>默认：手动配置</p>
<p class="secthead"><a name="book_part1_chap7__chap3_sect1">介绍</a></p>
<p>
手动配置内核经常被Linux使用者认为是最困难的步骤。事实并非如此——但是当您手动配置几次内核之后，您就不会再觉得它有多么难了。:)
</p>
<p>
然而，一件事情<span class="emphasis">是</span>真的：在手动配置内核之前，您必须了解您的系统。您可以安装pciutils（<span class="code" dir="ltr">emerge pciutils</span>），用其中的<span class="code" dir="ltr">lspci</span>来了解您需要的大部分信息。您现在可以在chroot的环境中运行<span class="code" dir="ltr">lspci</span>。您可以忽略任何<span class="emphasis">pcilib</span>的警告。（类似于pcilib: cannot open/sys/bus/pci/devices）。此外，您也可以在非chroot的环境执行<span class="code" dir="ltr">lspci</span>。结果相同。您还可以运行<span class="code" dir="ltr">lsmod</span>来查看安装光盘使用了哪些内核模块。（这也是个不错的提示，它可以教你该选择哪些模块）。
</p>
<p>
现在进入到您的内核目录并且执行<span class="code" dir="ltr">make menuconfig</span>。这将会启动一个基于ncureses的配置菜单。
</p>
<a name="book_part1_chap7__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 开始menuconfig</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">cd /usr/src/linux</span>
# <span class="code-input">make menuconfig</span>
</pre></td></tr>
</tbody></table>
<p>
您将会看到一些配置条目。首先我们将会列出一些您必须启用的选项（否则Gentoo将不能正常运行或者根本不能运行）。
</p>
<p class="secthead"><a name="book_part1_chap7__chap3_sect2">必须启用的选项</a></p>
<p>
确保启动您的系统所必需的驱动（比如SCSI控制器……）被编译<span class="emphasis">进</span>内核而不是作为模块加入的。否则您的系统将完全不能启动。
</p>
<p>
现在选择正确的处理器类型：
</p>
<a name="book_part1_chap7__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 选择正确的处理器类别</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Processor type and features ---&gt;
  <span class="code-comment">(Change according to your system)</span>
  (<span class="code-input">Athlon/Duron/K7</span>) Processor family
</pre></td></tr>
</tbody></table>
<p>
现在进入<span class="code" dir="ltr">File Systems</span>并且选择您使用的文件系统。请<span class="emphasis">不要</span>把它们编译成模块，否则您的Gentoo系统将不能挂载您的分区。同时您也要启用<span class="code" dir="ltr">Virtual memory</span>和<span class="code" dir="ltr">/proc file system</span>的支持。
</p>
<a name="book_part1_chap7__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 选择需要的文件系统</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<span class="code-comment">#-#-#-#-#  choice  #-#-#-#-#
（依照你系统的需要启用下面所列出的一个或是多个选项）</span>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support
</pre></td></tr>
</tbody></table>
<p>
如果您在使用PPPoE接入Interne或者您在使用拨号的调制解调器，您需要下面的选项：
</p>
<a name="book_part1_chap7__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 选择PPPoE驱动</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Device Drivers ---&gt;
  Networking Support ---&gt;
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports
</pre></td></tr>
</tbody></table>
<p>
两个压缩选项不会造成什么错误，不过它们不是必需的。<span class="code" dir="ltr">PPP over Ethernet</span>选项也不是必需的，只在使用<span class="code" dir="ltr">ppp</span>并被配置成使用核心PPPoE时才会用到它。
</p>
<p>
如果您需要它，请不要忘记在内核中包含对您的网卡的支持。
</p>
<p>
如果您拥有支持HyperThreading（tm）的Intel CPU，或者您有多个CPU，您需要
激活"Symmetric multi-processing support"：
</p>
<a name="book_part1_chap7__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: 启用SMP支持</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Processor type and features  ---&gt;
  [*] Symmetric multi-processing support
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
在多核心系统中，处理器的数目相当于核心的数目。
</p></td></tr></tbody></table>
<p>
如果你有多于4GB的内存，你需要启用"High Memory Support (64G)"。
</p>
<p>
如果您使用USB输入装置（比如键盘或者鼠标）那么不要忘记支持它们：
</p>
<a name="book_part1_chap7__chap3_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.6: 启用USB接口的输入设备支持</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Device Drivers ---&gt;
  [*] HID Devices---&gt;
    &lt;*&gt;   USB Human Interface Device (full HID) support
</pre></td></tr>
</tbody></table>
<p>
如果你想要对你的笔记本的PCMCIA支持，也不要忘了在系统中允许PCMCIA card bridge。
</p>
<a name="book_part1_chap7__chap3_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.7: 启用PCMCIA支持</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
    &lt;*&gt; PCCard (PCMCIA/CardBus) support
<span class="code-comment">（如果您需要使用老式的PCMCIA卡，选择16位。大多数人需要。）</span>
    &lt;*&gt;   16-bit PCMCIA support
    [*]   32-bit CardBus support
<span class="code-comment">（选择相关的bridges）</span>
    --- PC-card bridges
    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
    &lt;*&gt; i82092 compatible bridge support (NEW)
    &lt;*&gt; i82365 compatible bridge support (NEW)
    &lt;*&gt; Databook TCIC host bridge support (NEW)
</pre></td></tr>
</tbody></table>
<p>
当您完成了内核配置之后，请点击<a href="#compiling">编译与安装</a>.
</p>
<p class="secthead"><a name="compiling"></a><a name="book_part1_chap7__chap3_sect3">编译与安装</a></p>
<p>
既然现在您的内核已经配置成功了，那么就是时候编译并且安装它了。退出配置界面并且开启编译进程：
</p>
<a name="book_part1_chap7__chap3_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.8: 编译内核</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">make &amp;&amp; make modules_install</span>
</pre></td></tr>
</tbody></table>
<p>
当内核编译完成后，复制内核镜像到<span class="path" dir="ltr">/boot</span>。您可以给内核任意命名，然后记住它。因为在您配置您的系统引导程序的时候您需要用到它。记得用您内核的名字和版本来替代<span class="code" dir="ltr">kernel-2.6.24-gentoo-r5</span>。
</p>
<a name="book_part1_chap7__chap3_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.9: 安装内核</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">cp arch/i386/boot/bzImage /boot/kernel-2.6.24-gentoo-r5</span>
</pre></td></tr>
</tbody></table>
<p>
现在请从<a href="#kernel_modules">内核模块</a>一节继续安装。
</p>
<p class="chaphead"><a name="genkernel"></a><a name="book_part1_chap7__chap4"></a><span class="chapnum">7.d. </span>备选：使用genkernel</p>
<p>
如果您在阅读这部分，那么您选择了使用<span class="code" dir="ltr">genkernel</span>脚本来配置您自己的内核。
</p>
<p>
现在您的内核源码树已经安装了，是时候用<span class="code" dir="ltr">genkernel</span>脚本自动编译您的内核了。<span class="code" dir="ltr">genkernel</span>是使用类似安装光盘中的内核配置来配置内核的。这表明当您用<span class="code" dir="ltr">genkernel</span>建立内核时，您的系统在启动时候将会如同安装光盘那样识别您所有的硬件。因为genkernel不需要手动配置内核，所以它对于那些不想自己编译特定内核的用户来说是一个理想的解决方案。
</p>
<p>
现在让我们来看看如何使用genkernel吧。首先，安装genkernel：
</p>
<a name="book_part1_chap7__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 安装genkernel</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge genkernel</span>
</pre></td></tr>
</tbody></table>
<p>
然后，复制安装光盘上的内核配置文件到genkernel搜索配置文件的默认位置：
</p>
<a name="book_part1_chap7__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: 复制安装光盘的配置文件</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</span>
</pre></td></tr>
</tbody></table>
<p>
现在执行<span class="code" dir="ltr">genkernel all</span>编译您的内核源码。请注意，<span class="code" dir="ltr">genkernel</span>编译出的内核支持几乎所有硬件，编译需要一段很长的时间。
</p>
<p>
另外需要注意的是，如果您的启动分区没有使用ext2或者ext3文件系统，您必须使用<span class="code" dir="ltr">genkernel --menuconfig all</span>来手动配置您的内核，把您所使用的文件系统编译进内核。（<span class="emphasis">不能</span>编译为模块！）。EVMS2和LVM2的用户很可能也需要加上<span class="code" dir="ltr">--evms2</span>和<span class="code" dir="ltr">--lvm2</span>参数。
</p>
<a name="book_part1_chap7__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: 运行genkernel</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">genkernel all</span>
</pre></td></tr>
</tbody></table>
<p>
一旦<span class="code" dir="ltr">genkernel</span>运行完成，一个包括全部模块和initrd的内核将被建立。在后面配置引导程序时我们将会用到这个内核和initrd。请记下内核和initrd的名字，因为您将在配置引导程序的时候用到他们。initrd将会在启动真正的系统前自动识别硬件（如同安装光盘一样）。
</p>
<a name="book_part1_chap7__chap4_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.4: 查看内核和initrd的名字</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ls /boot/kernel* /boot/initramfs*</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="kernel_modules"></a><a name="book_part1_chap7__chap5"></a><span class="chapnum">7.e. </span>内核模块</p>
<p class="secthead"><a name="kernelmodules"></a><a name="book_part1_chap7__chap5_sect1">配置模块</a></p>
<p>
您应该在<span class="path" dir="ltr">/etc/modules.autoload.d/kernel-2.6</span>中列出您需要自动加载的模块。如果您愿意，您也可以加上模块的选项。
</p>
<p>
要查看所有可用的模块，运行如下的<span class="code" dir="ltr">find</span>命令。不要忘记把“&lt;kernel version&gt;”替换成你刚编译好的内核版本：
</p>
<a name="book_part1_chap7__chap5_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.1: 查看所有可用的模块</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</span>
</pre></td></tr>
</tbody></table>
<p>
例如，要自动加载<span class="code" dir="ltr">3c59x.ko</span>模块，编辑<span class="path" dir="ltr">kernel-2.6</span>文件然后写入模块的名字。
</p>
<a name="book_part1_chap7__chap5_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.2: 编辑/etc/modules.autoload.d/kernel-2.6</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/modules.autoload.d/kernel-2.6</span>
</pre></td></tr>
</tbody></table>
<a name="book_part1_chap7__chap5_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.3: /etc/modules.autoload.d/kernel-2.6</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>3c59x
</pre></td></tr>
</tbody></table>
<p>
现在请从<a href="#book_part1_chap8">配置您的系统</a>一章来继续您的安装。
</p>
<a name="book_part1_chap8"></a><h3>8. 配置系统</h3>
<p class="chaphead"><a name="book_part1_chap8__chap1"></a><span class="chapnum">8.a. </span>文件系统信息</p>
<p class="secthead"><a name="book_part1_chap8__chap1_sect1">fstab是什么？</a></p>
<p>
在Linux系统下，系统所用到的所有分区都必须在<span class="path" dir="ltr">/etc/fstab</span>文件中指明。这个文件包含了这些分区的挂载点（在系统目录树中的位置）、挂载方法和特殊挂载选项（是否自动挂载，是否可以用户挂载等）。
</p>
<p class="secthead"><a name="book_part1_chap8__chap1_sect2">创建/etc/fstab</a></p>
<p>
<span class="path" dir="ltr">/etc/fstab</span>使用一种特殊语法格式。每行都包含六个字段。这些字段之间由空白键（空格键，tab键，或者两者混合使用）分隔。每个字段都有自己的含意：
</p>
<ul>
<li>
  第一个字段是对<b>分区</b>的描述，也就是设备文件的路径
</li>
<li>
  第二个字段是分区<b>挂载点</b>，也就是分区应该挂载到的地方
</li>
<li>
  第三个字段给出分区所用的<b>文件系统</b>
</li>
<li>
  第四个字段给出的是挂载分区时<span class="code" dir="ltr">mount</span>命令所用的<b>挂载选项</b>。由于每个文件系统都有自己的挂载选项，我们建议你阅读mount手册（<span class="code" dir="ltr">man mount</span>）以获得所有挂载选项的列表。多个挂载选项之间是用逗号分隔的。
</li>
<li>
  第五个字段是给<span class="code" dir="ltr">dump</span>使用的，用以决定这个分区是否需要<b>dump</b>。一般情况下，你可以把该字段设为<span class="code" dir="ltr">0</span>（零）。
</li>
<li>
  第六个字段是给<span class="code" dir="ltr">fsck</span>使用的，用以决定系统非正常关机之后文件系统的检查顺序。根文件系统应该为<span class="code" dir="ltr">1</span>，而其它的应该为<span class="code" dir="ltr">2</span>（如果不需要文件系统自检的话可以设为<span class="code" dir="ltr">0</span>）。
</li>
</ul>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
Gentoo系统默认的<span class="path" dir="ltr">/etc/fstab</span>文件<span class="emphasis">不是有效的fstab文件</span>。你必须创建自己的<span class="path" dir="ltr">/etc/fstab</span>。
</p></td></tr></tbody></table>
<a name="book_part1_chap8__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 打开/etc/fstab</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/fstab</span>
</pre></td></tr>
</tbody></table>
<p>
让我们看看<span class="path" dir="ltr">/boot</span>分区的挂载选项是怎么写的。这仅仅是个例子，如果你没有或者不能创建<span class="path" dir="ltr">/boot</span>，请不要复制它。
</p>
<p>
在我们默认的x86分区例子中，<span class="path" dir="ltr">/boot</span>一般
为<span class="path" dir="ltr">/dev/sda1</span>分区，且采用<span class="emphasis">ext2</span>文件系统。
这个分区在引导过程中需要自检，因此我们这样写：
</p>
<a name="book_part1_chap8__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: /etc/fstab中/boot行的一个例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>/dev/sda1   /boot     ext2    defaults        1 2
</pre></td></tr>
</tbody></table>
<p>
为了提高系统的安全性，一部分用户不希望<span class="path" dir="ltr">/boot</span>分区自动挂载。这些用户应该用<span class="code" dir="ltr">noauto</span>替换<span class="code" dir="ltr">defaults</span>。这就表示用户每次使用该分区时，需要手动挂载。
</p>
<p>
增加符合你分区方案的规则，为你的光驱（当然，如果你有其他分区或者驱动器，也为它们加上）添加挂载规则。
</p>
<p>
现在就参考以下<span class="emphasis">例子</span>创建你的<span class="path" dir="ltr">/etc/fstab</span>：
</p>
<a name="book_part1_chap8__chap1_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.3: /etc/fstab的一个完整例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>/dev/sda1   /boot        ext2    defaults,noatime     1 2
/dev/sda2   none         swap    sw                   0 0
/dev/sda3   /            ext3    noatime              0 1

/dev/cdrom  /mnt/cdrom   auto    noauto,user          0 0
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">auto</span>选项可以使<span class="code" dir="ltr">mount</span>猜测文件系统（推荐对于可移动设备采用这个选项，因为它们可能采用很多不同的文件系统），而<span class="code" dir="ltr">user</span>选项使得非root用户可以挂载光驱。
</p>
<p>
为了提高性能，大部分用户会添加<span class="code" dir="ltr">noatime</span>挂载选项。由于不记录该分区中文件的访问时间（一般来说你并不需要知道它），这个选项能够提高系统速度。
</p>
<p>
请再次确认你的<span class="path" dir="ltr">/etc/fstab</span>文件是正确的，保存并退出，继续下面的内容。
</p>
<p class="chaphead"><a name="book_part1_chap8__chap2"></a><span class="chapnum">8.b. </span>网络信息</p>
<p class="secthead"><a name="book_part1_chap8__chap2_sect1">主机名、域名等</a></p>
<p>
用户必须要做的事情之一就是命名自己的机器。尽管这看上去很容易，但是<span class="emphasis">很多</span>用户觉得为他们的Linux机器起一个合适的名字是很难的。为了加快事情的进度，你应该知道你所命名的所有名字都是可以在今后重新修改的。因此，你可以简单命名你的系统为<span class="code" dir="ltr">tux</span>，域名为<span class="code" dir="ltr">homenetwork</span>。
</p>
<a name="book_part1_chap8__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 设定主机名</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/conf.d/hostname</span>

<span class="code-comment">（将HOSTNAME的变量值设定为主机名）</span>
HOSTNAME="<span class="code-input">tux</span>"
</pre></td></tr>
</tbody></table>
<p>
第二，<span class="emphasis">如果</span>你需要一个域名，在<span class="path" dir="ltr">/etc/conf.d/net</span>中设定。只有你的ISP或者网络管理员说你需要一个域名，或者你有一个DNS服务器但是没有DHCP服务器的时候，你才需要域名。如果你的网络是DHCP分配IP，那么你不需要理会DNS和域名的问题。
</p>
<a name="book_part1_chap8__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 设定域名</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/conf.d/net</span>

<span class="code-comment">（设定dns_domain的变量值为你的域名）</span>
dns_domain_lo="<span class="code-input">homenetwork</span>"
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果你选择不设定域名，你可以去掉登录界面上的这条信息“This is hostname.(none)”。你只需要修改<span class="path" dir="ltr">/etc/issue</span>，把字符串<span class="code" dir="ltr">.\O</span>从该文件里删掉即可。
</p></td></tr></tbody></table>
<p>
如果你有一个NIS域（如果你不知道这是什么，就说明你没有），你也需要定义一个：
</p>
<a name="book_part1_chap8__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 设定NIS域名</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/conf.d/net</span>

<span class="code-comment">（设定nis_domain的变量值为你的NIS域名）</span>
nis_domain_lo="<span class="code-input">my-nisdomain</span>"
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果想知道更多关于DNS和NIS配置的信息，可以看<span class="path" dir="ltr">/etc/conf.d/net.example</span>当中的例子。当然，你也可以安装<span class="code" dir="ltr">openresolv</span>来帮助设置DNS、NIS。
</p></td></tr></tbody></table>
<p class="secthead"><a name="book_part1_chap8__chap2_sect2">配置你的网络</a></p>
<p>
在准备说“嘿，我们已经配置过网络”之前，你应该记得在开始安装Gentoo之初所设置的网络配置是仅仅为了安装而设置的。现在你所要设置的是Gentoo系统的永久网络配置。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
更多关于网络配置的详细信息，包括网卡绑定、网桥、802.1Q VLANs和无线网络在内的高级配置会在<a href="#book_part4">Gentoo网络配置</a>这一部分介绍.
</p></td></tr></tbody></table>
<p>
<span class="path" dir="ltr">/etc/conf.d/net</span>当中收集了所有的网络信息。尽管这个文件采用直接易懂的语法，如果你还是因为觉得不够直观而完全不知道如何手动进行网络配置的话，请不用担心，我们将一一解释。在<span class="path" dir="ltr">/etc/conf.d/net.example</span>中有一个详细注释过的例子，它涵盖了许多种类不同的配置。
</p>
<p>
系统默认使用DHCP。如果使用DHCP的话，你需要安装一个DHCP客户端。这个将在稍后的<a href="#networking-tools">安装必要的系统工具</a>部分介绍。但是不要忘记安装一个DHCP客户端。
</p>
<p>
如果你需要配置你的网络连接，不管是因为你是需要指定DHCP选项还是你根本不想采用DHCP，请使用你喜欢的编辑器（在这个例子中用的是<span class="code" dir="ltr">nano</span>）打开<span class="path" dir="ltr">/etc/conf.d/net</span>：
</p>
<a name="book_part1_chap8__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 打开/etc/conf.d/net准备编辑</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/conf.d/net</span>
</pre></td></tr>
</tbody></table>
<p>
你会看到以下的文件:
</p>
<a name="book_part1_chap8__chap2_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.5: 默认的/etc/conf.d/net</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># This blank configuration will automatically use DHCP for any net.*
# scripts in /etc/init.d.  To create a more complete configuration,
# please review /etc/conf.d/net.example and save your configuration
# in /etc/conf.d/net (this file :]!).
</pre></td></tr>
</tbody></table>
<p>
为了输入你自己的IP地址，子网掩码和网关，你需要设置<span class="code" dir="ltr">config_eth0</span>和<span class="code" dir="ltr">routes_eth0</span>：
</p>
<a name="book_part1_chap8__chap2_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.6: 手动为eth0设置IP信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>config_eth0=( "192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255" )
routes_eth0=( "default via 192.168.0.1" )
</pre></td></tr>
</tbody></table>
<p>
如果你使用DHCP并且想设定DHCP选项，请定义一下<span class="code" dir="ltr">config_eth0</span>和<span class="code" dir="ltr">dhcp_eth0</span>:
</p>
<a name="book_part1_chap8__chap2_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.7: 让eth0自动获得IP地址</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>config_eth0=( "dhcp" )
dhcp_eth0="nodns nontp nonis"
</pre></td></tr>
</tbody></table>
<p>
请阅读<span class="path" dir="ltr">/etc/conf.d/net.example</span>以得到所有选项的列表。
</p>
<p>
如果你有多个网络接口，那么重复之前对于<span class="code" dir="ltr">config_eth1</span>、<span class="code" dir="ltr">config_eth2</span>等的操作步骤。
</p>
<p>
现在可以保存配置并且退出，继续下面的安装和配置。
</p>
<p class="secthead"><a name="book_part1_chap8__chap2_sect3">在启动时自动启用网络</a></p>
<p>
为了在启动时自动激活网络接口，你必须添加这些到default运行级别。
</p>
<a name="book_part1_chap8__chap2_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.8: 添加net.eth0到默认的运行级别</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rc-update add net.eth0 default</span>
</pre></td></tr>
</tbody></table>
<p>
如果你有多个网络接口，你需要为他们创建合适的<span class="path" dir="ltr">net.eth1</span>、<span class="path" dir="ltr">net.eth2</span>等启动脚本。你可以用<span class="code" dir="ltr">ln</span>来做这个。
</p>
<a name="book_part1_chap8__chap2_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.9: 创建额外的启动脚本</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">cd /etc/init.d</span>
# <span class="code-input">ln -s net.lo net.eth1</span>
# <span class="code-input">rc-update add net.eth1 default</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap8__chap2_sect4">记下网络信息</a></p>
<p>
现在你需要告诉Linux有关你的网络的信息。这需要在<span class="path" dir="ltr">/etc/hosts</span>文件中定义，它将帮助你将那些无法被域名解析器解析的主机名解析成IP地址。你需要定义你自己的系统。如果你不想启用内部DNS系统的话，你也需要定义内部网络上的其它系统。
</p>
<a name="book_part1_chap8__chap2_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.10: 打开/etc/hosts</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/hosts</span>
</pre></td></tr>
</tbody></table>
<a name="book_part1_chap8__chap2_pre11"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.11: 填入网络信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（这里定义的是现在的系统）</span>
127.0.0.1     tux.homenetwork tux localhost

<span class="code-comment">（定义你网络上的其它系统。如果你要用这种方式进行定义的话,它们必须有静
态IP。）</span>
192.168.0.5   jenny.homenetwork jenny
192.168.0.6   benny.homenetwork benny
</pre></td></tr>
</tbody></table>
<p>
保存并且退出编辑器，继续下面的过程。
</p>
<p>
如果你没有PCMCIA，你可以跳过以下内容进入<a href="#sysinfo">系统信息</a>了。
PCMCIA用户应该读一下以下关于PCMCIA的内容。
</p>
<p class="secthead"><a name="book_part1_chap8__chap2_sect5">可选：启用PCMCIA</a></p>
<p>
PCMCIA用户首先应该安装<span class="code" dir="ltr">pcmciautils</span>软件包。
</p>
<a name="book_part1_chap8__chap2_pre12"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.12: 安装pcmciautils</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge pcmciautils</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="sysinfo"></a><a name="book_part1_chap8__chap3"></a><span class="chapnum">8.c. </span>系统信息</p>
<p class="secthead"><a name="book_part1_chap8__chap3_sect1">Root密码</a></p>
<p>
首先我们键入以设置root密码：
</p>
<a name="book_part1_chap8__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 设置root密码</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">passwd</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap8__chap3_sect2">系统信息</a></p>
<p>
Gentoo使用<span class="path" dir="ltr">/etc/rc.conf</span>来做通用的、系统级的配置。打开<span class="path" dir="ltr">/etc/rc.conf</span>并好好读读这个文件中的注解：）
</p>
<a name="book_part1_chap8__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 打开/etc/rc.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/rc.conf</span>
</pre></td></tr>
</tbody></table>
<p>
当你完成对<span class="path" dir="ltr">/etc/rc.conf</span>的配置后，保存并退出。
</p>
<p>
正如你所看到的，为了帮助你完成必要变量的配置，这个文件有丰富的注释信息。你可以让你的系统使用unicode并定义你的默认编辑器和你的显示管理器（比如gdm或者kdm）。
</p>
<p>
Gentoo用<span class="path" dir="ltr">/etc/conf.d/keymaps</span>来处理键盘设置。编辑它就可以设置你的键盘。
</p>
<a name="book_part1_chap8__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 打开/etc/conf.d/keymaps</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/conf.d/keymaps</span>
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">KEYMAP</span>这个变量要特别注意。如果你选择了错误的<span class="code" dir="ltr">KEYMAP</span>，在你敲击键盘的时候会有奇怪的结果。
</p>
<p>
完成<span class="path" dir="ltr">/etc/conf.d/keymaps</span>的配置之后，保存并退出。
</p>
<p>
Gentoo使用<span class="path" dir="ltr">/etc/conf.d/clock</span>来设置时钟选项。根据你的需要来编辑它。
</p>
<a name="book_part1_chap8__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 打开/etc/conf.d/clock</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/conf.d/clock</span>
</pre></td></tr>
</tbody></table>
<p>
如果你机器上的钟不用UTC，你需要在文件钟加上<span class="code" dir="ltr">CLOCK="local"</span>。否则，你的时钟就有可能出现偏差。
</p>
<p>
完成对<span class="path" dir="ltr">/etc/conf.d/clock</span>的配置后，保存并且退出。
</p>
<p>
请继续阅读<a href="#book_part1_chap9">安装必要的系统工具</a>。
</p>
<a name="book_part1_chap9"></a><h3>9. 安装必要的系统工具
</h3>
<p class="chaphead"><a name="book_part1_chap9__chap1"></a><span class="chapnum">9.a. </span>系统日志工具</p>
<p>
因为有一些工具提供给用户的功能比较类似，它们就没有包含在<span class="emphasis">stage3</span>当中。现在就是你选择安装哪一个的时候了。
</p>
<p>
你首先需要决定的就是系统日志工具。Unix和Linux在日志记录功能方面有良好的传统——如果你愿意的话你可以把系统发生的所有事件都记录到日志文件中。这些功能就是通过<span class="emphasis">系统日志工具</span>来完成的。
</p>
<p>
Gentoo提供了多种系统日志工具可供选择。这当中有<span class="code" dir="ltr">sysklogd</span>（传统的系统日志守护进程），<span class="code" dir="ltr">syslog-ng</span>（一个高级系统日志工具），<span class="code" dir="ltr">metalog</span>（一个可以灵活配置的系统日志工具）。Portage内或许还有其他的系统日志工具——我们的可用软件包数量是以天为单位在增加的。
</p>
<p>
如果你打算使用<span class="code" dir="ltr">sysklogd</span>或者<span class="code" dir="ltr">syslog-ng</span>你很可能会随后希望安装<span class="code" dir="ltr">logrotate</span>，因为这些系统日志工具并没有提供系统日志文件的滚动功能。
</p>
<p>
要安装你所选择的系统日志工具，你可以用<span class="code" dir="ltr">emerge</span>命令安装它，并使用<span class="code" dir="ltr">rc-update</span>将它加入default运行级别。以下就是一个安装<span class="code" dir="ltr">syslog-ng</span>的例子。当然你要把它换成你的系统日志工具：
</p>
<a name="book_part1_chap9__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 安装一个系统日志工具</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge syslog-ng</span>
# <span class="code-input">rc-update add syslog-ng default</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part1_chap9__chap2"></a><span class="chapnum">9.b. </span>可选：Cron守护进程</p>
<p>
接下来你可以选择cron守护进程。尽管这是可选的并且不是系统所必须的，但是最好能够安装一个。那么，什么是cron守护进程呢？cron守护进程执行预定的命令。如果你需要执行一些有规律（例如每天、每周或者每月）的命令，这就会非常有用。
</p>
<p>
Gentoo提供了三个可选的cron守护进程：<span class="code" dir="ltr">dcron</span>、<span class="code" dir="ltr">fcron</span>和<span class="code" dir="ltr">vixie-cron</span>。安装这其中一个的方法和安装一个系统日志工具的方法类似。但是，<span class="code" dir="ltr">dcron</span>和<span class="code" dir="ltr">fcron</span>需要额外的配置命令，即<span class="code" dir="ltr">crontab /etc/crontab</span>。如果你不知道应该选择哪个，那么就用<span class="code" dir="ltr">vixie-cron</span>好了。
</p>
<p>
我们对无网络安装只提供了<span class="code" dir="ltr">vixie-cron</span>。如果你希望安装其它的cron守护进程，那你只能等待稍后安装了。
</p>
<a name="book_part1_chap9__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装一个cron守护进程</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge vixie-cron</span>
# <span class="code-input">rc-update add vixie-cron default</span>
<span class="code-comment">（只有在使用dcron或fcron时需要）</span> # <span class="code-input">crontab /etc/crontab</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part1_chap9__chap3"></a><span class="chapnum">9.c. </span>可选：文件索引</p>
<p>
如果你想索引你的系统文件使得你能够使用<span class="code" dir="ltr">locate</span>工具很快定位它们，你需要安装<span class="code" dir="ltr">sys-apps/slocate</span>。
</p>
<a name="book_part1_chap9__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 安装slocate</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge slocate</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part1_chap9__chap4"></a><span class="chapnum">9.d. </span>文件系统工具</p>
<p>
根据你所使用的文件系统的不同，你需要安装必须的文件系统工具（用于检查文件系统完整性、创建额外的文件系统等）。请注意管理ext2/ext3文件系统的工具（<span class="code" dir="ltr">e2fsprogs</span>）已经做为系统的一部分被安装了。
</p>
<p>
以下的表格列出了特定文件系统所需要安装的工具。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>文件系统</b></th>
  <th class="infohead" style="text-align: left;"><b>工具</b></th>
  <th class="infohead" style="text-align: left;"><b>安装命令</b></th>
</tr>
<tr>
  <td class="tableinfo">XFS</td>
  <td class="tableinfo">xfsprogs</td>
  <td class="tableinfo"><span class="code" dir="ltr">emerge xfsprogs</span></td>
</tr>
<tr>
  <td class="tableinfo">ReiserFS</td>
  <td class="tableinfo">reiserfsprogs</td>
  <td class="tableinfo"><span class="code" dir="ltr">emerge reiserfsprogs</span></td>
</tr>
<tr>
  <td class="tableinfo">JFS</td>
  <td class="tableinfo">jfsutils</td>
  <td class="tableinfo"><span class="code" dir="ltr">emerge jfsutils</span></td>
</tr>
</tbody></table>
<p>
如果你是EVMS用户，你还需要安装<span class="code" dir="ltr">evms</span>：
</p>
<a name="book_part1_chap9__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 安装EVMS工具</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">USE="-gtk" emerge evms</span>
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">USE="-gtk"</span>参数会避免安装一些相关依赖的基于GTK的程序。如果你希望使用<span class="code" dir="ltr">evms</span>的图形工具，你可以重新编译<span class="code" dir="ltr">evms</span>。
</p>
<p class="chaphead"><a name="网络工具"></a><a name="book_part1_chap9__chap5"></a><span class="chapnum">9.e. </span>网络工具</p>
<p>
如果你不需要任何其它网络相关的工具（例如ppp或dhcp客户端）可以跳过这部分内容继续进入<a href="#book_part1_chap10">配置引导程序</a>
</p>
<p class="secthead"><a name="book_part1_chap9__chap5_sect2">可选：安装一个DHCP客户端</a></p>
<p>
如果你需要Gentoo为你的网卡自动获得IP地址，你需要安装<span class="code" dir="ltr">dhcpcd</span>（或者任何其它的DHCP客户端——参见<a href="#book_part4_chap3">网络模块</a>当中的DHCP客户端列表）。如果你不安装的话，你安装完Gentoo系统后可能会无法连接网络。
</p>
<a name="book_part1_chap9__chap5_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.1: 安装dhcpcd</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge dhcpcd</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap9__chap5_sect3">可选：安装PPPoE客户端</a></p>
<p>
如果你需要<span class="code" dir="ltr">ppp</span>来连接网络，你需要安装它。
</p>
<a name="book_part1_chap9__chap5_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.2: 安装ppp</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge ppp</span>
</pre></td></tr>
</tbody></table>
<p>
现在进入<a href="#book_part1_chap10">配置引导程序</a>部分。
</p>
<a name="book_part1_chap10"></a><h3>10. 配置引导程序</h3>
<p class="chaphead"><a name="book_part1_chap10__chap1"></a><span class="chapnum">10.a. </span>做出您的选择</p>
<p class="secthead"><a name="book_part1_chap10__chap1_sect1">介绍</a></p>
<p>
现在，您已经配置并编译好了内核，必需的一些系统配置文件也已经就位，是时候安装一个叫做<span class="emphasis">引导程序</span>的程序来“引燃”您的内核并启动系统了。
</p>
<p>
对于x86，Gentoo Linux提供了<a href="#grub">GRUB</a>和<a href="#lilo">LILO</a>。
</p>
<p>
但在安装bootloader之前，我们要告诉您如何配置framebuffer（前提当然是您想使用它）。在framebuffer的帮助下，您系统的Linux命令行将拥有（有限的）图形特性（例如使用Gentoo提供的漂亮的bootsplash图片）。
</p>
<p class="secthead"><a name="book_part1_chap10__chap1_sect2">可选：Framebuffer</a></p>
<p>
<span class="emphasis">如果</span>您已经为您的内核加上了framebuffer支持（或者您使用<span class="code" dir="ltr">genkernel</span>的默认内核配置），您就可以在bootloader配置文件中加入一个<span class="code" dir="ltr">vga</span>和／或一个<span class="code" dir="ltr">video</span>内核参数来启用它。
</p>
<p>
首先，您需要知道您使用的是什么类型的framebuffer设备。如果您用的是加过Gentoo补丁的内核源代码（例如<span class="code" dir="ltr">gentoo-sources</span>），您将可以选择<span class="code" dir="ltr">uvesafb</span>作为<span class="emphasis">VESA驱动</span>。这样的话，您使用的就是<span class="code" dir="ltr">uvesafb</span>驱动，您将<span class="emphasis">不需要</span>设置<span class="code" dir="ltr">vga</span>参数。否则您使用的就是<span class="code" dir="ltr">vesafb</span>驱动，您将<span class="emphasis">需要</span>设置<span class="code" dir="ltr">vga</span>参数。
</p>
<p>
<span class="code" dir="ltr">vga</span>参数用来控制您的<span class="code" dir="ltr">vesafb</span> framebuffer屏幕的分辨率和颜色深度。正如<span class="path" dir="ltr">/usr/src/linux/Documentation/fb/vesafb.txt</span>（您安装内核源码包的同时就会安装这一文件）里说明的那样，您需要将与您想使用的分辨率和色深相对应的VESA数值传递给此参数。
</p>
<p>
下表列出了可用的分辨率和对应的颜色深度，您在里面可以找到需要传递给<span class="code" dir="ltr">vga</span>参数的值。
</p>
<table class="ntable">
<tbody><tr>
  <td class="tableinfo"></td>
  <th class="infohead" style="text-align: left;"><b>640x480</b></th>
  <th class="infohead" style="text-align: left;"><b>800x600</b></th>
  <th class="infohead" style="text-align: left;"><b>1024x768</b></th>
  <th class="infohead" style="text-align: left;"><b>1280x1024</b></th>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>256</b></th>
  <td class="tableinfo">0x301</td>
  <td class="tableinfo">0x303</td>
  <td class="tableinfo">0x305</td>
  <td class="tableinfo">0x307</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>32k</b></th>
  <td class="tableinfo">0x310</td>
  <td class="tableinfo">0x313</td>
  <td class="tableinfo">0x316</td>
  <td class="tableinfo">0x319</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>64k</b></th>
  <td class="tableinfo">0x311</td>
  <td class="tableinfo">0x314</td>
  <td class="tableinfo">0x317</td>
  <td class="tableinfo">0x31A</td>
</tr>
<tr>
  <th class="infohead" style="text-align: left;"><b>16M</b></th>
  <td class="tableinfo">0x312</td>
  <td class="tableinfo">0x315</td>
  <td class="tableinfo">0x318</td>
  <td class="tableinfo">0x31B</td>
</tr>
</tbody></table>
<p>
<span class="code" dir="ltr">video</span>语句用来控制framebuffer的显示参数。此语句中需指定欲使用的framebuffer驱动以及你想启用的控制语句。<span class="path" dir="ltr">/usr/src/linux/Documentation/fb/vesafb.txt</span>文件里列出了所有变量。最常用的选项是：
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>控制选项</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo">ywrap</td>
  <td class="tableinfo">
    假设显卡支持显存回卷操作（也就是说显存里的数据填充到尽头的时候会接着从起始处继续）
  </td>
</tr>
<tr>
  <td class="tableinfo">mtrr:<span class="code" dir="ltr">n</span>
</td>
  <td class="tableinfo">
    设置MTRR寄存器. <span class="code" dir="ltr">n</span> 可以是：<br>
    0 - 禁用<br>
    1 - 不使用cache<br>
    2 - write-back<br>
    3 - write-combining<br>
    4 - write-through 
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">模式</span></td>
  <td class="tableinfo">
    (只针对<span class="code" dir="ltr">uvesafb</span>)<br>
    设定分辨率，颜色深度和刷新率。
    例如，<span class="code" dir="ltr">1024x768-32@85</span>对应的分辨率是1024x768，32位色深和85Hz的刷新率。
  </td>
</tr>
</tbody></table>
<p>
最后这两个参数的内容可能类似这样<span class="code" dir="ltr">vga=0x318 video=vesafb:mtrr:3,ywrap</span>或者<span class="code" dir="ltr">video=uvesafb:mtrr:3,ywrap,1024x768-32@85</span>。将它们记下来；很快您将用到它们。
</p>
<p>
接下来要继续安装<a href="#grub">GRUB</a><span class="emphasis">或</span><a href="#lilo">LILO</a>。
</p>
<p class="chaphead"><a name="grub"></a><a name="book_part1_chap10__chap2"></a><span class="chapnum">10.b. </span>默认：使用GRUB</p>
<p class="secthead"><a name="book_part1_chap10__chap2_sect1">了解GRUB的术语</a></p>
<p>
理解GRUB最重要的在于熟悉它如何表述硬盘驱动器和分区。在GRUB中，您的Linux分区<span class="path" dir="ltr">/dev/sda1</span>将很可能都被称为<span class="path" dir="ltr">(hd0,0)</span>。请注意<span class="path" dir="ltr">hd0,0</span>两边的括号——它们是必须加上的。
</p>
<p>硬盘是从0而不是从“a”开始，分区从0而不是1开始。要明确的是，hd设备只指硬盘，而不包括atapi-ide设备，例如cdrom播放器和刻
录机。同样的标识构造方式也适用于SCSI驱动器。（正常情况下，除非BIOS被配置为从SCSI驱动器引导，否则SCSI硬盘的标识数字会比IDE的
高。）当您要求BIOS从一个不同的硬盘引导时（例如您的主IDE接口上的从盘），<span class="emphasis">那个</span>硬盘就会被视为<span class="path" dir="ltr">hd0</span>。
</p>
<p>
假设您有一个硬盘是<span class="path" dir="ltr">/dev/sda</span>，还有两个分别是<span class="path" dir="ltr">/dev/sdb</span>和<span class="path" dir="ltr">/dev/sdc</span>，那么<span class="path" dir="ltr">/dev/hdd7</span>将会被GRUB标识为<span class="path" dir="ltr">(hd1,6)</span>。听起来这有些不合常理，确实如此。但正如我们即将见到的，GRUB为您提供了一个tab补全机制，这将大大方便您的操作。即使您拥有许多的硬盘和分区，而且对GRUB的数字标识方案不甚了解，也不用怕。
</p>
<p>
我们已经有了一些感觉了，是时候安装GRUB了。
</p>
<p class="secthead"><a name="book_part1_chap10__chap2_sect2">安装GRUB</a></p>
<p>
要安装GRUB，首先让我们emerge它：
</p>
<a name="book_part1_chap10__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装GRUB</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge grub</span>
</pre></td></tr>
</tbody></table>
<p>
尽管现在已经安装完GRUB，我们仍需要为其写一个配置文件，并将其安置到硬盘的主引导记录中，使它能自动引导您新创建的内核。您可以使用<span class="code" dir="ltr">nano</span>（或其他可用的编辑器）来创建配置文件<span class="path" dir="ltr">/boot/grub/grub.conf</span>：
</p>
<a name="book_part1_chap10__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 创建/boot/grub/grub.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /boot/grub/grub.conf</span>
</pre></td></tr>
</tbody></table>
<p>
现在我们将详细地写一个<span class="path" dir="ltr">grub.conf</span>。您在下面的内容中可以找到两个可能的针对本指南中前面章节给出的分区方式例子的<span class="path" dir="ltr">grub.conf</span>。我们只详细地评述第一个<span class="path" dir="ltr">grub.conf</span>。确保您使用<span class="emphasis">您自己的</span>内核镜像文件名，以及如果有的话，<span class="emphasis">您自己的</span>的initrd镜像文件名。
</p>
<ul>
  <li>
    第一个<span class="path" dir="ltr">grub.conf</span>是为未使用<span class="code" dir="ltr">genkernel</span>来构建内核的用户准备的
  </li>
  <li>
    第二个<span class="path" dir="ltr">grub.conf</span>则是为使用<span class="code" dir="ltr">genkernel</span>来构建内核的用户准备的
  </li>
</ul>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
Grub根据BIOS来决定设备名。如果你改变了你的BIOS设定，你的设备字母和序号也会改变。比如如果你改变了你的设备的启动顺序，你就需要改变你的grub配置。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果您使用JFS来作为root文件系统，您就<span class="emphasis">必须</span>在<span class="code" dir="ltr">kernel</span>那行添加上“ro”参数，因为JFS文件系统在其允许被加载为可读写状态前需要使用这个参数来重放它的日志。
</p></td></tr></tbody></table>
<a name="book_part1_chap10__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 不使用genkernel的用户的grub.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 默认选择哪个列表来引导。0表示第一个， 1表示第二个，以此类推。</span>
default 0
<span class="code-comment"># 引导默认列表前等待多少秒</span>
timeout 30
<span class="code-comment"># 使用漂亮、“臃肿”的spalsh图像来增加一点趣味:)
# 如果您没有安装显卡，请将这行注释掉</span>
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title Gentoo Linux 2.6.24-r5
<span class="code-comment"># 内核镜像（或者操作系统）所在分区</span>
root (hd0,0)
kernel /boot/kernel-2.6.24-gentoo-r5 root=/dev/sda3

title Gentoo Linux 2.6.24-r5 (rescue)
<span class="code-comment"># 内核镜像（或者操作系统）所在分区</span>
root (hd0,0)
kernel /boot/kernel-2.6.24-gentoo-r5 root=/dev/sda3 init=/bin/bb

<span class="code-comment"># 接下来的四行只有在您与Windows系统进行双启动的情况下才需要。</span>
<span class="code-comment"># 本例中，windows系统位于/dev/sda6。</span>
title Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre></td></tr>
</tbody></table>
<a name="book_part1_chap10__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 使用genkernel的用户的grub.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title Gentoo Linux 2.6.24-r5
root (hd0,0)
kernel /boot/kernel-genkernel-x86-2.6.24-gentoo-r5 root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/sda3 
initrd /boot/initramfs-genkernel-x86-2.6.24-gentoo-r5

<span class="code-comment"># 只有在双启动的情况下才需要以下内容</span>
title Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1
</pre></td></tr>
</tbody></table>
<p>
如果您使用与此不同的分区方案和／或内核镜像，请相应地进行调整。无论怎样，请确保紧跟在GRUB设备（例如<span class="path" dir="ltr">(hd0,0)</span>）后面的是相对于挂载点的路径，而不是根目录。换句话说，<span class="path" dir="ltr">(hd0,0)/grub/splash.xpm.gz</span>的实际目标是<span class="path" dir="ltr">/boot/grub/splash.xpm.gz</span>，因为<span class="path" dir="ltr">(hd0,0)</span>就是<span class="path" dir="ltr">/boot</span>分区。
</p>
<p>
另外，如果您选择使用不同的分区方案并且没有将<span class="path" dir="ltr">/boot</span>置于一个独立的分区，上述示例代码中<span class="path" dir="ltr">/boot</span>前缀实际上是<span class="emphasis">必需</span>的。如果您使用我们所建议的分区方案，则不一定非要使用<span class="path" dir="ltr">/boot</span>前缀，但即便加了它，由于/boot分区里有一个<span class="path" dir="ltr">boot</span>符号链接指向当前目录，也可以正常工作。简单的说，无论您是否定义了一个独立的<span class="path" dir="ltr">/boot</span>分区，上述例子应该都能正常工作。
</p>
<p>
如果您需要传递任何其他的参数给内核，简单地在内核命令后面加上它们就可以了。我们已经传递了一个参数（<span class="code" dir="ltr">root=/dev/sda3</span>或<span class="code" dir="ltr">real_root=/dev/sda3</span>），但您也可以加上其他的，例如我们前面讨论过的为framebuffer加上<span class="code" dir="ltr">video</span>和／或<span class="code" dir="ltr">vga</span>参数等等。
</p>
<p>
如果您使用的是2.6.7或更高版本的内核，并且您使用硬盘跳线来使主板的BIOS能正确处理大硬盘，那么在启动内核时您还需要附加<span class="code" dir="ltr">sda=stroke</span>的参数。请把sda替换成需要这个参数的设备。
</p>
<p>
<span class="code" dir="ltr">genkernel</span>用户需知道他们的内核使用与安装光盘相同的启动参数。例如，若您有SCSI设备时，您就需要添加<span class="code" dir="ltr">doscsi</span>这个内核启动参数。
</p>
<p>
现在请保存<span class="path" dir="ltr">grub.conf</span>文件并退出。您仍需要将GRUB安装到MBR（主引导记录），以便重启时GRUB能自动执行。
</p>
<p>
GRUB的开发者推荐使用<span class="code" dir="ltr">grub-install</span>。尽管如此，如果在某些情况下<span class="code" dir="ltr">grub-install</span>无法正常工作，您依然可以选择进行手动安装GRUB。
</p>
<p>
从<a href="#grub-install-auto">默认：使用grub-install安装GRUB</a>或者<a href="#grub-install-manual">备选：使用手动指令安装GRUB</a>继续。
</p>
<p class="secthead"><a name="grub-install-auto"></a><a name="book_part1_chap10__chap2_sect3">默认：使用grub-install安装GRUB</a></p>
<p>
为了安装GRUB，您将需要执行<span class="code" dir="ltr">grub-install</span>命令。尽管如此，当我们处于chroot的环境时，<span class="code" dir="ltr">grub-install</span>并不能正常的工作。我们还需要创建一个<span class="path" dir="ltr">/etc/mtab</span>，在里面列出所有已加载的文件系统。幸运的是，有一个简单的方法来完成这个任务——将<span class="path" dir="ltr">/proc/mounts</span>拷贝成<span class="path" dir="ltr">/etc/mtab</span>，如果您没有创建一个独立的boot分区，请排除<span class="code" dir="ltr">rootfs</span>行。下面的命令在两种情况下都可以正常工作：
</p>
<a name="book_part1_chap10__chap2_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.5: 创建/etc/mtab</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">grep -v rootfs /proc/mounts &gt; /etc/mtab</span>
</pre></td></tr>
</tbody></table>
<p>
现在我们就可以用<span class="code" dir="ltr">grub-install</span>来安装GRUB了：
</p>
<a name="book_part1_chap10__chap2_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.6: 执行grub-install</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">grub-install --no-floppy /dev/sda</span>
</pre></td></tr>
</tbody></table>
<p>
如果您还有更多与GRUB相关的问题，请查阅<a href="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</a>或者<a href="http://www.gnu.org/software/grub/manual/">GRUB手册</a>。
</p>
<p>
从<a href="#reboot">重启系统</a>章节继续。
</p>
<p class="secthead"><a name="grub-install-manual"></a><a name="book_part1_chap10__chap2_sect4">备选：使用手动指令安装GRUB</a></p>
<p>
您可以通过输入<span class="code" dir="ltr">grub</span>来开始配置GRUB。呈现在您面前的将是grub命令提示符<span class="path" dir="ltr">grub&gt;</span>。现在，您需要输入正确的命令来将GRUB引导记录安装到您的硬盘中。
</p>
<a name="book_part1_chap10__chap2_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.7: 启动GRUB shell</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">grub --no-floppy</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果您的系统中没有任何的软盘驱动器，在上面的命令后面加上<span class="code" dir="ltr">--no-floppy</span>选项，防止grub检测（实际上不存在的）软驱。
</p></td></tr></tbody></table>
<p>
在此示例配置中，我们想让我们安装的GRUB可以从boot分区<span class="path" dir="ltr">/dev/sda1</span>读取信息，同时我们将GRUB引导记录安装到硬盘的MBR（主引导记录）中，这样当打开电脑时您首先可以看到的就是GRUB引导的界面。当然，如果您安装时没有按照示例配置来做，请相应的更改一些命令。
</p>
<p>
GRUB的tab自动补全机制可以在GRUB中使用。例如，如果您输入“<span class="code" dir="ltr">root (</span>”之后按下TAB键，一个设备列表就会呈现在您面前（例如<span class="path" dir="ltr">hd0</span>）。如果您输入“<span class="code" dir="ltr">root (hd0,</span>”之后按下TAB键，系统又将返回一个已有的分区列表，以便您选择（例如<span class="path" dir="ltr">hd0,0</span>）。
</p>
<p>
利用tab补全，设置GRUB将不会那么困难。现在我们继续设置GRUB，如何？ :-)
</p>
<a name="book_part1_chap10__chap2_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.8: 将GRUB安装到硬盘主引导记录中</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>grub&gt; <span class="code-input">root (hd0,0)</span>    <span class="code-comment">（指定您的/boot目录所在分区）</span>
grub&gt; <span class="code-input">setup (hd0)</span>     <span class="code-comment">（将GRUB安装到硬盘主引导记录）</span>
grub&gt; <span class="code-input">quit</span>            <span class="code-comment">（退出GRUB shell）</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果您想将GRUB安装到某一个分区而不是硬盘主引导记录中，您需要调整<span class="code" dir="ltr">setup</span>命令，使其指向正确的分区。例如，如果您要将GRUB安装到<span class="path" dir="ltr">/dev/sda3</span>，对应的命令应该是<span class="code" dir="ltr">setup (hd0,2)</span>。但是只有少数用户需要这么做。
</p></td></tr></tbody></table>
<p>
如果您还有更多与GRUB相关的问题，请查阅<a href="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ</a>或者<a href="http://www.gnu.org/software/grub/manual/">GRUB手册</a>。
</p>
<p>
从<a href="#reboot">重启系统</a>章节继续。
</p>
<p class="chaphead"><a name="lilo"></a><a name="book_part1_chap10__chap3"></a><span class="chapnum">10.c. </span>备选：使用LILO</p>
<p class="secthead"><a name="book_part1_chap10__chap3_sect1">安装LILO</a></p>
<p>
LILO，是LInuxLoader的简称，它是一个可靠且确实能担当重任的Linux的bootloader。尽管如此，它缺少一些GRUB具有的特性
（这正是目前GRUB之所以流行的原因）。LILO仍被人们使用的原因在于：在一些系统中，GRUB不能工作而LILO可以。当然，也有一些用户是因为熟
悉它而仍坚持使用它。无论是什么原因，Gentoo对两个bootloader都提供了支持，看到这里显然您已经选择了使用LILO。
</p>
<p>
安装LILO是件轻而易举的事；只需<span class="code" dir="ltr">emerge</span>就好了。
</p>
<a name="book_part1_chap10__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 安装LILO</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge lilo</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part1_chap10__chap3_sect2">配置LILO</a></p>
<p>
要配置LILO，您必须创建<span class="path" dir="ltr">/etc/lilo.conf</span>文件。打开一个您喜欢的编辑器（为保持一致性，在本手册中我们使用<span class="code" dir="ltr">nano</span>）然后创建它。
</p>
<a name="book_part1_chap10__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 创建/etc/lilo.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">nano -w /etc/lilo.conf</span>
</pre></td></tr>
</tbody></table>
<p>
前面章节中我们已经提醒您记下您所创建的内核镜像文件名。在接下来的示例<span class="path" dir="ltr">lilo.conf</span>中，我们使用的是示例的分区方案。这里有两个独立的部分：
</p>
<ul>
  <li>
    一个是为那些不使用<span class="code" dir="ltr">genkernel</span>建立内核的用户准备的
  </li>
  <li>
    另一个是为那些使用<span class="code" dir="ltr">genkernel</span>建立内核的用户准备的
  </li>
</ul>
<p>
请确保您使用的是<span class="emphasis">您自己的</span>内核镜像的文件名，以及（如果用到的话）<span class="emphasis">您自己的</span>initrd镜像的文件名。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果您使用JFS来作为root文件系统，您就<span class="emphasis">必须</span>在每个引导项目的后面添加上形如<span class="code" dir="ltr">append="ro"</span>的一行内容，因为JFS文件系统在其允许被加载为可读写状态前需要使用这个参数来重放它的日志。
</p></td></tr></tbody></table>
<a name="book_part1_chap10__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 示例/etc/lilo.conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>boot=/dev/sda             <span class="code-comment"># 将LILO安装到硬盘主引导扇区</span>
prompt                    <span class="code-comment"># 给用户选择其他引导项目的机会</span>
timeout=50                <span class="code-comment"># 引导默认引导项目前等待5秒钟</span>
default=gentoo            <span class="code-comment"># 当等待结束后引导“gentoo”项目</span>

<span class="code-comment"># 给不使用genkernel的用户的</span>
image=/boot/kernel-2.6.24-gentoo-r5
  label=gentoo            <span class="code-comment"># 我们为此引导项目起的名字</span>
  read-only               <span class="code-comment"># 以只读root状态开始。此处不要改变！</span>
  root=/dev/sda3          <span class="code-comment"># 定位root文件系统</span>

image=/boot/kernel-2.6.24-gentoo-r5
  label=gentoo.rescue     <span class="code-comment"># 我们为此引导项目起的名字</span>
  read-only               <span class="code-comment"># 以只读root状态开始。此处不要改变！</span>
  root=/dev/sda3          <span class="code-comment"># 定位root文件系统</span>
  append="init=/bin/bb"   <span class="code-comment"># 启动Gentoo的静态急救shell</span>

<span class="code-comment"># 给使用genkernel的用户的</span>
image=/boot/kernel-genkernel-x86-2.6.24-gentoo-r5
  label=gentoo
  read-only
  root=/dev/ram0
  append="init=/linuxrc ramdisk=8192 real_root=/dev/sda3"
  initrd=/boot/initramfs-genkernel-x86-2.6.24-gentoo-r5

<span class="code-comment"># 下边的两行只有在您与Windows系统进行双启动的情况下才需要</span>
<span class="code-comment"># 在本例中，Windows位于/dev/sda6</span>
other=/dev/sda6
  label=windows
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果您使用了与此不同的分区方案和/或者内核镜像，请进行相应的调整。
</p></td></tr></tbody></table>
<p>
如果您需要为内核传递任何额外的参数，可以在相应的启动项目里添加一个<span class="code" dir="ltr">append</span>语句。例如，我们加上<span class="code" dir="ltr">video</span>参数来启用framebuffer：
</p>
<a name="book_part1_chap10__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 使用append来添加内核参数</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>image=/boot/kernel-2.6.24-gentoo-r5
  label=gentoo
  read-only
  root=/dev/sda3
  <span class="code-input">append="video=vesafb:mtrr,ywrap,1024x768-32@85"</span>
</pre></td></tr>
</tbody></table>
<p>
如果您使用的是2.6.7或更高版本的内核，并且您使用硬盘跳线来使主板的BIOS能正确处理大硬盘，那么在启动内核时您还需要附加<span class="code" dir="ltr">sda=stroke</span>的参数。请把sda替换成需要这个参数的设备。
</p>
<p>
<span class="code" dir="ltr">genkernel</span>用户需知道他们的内核使用与安装光盘相同的启动参数。例如，若您有SCSI设备时，您需添加<span class="code" dir="ltr">doscsi</span>这个内核启动参数。
</p>
<p>
现在让我们保存文件并退出。要最终完成，您还得运行<span class="code" dir="ltr">/sbin/lilo</span>，这样LILO才能将<span class="path" dir="ltr">/etc/lilo.conf</span>应用到您的系统（也就是将其自身安装到硬盘中）。请记住每当你安装了一个新内核或改变了菜单的任何内容时，您也需要再运行一次<span class="code" dir="ltr">/sbin/lilo</span>。
</p>
<a name="book_part1_chap10__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: 完成LILO的安装</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/sbin/lilo</span>
</pre></td></tr>
</tbody></table>
<p>
如果您还有更多与LILO有关的问题，请参阅它的<a href="http://en.wikipedia.org/wiki/LILO_%28boot_loader%29">wikipedia页面</a>。
</p>
<p>
现在请继续阅读<a href="#reboot">重启系统</a>。
</p>
<p class="chaphead"><a name="reboot"></a><a name="book_part1_chap10__chap4"></a><span class="chapnum">10.d. </span>重启系统</p>
<p>
退出chroot的环境，卸载所有已挂载的分区。然后输入您已经等待多时的那个魔术般的命令：<span class="code" dir="ltr">reboot</span>。
</p>
<a name="book_part1_chap10__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 卸载所有分区和重启</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">exit</span>
cdimage ~# <span class="code-input">cd</span>
cdimage ~# <span class="code-input">umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</span>
cdimage ~# <span class="code-input">reboot</span>
</pre></td></tr>
</tbody></table>
<p>
当然您别忘了取出可引导的光盘盘，否则重启后引导的将是这张光盘而不是您的新Gentoo系统。
</p>
<p>
当重启进入到您新装的Gentoo系统之后，请阅读<a href="#book_part1_chap11">结束Gentoo的安装</a>来完成剩下的工作。
</p>
<a name="book_part1_chap11"></a><h3>11. 结束Gentoo的安装</h3>
<p class="chaphead"><a name="book_part1_chap11__chap1"></a><span class="chapnum">11.a. </span>用户管理</p>
<p class="secthead"><a name="book_part1_chap11__chap1_sect1">为日常使用添加一个用户</a></p>
<p>
在Unix/Linux系统中，用root进行工作是一件<span class="emphasis">危险</span>的事情，应该尽量避免。因此我们<span class="emphasis">强烈</span>推荐您为日常使用添加一个普通用户。
</p>
<p>
用户所属的组定义了其可以执行的活动。下表中列出了许多您可能希望使用的重要组：
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>组</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo">audio</td>
  <td class="tableinfo">允许使用声音设备</td>
</tr>
<tr>
  <td class="tableinfo">cdrom</td>
  <td class="tableinfo">允许直接使用光驱</td>
</tr>
<tr>
  <td class="tableinfo">floppy</td>
  <td class="tableinfo">允许直接使用软驱</td>
</tr>
<tr>
  <td class="tableinfo">games</td>
  <td class="tableinfo">允许运行游戏</td>
</tr>
<tr>
  <td class="tableinfo">portage</td>
  <td class="tableinfo">允许以普通用户的身份执行<span class="code" dir="ltr">emerge --pretend</span>
</td>
</tr>
<tr>
  <td class="tableinfo">usb</td>
  <td class="tableinfo">允许使用USB设备</td>
</tr>
<tr>
  <td class="tableinfo">plugdev</td>
  <td class="tableinfo">
    允许挂载和使用可拔插设备，例如摄像头和U盘
  </td>
</tr>
<tr>
  <td class="tableinfo">video</td>
  <td class="tableinfo">
    允许使用视频采集设备和硬件加速
  </td>
</tr>
<tr>
  <td class="tableinfo">wheel</td>
  <td class="tableinfo">允许使用<span class="code" dir="ltr">su</span>
</td>
</tr>
</tbody></table>
<p>
例如，要创建一个名为<span class="code" dir="ltr">john</span>的用户，并使其隶属于<span class="code" dir="ltr">wheel</span>组，<span class="code" dir="ltr">users</span>组和<span class="code" dir="ltr">audio</span>组，请先用root用户登录（只有root有权限创建用户），然后执行<span class="code" dir="ltr">useradd</span>命令：
</p>
<a name="book_part1_chap11__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 添加一个日常使用的用户</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Login: <span class="code-input">root</span>
Password: <span class="code-comment">(您的root密码)</span>

# <span class="code-input">useradd -m -G users,wheel,audio -s /bin/bash john</span>
# <span class="code-input">passwd john</span>
Password: <span class="code-comment">（输入john用户使用的密码）</span>
Re-enter password: <span class="code-comment">（再次输入以便进行校验）</span>
</pre></td></tr>
</tbody></table>
<p>
有时，普通用户可能需要以root身份执行一些任务，这时您可以使用<span class="code" dir="ltr">su -</span>来临时取得root权限。另外一种方法就是使用<span class="code" dir="ltr">sudo</span>包，如果配置正确，使用它将会非常安全。
</p>
<p class="chaphead"><a name="book_part1_chap11__chap2"></a><span class="chapnum">11.b. </span>磁盘清理</p>
<p class="secthead"><a name="book_part1_chap11__chap2_sect1">移除tarball</a></p>
<p>
现在您的gentoo已经结束了安装并完成了重启，如果一切顺利，您就可以将下载下来的stage3 tarball和Portage快照文件从硬盘里清除掉了。请记住它们是被下载到您的<span class="path" dir="ltr">/</span>目录中的。
</p>
<a name="book_part1_chap11__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 移除stage3 tarball</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rm /stage3-*.tar.bz2*</span>
</pre></td></tr>
</tbody></table>
<a name="book_part1_chap11__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 移除Portage快照文件</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rm /portage-latest.tar.bz2*</span>
</pre></td></tr>
</tbody></table>
<a name="book_part1_chap12"></a><h3>12. 下一步该做什么？</h3>
<p class="chaphead"><a name="book_part1_chap12__chap1"></a><span class="chapnum">12.a. </span>文档</p>
<p>
恭喜！您现在拥有了一个可以运转的Gentoo系统。但接下来往何处去？现在您拥有什么样的选择？先探索些什么？Gentoo为它的用户提供了大量的可能性，因此也有大量已经提供文档（少量没有）的特性。
</p>
<p>
您无疑应该先看一下Gentoo手册里标题为<a href="#book_part2">在Gentoo中工作</a>的那一章节，那里解释了如何保证您随时用上最新的软件，如何安装更多的软件，什么是USE标记，以及Gentoo Init系统是如何工作的等等。
</p>
<p>
如果您有兴趣对系统进行优化以使其适合桌面应用，或者您想了解如何将您的系统配置成一个完整可用的桌面系统，请参阅我们所提供的全面的<a href="http://www.gentoo.org/doc/zh_cn/index.xml?catid=desktop">Gentoo桌面文档资源</a>。另外，我们也提供<a href="http://www.gentoo.org/doc/zh_cn/guide-localization.xml">本地化指南</a>供您参考，利用它您可以使您的系统看起来更加本地化。
</p>
<p>
我们还提供了一份值得您阅读的<a href="http://www.gentoo.org/doc/zh_cn/security/">Gentoo安全手册</a>
</p>
<p>
您如果想得到一份我们已有的可用文档的列表，请查看我们提供的<a href="http://www.gentoo.org/doc/zh_cn/index.xml">文档资源</a>页面。
</p>
<p class="chaphead"><a name="book_part1_chap12__chap2"></a><span class="chapnum">12.b. </span>线上Gentoo</p>
<p>
当然也非常欢迎您加入我们的<a href="http://forums.gentoo.org/">Gentoo论坛</a>或者我们建立的<a href="http://www.gentoo.org/main/en/irc.xml">Gentoo IRC 频道</a>中的任意一个。
</p>
<p>
我们也有一些<a href="http://www.gentoo.org/main/en/lists.xml">邮件列表</a>是面对所有用户开放的。加入列表的方法已包含在前述页面中。
</p>
<p>
现在，我们将保持安静，以便让您享受您的安装过程。:)
</p>
<a name="book_part2"></a><h2>B. 使用Gentoo</h2>
<a name="book_part2_chap1"></a><h3>1. Portage入门</h3>
<p class="chaphead"><a name="book_part2_chap1__chap1"></a><span class="chapnum">1.a. </span>欢迎使用Portage</p>
<p>
Portage可能是Gentoo在软件包管理方面最瞩目的创新。它所具有的高度灵活性以及其他大量的特性，使其经常被认为是Linux中最好用的软件包管理工具。
</p>
<p>
Portage完全用<a href="http://www.python.org/">Python</a>和<a href="http://www.gnu.org/software/bash">Bash</a>写成。由于它们均为脚本语言，所以Portage对于用户而言也就是完全可见的。
</p>
<p>
绝大部分用户将通过<span class="code" dir="ltr">emerge</span>工具来使用Portage。本章节的目的不是在重复emerge的man page里已经提供的内容，如果要完整的了解emerge工具提供的选项，请参考其man page里给出的相应说明。
</p>
<a name="book_part2_chap1__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 获取emerge的帮助信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man emerge</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap1__chap2"></a><span class="chapnum">1.b. </span>Portage树</p>
<p class="secthead"><a name="book_part2_chap1__chap2_sect1">Ebuilds</a></p>
<p>
当我们谈到（软件）包的时候，我们通常指的是Portage树为Gentoo用户提供的包的名称。Portage树是<span class="emphasis">ebuilds</span>文件的集合，这些文件包含了Portage管理工具维护软件（安装，搜索，查询， ...）时所需要的所有信息，并被默认的放置在<span class="path" dir="ltr">/usr/portage</span>目录中。
</p>
<p>
每当您要求Portage对系统中的软件包执行一些操作的时候，它会以系统中的ebuilds文件作为基础。因此您最好定期更新系统Portage树中的ebuild文件，这样Portage才知道新加入了哪些软件，哪些软件发布了安全更新，等等。
</p>
<p class="secthead"><a name="book_part2_chap1__chap2_sect2">更新Portage树</a></p>
<p>
通常我们使用<a href="http://rsync.samba.org/">rsync</a>命令来更新Portage树，它是一个快速的增量性的文件传输工具。另外<span class="code" dir="ltr">emerge</span>命令为rsync命令提供了一个相当简单的前端。
</p>
<a name="book_part2_chap1__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 更新Portage树</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --sync</span>
</pre></td></tr>
</tbody></table>
<p>
如果由于防火墙的限制，您无法进行rsync操作，您仍然可以通过下载我们每天汇总的Portage树快照来更新本地的Portage树。<span class="code" dir="ltr">emerge-webrsync</span>命令会自动将最新的Portage快照下载并安装到您的系统中。
</p>
<a name="book_part2_chap1__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 运行emerge-webrsync</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge-webrsync</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap1__chap3"></a><span class="chapnum">1.c. </span>软件包维护</p>
<p class="secthead"><a name="book_part2_chap1__chap3_sect1">软件的查询</a></p>
<p>
要在Portage树中查找指的的软件，您可以使用<span class="code" dir="ltr">emerge</span>命令里内建的查找功能。默认情况下，<span class="code" dir="ltr">emerge --search</span>会返回那些名字与您指定（无论完整或部分）的名字匹配的软件包。
</p>
<p>
例如，要查找那些名字中包含“pdf”字样的软件：
</p>
<a name="book_part2_chap1__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 查找名字包含pdf的软件包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">emerge --search pdf</span>
</pre></td></tr>
</tbody></table>
<p>
而如果要通过软件的描述来查找相应的软件，您可以使用<span class="code" dir="ltr">--searchdesc</span> (或者简写为 <span class="code" dir="ltr">-S</span>) 开关：
</p>
<a name="book_part2_chap1__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 查找与pdf相关的软件包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">emerge --searchdesc pdf</span>
</pre></td></tr>
</tbody></table>
<p>
当您观察输出结果的时候，会注意到它提供了大量信息。因为相关的区域已经进行了明确的标注，我们就不再进一步介绍各个部分的含义：
</p>
<a name="book_part2_chap1__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 'emerge --search'返回结果的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>*  net-print/cups-pdf
      Latest version available: 1.5.2
      Latest version installed: [ Not Installed ]
      Size of downloaded files: 15 kB
      Homepage:    http://cip.physik.uni-wuerzburg.de/~vrbehr/cups-pdf/
      Description: Provides a virtual printer for CUPS to produce PDF files.
      License:     GPL-2
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap1__chap3_sect2">软件的安装</a></p>
<p>
每当您找到一个感兴趣的软件，您可以轻松地用<span class="code" dir="ltr">emerge</span>命令安装它。例如，要安装<span class="code" dir="ltr">gnumeric</span>：
</p>
<a name="book_part2_chap1__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 安装gnumeric</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge gnumeric</span>
</pre></td></tr>
</tbody></table>
<p>
因为许多应用程序互相依赖，试图安装其中任何一个，可能将会要求同时安装其所依赖的其他相关软件。无需担心，Portage可以很好地处理软件包间的依赖问题。当您安装某个软件的时候，您可以加上<span class="code" dir="ltr">--pretend</span>开关，以便观察Portage<span class="emphasis">将会</span>同时安装哪些软件。例如：
</p>
<a name="book_part2_chap1__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: 假装安装gnumeric</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --pretend gnumeric</span>
</pre></td></tr>
</tbody></table>
<p>
当您要求Portage安装一个软件的时候，必要时它会自动从internet下载相应的源代码包并默认将其保存在<span class="path" dir="ltr">/usr/portage/distfiles</span>目录中，然后将源代码包解压缩，编译并安装软件。如果您仅仅希望Portage将源代码包下载到本地而不安装它们，在<span class="code" dir="ltr">emerge</span>命令后加上<span class="code" dir="ltr">--fetchonly</span>的选项：
</p>
<a name="book_part2_chap1__chap3_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.6: 下载gnumeric的源代码包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --fetchonly gnumeric</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap1__chap3_sect3">查找已安装软件的文档</a></p>
<p>
许多软件包中包含有自己的文档，有些时候<span class="code" dir="ltr">doc</span>的USE标记决定了软件包中的自带文档是否会被安装到本地。您可以通过<span class="code" dir="ltr">emerge -vp &lt;软件包名称&gt;</span>命令来检查是否存在<span class="code" dir="ltr">doc</span> USE标记。
</p>
<a name="book_part2_chap1__chap3_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.7: 检查是否存在doc的USE标记</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">(当然alsa-lib只是一个例子。)</span>
# <span class="code-input">emerge -vp alsa-lib</span>
[ebuild  N    ] media-libs/alsa-lib-1.0.14_rc1  -debug +doc 698 kB
</pre></td></tr>
</tbody></table>
<p>
最好的启用<span class="code" dir="ltr">doc</span>的方式是在<span class="path" dir="ltr">/etc/portage/package.use</span>里对想要启用的包单独启用，这样你就能只获得你想要的软件文档。全局启用此标记已知会导致循环依赖。欲了解更多信息请看<a href="#book_part2_chap2">USE标志</a>一章。
</p>
<p>
当一个软件包安装结束后，它的文档通常会存放在<span class="path" dir="ltr">/usr/share/doc</span>目录下以软件包名命名的子目录中。您也可以通过<span class="code" dir="ltr">equery</span>工具来列出此软件安装后生成的所有文件，这个工具来自于<span class="code" dir="ltr">app-portage/gentoolkit</span> <a href="http://www.gentoo.org/doc/en/gentoolkit.xml">包</a>。
</p>
<a name="book_part2_chap1__chap3_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.8: 定位包的文档</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ls -l /usr/share/doc/alsa-lib-1.0.14_rc1</span>
total 28
-rw-r--r--  1 root root  669 May 17 21:54 ChangeLog.gz
-rw-r--r--  1 root root 9373 May 17 21:54 COPYING.gz
drwxr-xr-x  2 root root 8560 May 17 21:54 html
-rw-r--r--  1 root root  196 May 17 21:54 TODO.gz

<span class="code-comment">(或者使用equery来定位您感兴趣的文件:)</span>
# <span class="code-input">equery files alsa-lib | less</span>
media-libs/alsa-lib-1.0.14_rc1
* Contents of media-libs/alsa-lib-1.0.14_rc1:
/usr
/usr/bin
/usr/bin/alsalisp
<span class="code-comment">(部分输出内容)</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap1__chap3_sect4">软件的移除</a></p>
<p>
当您想把一个软件包从系统中移除的时候，使用<span class="code" dir="ltr">emerge --unmerge</span>命令。命令执行完成后，<span class="emphasis">除了</span>那些在安装软件包后您修改过的配置文件，Portage将会移除此软件包安装到您系统中的所有文件。保留这些修改过的配置文件是为了便于您今后再次使用同一个软件包。
</p>
<p>
不过，您需要<font color="#ff0000"><b>特别注意</b></font>的是：Portage将<span class="emphasis">不会</span>检查您要删除的包是否仍被其他的包依赖。但是当您要删除一个可能破坏您系统的重要的软件包时，它还是会给予警告。
</p>
<a name="book_part2_chap1__chap3_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.9: 从系统中删除gnumeric</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --unmerge gnumeric</span>
</pre></td></tr>
</tbody></table>
<p>
当您从系统中移除一个软件包时，之前那些为了满足其依赖关系而自动被一并安装的软件包将会被保留。如果想让Portage找出那些现在可以移除的相关软件包，可以使用<span class="code" dir="ltr">emerge</span>的<span class="code" dir="ltr">--depclean</span>功能。稍后我们将谈到这点。
</p>
<p class="secthead"><a name="book_part2_chap1__chap3_sect5">更新您的系统</a></p>
<p>
要保持您系统在最佳状态（更不用说安装那些最新的安全更新），您需要定期的更新您的系统。由于Portage只能检查本地Portage树中已有的ebuilds文件，因此您首先应该更新您的Portage树。当您的Portage树更新后，您可以用<span class="code" dir="ltr">emerge --update world</span>命令来更新系统。在下一个例子里，我们还会使用<span class="code" dir="ltr">--ask</span>开关来控制Portage显示它要更新的软件包列表，并让您决定是否继续更新。
</p>
<a name="book_part2_chap1__chap3_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.10: 更新您的系统</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --update --ask world</span>
</pre></td></tr>
</tbody></table>
<p>
Portage接下来会查找您已经安装的软件包是否有更新版本，但它只会核对那些您已经<span class="emphasis">明确地</span>安装过的软件包(也就是在<span class="path" dir="ltr">/var/lib/portage/world</span>文件中列出的包），并不会完整去的检查与这些软件产生依赖关系的包是否也需要更新。如果您想更新系统中的<span class="emphasis">每个软件包</span>，那就加上<span class="code" dir="ltr">--deep</span>参数：
</p>
<a name="book_part2_chap1__chap3_pre11"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.11: 更新整个系统</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --update --deep world</span>
</pre></td></tr>
</tbody></table>
<p>
因为有时开发者会为那些您没有明确要求安装（但被其他软件包依赖而装入系统中）的包推出安全更新，我们也推荐偶尔运行一下这个命令。
</p>
<p>
每当您改变了系统中任何的<a href="#book_part2_chap2">USE标记</a>后，您可能需要加入<span class="code" dir="ltr">--newuse</span>选项。这样Portage将会检查这个USE标记的变动是否导致需要安装新的软件包或者将现有的包重新编译。
</p>
<a name="book_part2_chap1__chap3_pre12"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.12: 执行完整更新</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --update --deep --newuse world</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap1__chap3_sect6">Meta软件包</a></p>
<p>
Portage树中的一些软件包并没有包含任何实际的内容，而只是用来安装一系列软件包的集合。例如，<span class="code" dir="ltr">kde</span>包就是一个包含了一系列与KDE相关的互相依赖的软件包的集合，您可以通过安装它来在系统中搭建起一个完整的KDE环境。
</p>
<p>
如果您试图从系统中移除一个这样的软件包的集合体，只是单纯地使用<span class="code" dir="ltr">emerge --unmerge</span>命令并不能完成您的要求，原因在于这些包的依赖关系仍然保留在系统中。
</p>
<p>
不用担心，Portage也提供了移除孤立依赖的软件包的功能，但由于软件包间的依赖关系是动态的，您首先需要充分地更新您的整个系统，包括更改USE标记设定而导致的变化。在这之后您可以运行<span class="code" dir="ltr">emerge --depclean</span>来移除那些完全没有被其他包依赖的软件包（“orphaned dependencies”）。移除之后你需要重新编译那些曾经与刚刚移除的这些包动态连接过的应用程序，因为实际上这些程序不需要那些包。
</p>
<p>
所有这些可以用以下三个命令来实现：
</p>
<a name="book_part2_chap1__chap3_pre13"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.13: 移除孤立依赖的软件包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --update --deep --newuse world</span>
# <span class="code-input">emerge --depclean</span>
# <span class="code-input">revdep-rebuild</span>
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">revdep-rebuild</span>工具由<span class="code" dir="ltr">gentoolkit</span>包提供；使用前别忘了首先emerge它：
</p>
<a name="book_part2_chap1__chap3_pre14"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.14: 安装gentoolkit包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge gentoolkit</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap1__chap4"></a><span class="chapnum">1.d. </span>当Portage抱怨的时候...</p>
<p class="secthead"><a name="book_part2_chap1__chap4_sect1">有关SLOT，Virtual，分支，体系结构和Profile</a></p>
<p>
正如我们之前指出的那样，Portage是一个非常强大并支持许多特性的软件包管理工具，而这是其他类似工具所欠缺的。为了理解这一点，我们为您粗略地解释一些Portage的面貌。
</p>
<p>
通过使用Portage，一个软件的不同版本可以共存于一个系统中。其他发行版倾向于直接在软件包名字中包含版本号（例如<span class="code" dir="ltr">freetype</span> 和 <span class="code" dir="ltr">freetype2</span>），Gentoo的Portage使用一种我们称之为<span class="emphasis">SLOT</span>的技术来实现这种并存。一个ebuild为它自身的版本声明了一个确切的SLOT。具有不同SLOT的同一软件的Ebuild可以共存于同一个系统中。例如，上例中那个<span class="code" dir="ltr">freetype</span>包就拥有不同的ebuilds，里面分别有<span class="code" dir="ltr">SLOT="1"</span>和<span class="code" dir="ltr">SLOT="2"</span>的标志。
</p>
<p>
有一些不同的软件包提供了类似的功能。比如<span class="code" dir="ltr">metalogd</span>，<span class="code" dir="ltr">sysklogd</span>和<span class="code" dir="ltr">syslog-ng</span>都是系统日志记录工具。那些依赖于“系统日志记录工具”的程序并不能随便的依赖于其中之一，比如<span class="code" dir="ltr">metalogd</span>，因为其他的系统日志工具可能也是很好的选择。好在Portage允许使用<span class="emphasis">虚拟包</span>：每一个系统日志记录工具都可以提供<span class="code" dir="ltr">virtual/syslog</span>包，因此应用程序们可以设定成仅仅依赖于<span class="code" dir="ltr">virtual/syslog</span>即可。
</p>
<p>Portage树中的软件可以存在于不同的分支中。您的系统默认只会接受那些Gentoo认为稳定的软件包。绝大多数新提交的软件会被添加到测试分
支里。这意味着在此软件被标示为稳定版前需要进行更多的测试。尽管您可以看到那些软件的ebuilds已经加入Portage树，在它们未被加入稳定分支
前Portage将不会安装它们。
</p>
<p>
有些软件只在某几个体系结构上可用。或者在其他体系结构中还不能运行，或者仍需要对其进行更多的测试，或者将软件提交到Portage树中的开发者还不能确定这个软件能否运行于其他体系结构。
</p>
<p>
每一个Gentoo安装都依附于一个确定的<span class="code" dir="ltr">profile</span>，此文件里除了其他信息外还包含了一个正常工作的系统需要的软件包的列表。
</p>
<p class="secthead"><a name="blocked"></a><a name="book_part2_chap1__chap4_sect2">被阻挡的包</a></p>
<a name="book_part2_chap1__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: Portage关于被阻挡的包的警告(使用 --pretend参数)</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>[blocks B     ] mail-mta/ssmtp (is blocking mail-mta/postfix-2.2.2-r1)
</pre></td></tr>
</tbody></table>
<a name="book_part2_chap1__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: Portage关于被阻挡的包的警告(不使用 --pretend参数)</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! Error: the mail-mta/postfix package conflicts with another package.
!!!        both can't be installed on the same system together.
!!!        Please use 'emerge --pretend' to determine blockers. 
</pre></td></tr>
</tbody></table>
<p>
Ebuilds文件中包含了特定的字段，里面为Portage提供了此软件的各种依赖关系的信息。总计有两种可能的依赖关系：一种是编译依赖，在<span class="code" dir="ltr">DEPEND</span>区域进行声明;另一种是“运行时”依赖，在<span class="code" dir="ltr">RDEPEND</span>区域中进行声明。如果上述两种依赖关系中任何一个明确指明某个实体或者虚拟包（译注：可能已安装和正要安装）与要安装的包<span class="emphasis">不</span>相容的时候，就会阻挡软件的安装。
</p>
<p>
为了使安装得以继续进行，您可以选择不安装这个软件包，或者先将发生冲突的包卸载。例如，在我们给出的这个例子中，您可以选择不安装<span class="code" dir="ltr">postfix</span>，或者先卸载<span class="code" dir="ltr">ssmtp</span>。
</p>
<p>
你也可能会遇到某些特定版本的包被屏蔽的情况，比如<b>&lt;</b>media-video/mplayer-bin-1.0_rc1-r2。在这种情况下，升级到一个更新的版本就能解决问题。
</p>
<p>
也有可能两个需要安装的包互相阻挡。这种少见的情况下，您应该明确自己为什么需要同时安装它们。绝大多数时候您只需要安装它们之中的一个就可以了。如果不是这样，请您到<a href="http://bugs.gentoo.org/">Gentoo的bug跟踪系统</a>中提交一个bug，以便我们找出解决方案。
</p>
<p class="secthead"><a name="masked"></a><a name="book_part2_chap1__chap4_sect3">被屏蔽的包</a></p>
<a name="book_part2_chap1__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: Portage关于被屏蔽的包的警告</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! all ebuilds that could satisfy "bootsplash" have been masked. 
</pre></td></tr>
</tbody></table>
<a name="book_part2_chap1__chap4_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.4: Portage关于被屏蔽的包的警告——原因</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! possible candidates are:

- gnome-base/gnome-2.8.0_pre1 (masked by: <span class="code-input">~x86 keyword</span>)
- lm-sensors/lm-sensors-2.8.7 (masked by: <span class="code-input">-sparc keyword</span>)
- sys-libs/glibc-2.3.4.20040808 (masked by: <span class="code-input">-* keyword</span>)
- dev-util/cvsd-1.0.2 (masked by: <span class="code-input">missing keyword</span>)
- games-fps/unreal-tournament-451 (masked by: <span class="code-input">package.mask</span>)
- sys-libs/glibc-2.3.2-r11 (masked by: <span class="code-input">profile</span>)
</pre></td></tr>
</tbody></table>
<p>
当您想安装一个对于您系统不可用的软件包。您会收到类似这样的屏蔽错误提示。您应该试着安装那些对于您系统可用的程序或者等待那些不可用的包被置为可用的。通常一个软件包被屏蔽的原因在于：
</p>
<ul>
  <li>
    <b>~arch keyword</b> 意味着这个软件没有经过充分的测试，不能进入稳定分支，请等待一段时间后在尝试使用它。
  </li>
  <li>
    <b>-arch keyword</b>或<b>-* keyword</b> 意味着这个软件不能工作在您机器的体系结构中。如果您确信它能工作那么请到我们的<a href="http://bugs.gentoo.org/">bugzilla</a>网站提交一个bug报告。
  </li>
  <li>
    <b>missing keyword</b> 意味着这个软件还没有在您机器的体系结构中进行过测试。您可以咨询相应体系结构移植小组是否能对它进行测试，或者您自己为他们进行这样的测试并将您得到的结论提交到我们的<a href="http://bugs.gentoo.org/">bugzilla</a>网站。
  </li>
  <li>
    <b>package.mask</b> 意味着这个软件被认为是损坏的，不稳定的或者有更严重的问题，它被故意标识为“不应使用”。
  </li>
  <li>
    <b>profile</b> 意味着这个软件不适用于您的profile。安装这样的应用软件可能会破坏您的系统，或者只是不能与您使用的profile相兼容。
  </li>
</ul>
<p class="secthead"><a name="missingependencies"></a><a name="book_part2_chap1__chap4_sect4">依赖缺失</a></p>
<a name="book_part2_chap1__chap4_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.5: Portage关于依赖缺失的警告</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>emerge: there are no ebuilds to satisfy "&gt;=sys-devel/gcc-3.4.2-r4".

!!! Problem with ebuild sys-devel/gcc-3.4.2-r2
!!! Possibly a DEPEND/*DEPEND problem. 
</pre></td></tr>
</tbody></table>
<p>
这表示您正尝试安装的应用程序依赖于您的系统不可用的另外一些软件包。请到<a href="http://bugs.gentoo.org/">bugzilla</a>查看是否有此问题的记录，如果没有查找到相关信息的话请提交一个报告。除非您的系统混用了不同分支，否则这类问题不应该发生，若发生了那就是一个bug。
</p>
<p class="secthead"><a name="ambiguousebuild"></a><a name="book_part2_chap1__chap4_sect5">意指不明的Ebuild名称</a></p>
<a name="book_part2_chap1__chap4_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.6: Portage对于意指不明的Ebuild名称的警告</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! The short ebuild name "aterm" is ambiguous.  Please specify
!!! one of the following fully-qualified ebuild names instead:

    dev-libs/aterm
    x11-terms/aterm
</pre></td></tr>
</tbody></table>
<p>
您要安装的应用程序对应有多个同名的包。您需要同时指定类别的名称。Portage会列出所有可供选择的名称匹配的包。
</p>
<p class="secthead"><a name="circulardependencies"></a><a name="book_part2_chap1__chap4_sect6">循环依赖</a></p>
<a name="book_part2_chap1__chap4_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.7: Portage关于循环依赖问题的警告</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! Error: circular dependencies: 

ebuild / net-print/cups-1.1.15-r2 depends on ebuild / app-text/ghostscript-7.05.3-r1
ebuild / app-text/ghostscript-7.05.3-r1 depends on ebuild / net-print/cups-1.1.15-r2 
</pre></td></tr>
</tbody></table>
<p>
两个（或多个）您想安装的包由于循环依赖而不能安装。这很可能源于Portage树中的bug。请等一段时间后重新sync再尝试安装。您也可以去<a href="http://bugs.gentoo.org/">bugzilla</a>看看是否已经有此问题的报告，或者提交一个关于它的报告。
</p>
<p class="secthead"><a name="fetchfailed"></a><a name="book_part2_chap1__chap4_sect7">下载失败</a></p>
<a name="book_part2_chap1__chap4_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.8: Portage关于下载失败的警告</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! Fetch failed for sys-libs/ncurses-5.4-r5, continuing...
<span class="code-comment">(...)</span>
!!! Some fetch errors were encountered.  Please see above for details.
</pre></td></tr>
</tbody></table>
<p>
当Portage下载指定软件的源代码失败时，它会尝试继续安装其它（若适用）的应用程序。源代码下载失败可能源于镜像服务器没有正确同步，也可能因为ebuild文件给出了错误的下载地址。那些保存源代码的服务器也可能因为某些原因当机。
</p>
<p>
一小时后重试一次看看问题是否仍然存在。
</p>
<p class="secthead"><a name="profileprotect"></a><a name="book_part2_chap1__chap4_sect8">系统Profile保护</a></p>
<a name="book_part2_chap1__chap4_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.9: Portage关于profile中保护的包的警告</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>!!! Trying to unmerge package(s) in system profile. 'sys-apps/portage'
!!! This could be damaging to your system.
</pre></td></tr>
</tbody></table>
<p>
您要求移除系统核心软件包中的一个。它是您的profile中所列出的必需的软件，因此不能从系统中移除。
</p>
<p class="secthead"><a name="digesterror"></a><a name="book_part2_chap1__chap4_sect9">Digest验证失败</a></p>
<p>
有时当您试图emerge一个软件包时，它会失败并给出以下信息：
</p>
<a name="book_part2_chap1__chap4_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.10: Digest验证失败</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>&gt;&gt;&gt; checking ebuild checksums
!!! Digest verification failed:
</pre></td></tr>
</tbody></table>
<p>
这是Portage树中出现了错误的迹象，通常这是由于开发者在向Portage树提交一个软件包时出错造成的。
</p>
<p>
当digest校验失败的时候，请<span class="emphasis">不要</span>尝试自己去为此软件包重新产生digest。使用<span class="code" dir="ltr">ebuild foo digest</span>并不能修复问题，反而几乎肯定会使问题变得更糟。
</p>
<p>
取而代之的应该是等待一至两个小时以便让开发者来修复Portage树。一般来说错误很有可能马上就会被开发者注意到，但Portage树的修复也需要一点点时间。当您等待的时候，到<a href="http://bugs.gentoo.org/">Bugzilla</a>看看是否已经有人报告了这个问题。如果没有，那就为那个损坏的包提交一个bug报告吧。
</p>
<p>
一旦在Bugzilla上看到此问题已经修复，您只需要重新sync就可以下载下来那些修复后的digest。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
但值得注意的是：这并<span class="emphasis">不</span>意为着您可以短时间内多次重复sync您的portage树（对于同一个rsync服务器）。正如（当您运行<span class="code" dir="ltr">emerge --sync</span>时）rsync
策略所指出的那样，那些短时间内过于频繁进行多次sync的用户将会被更新服务器禁止访问（一般是将你的IP添加到禁止名单并保留一段指定的时间后才解
除）。实际上，最好等到您的下次计划更新的日子再sync，因为这样您不会使rsync服务器过载而影响其他用户的正常使用。
</p></td></tr></tbody></table>
<a name="book_part2_chap2"></a><h3>2. USE标记</h3>
<p class="chaphead"><a name="book_part2_chap2__chap1"></a><span class="chapnum">2.a. </span>USE标记是什么？</p>
<p class="secthead"><a name="book_part2_chap2__chap1_sect1">USE标记的指导思想</a></p>
<p>
你在安装gentoo（或者是其他发行版，甚至于其他特定操作系统）的时候，你要依据你工作的环境做出选择。服务器跟工作站的组织结构不同，游戏机跟3D工作站也会不一样。
</p>
<p>不单只是选择你想要安装的包时如此，选择某一个包需要的特性时同样如此。如果你不需要OpenGL，为什么还要颇费周折的安装OpenGL并在其他
包中加入对OpenGL的支持？如果你不想用KDE，而且软件包没有KDE也能完美运行，为什么还要在编译这些包的时候加入KDE支持？
</p>
<p>
为了帮用户判断什么需要安装或激活，什么不需要；我们希望用户能用简单的方式设定他们自己的环境。这能促使用户判断他真正需要的东西，并让Portage（我们的包管理系统）做出有用的决定的过程变得简单。
</p>
<p class="secthead"><a name="book_part2_chap2__chap1_sect2">USE标记的设定</a></p>
<p>
我们来具体看看USE标记。每一个标记都是代表对某特定概念的支持和依赖关系信息的关键字。如果你设定了某个USE标记，Portage会明白你选择了支持这个关键字（所代表的概念）。当然这同时也改变了这个包的依赖关系信息。
</p>
<p>
让我们看一个示例：关键字<span class="code" dir="ltr">kde</span>。如果你的<span class="code" dir="ltr">USE</span>变量里面没有这个关键字，所有具有<span class="emphasis">可选</span>KDE支持的包在编译时都<span class="emphasis">不会</span>编译KDE支持。所有具有<span class="emphasis">可选</span>KDE依赖关系的包在安装时都<span class="emphasis">不会</span>（做为一个依赖关系而）安装KDE库。如果你设定了<span class="code" dir="ltr">kde</span>关键字，这些包在安装时都<span class="emphasis">会</span>编译KDE支持，而且KDE库也会（作为一个依赖关系而）被安装。
</p>
<p>
通过正确设定关键字，你会得到一个根据你的需要而定制的系统。
</p>
<p class="secthead"><a name="book_part2_chap2__chap1_sect3">有哪些USE标记？</a></p>
<p>
USE标记分两类：<span class="emphasis">全局</span>和<span class="emphasis">局部</span>USE标记。
</p>
<ul>
  <li>
    <span class="emphasis">全局</span>USE标记适用范围是整个系统，可以被许多包使用。这就是大多数人眼里的USE标记。
  </li>
  <li>
    <span class="emphasis">局部</span>USE标记只被单个包用来做该包特有的决定。
  </li>
</ul>
<p>
当前可用的全局USE标记列表可以在<a href="http://www.gentoo.org/dyn/use-index.xml">网上</a>或者本机的<span class="path" dir="ltr">/usr/portage/profiles/use.desc</span>文件里找到。
</p>
<p>
当前可用的局部USE标记列表可以在本机的<span class="path" dir="ltr">/usr/portage/profiles/use.local.desc </span>文件里找到。
</p>
<p class="chaphead"><a name="book_part2_chap2__chap2"></a><span class="chapnum">2.b. </span>使用USE标记</p>
<p class="secthead"><a name="book_part2_chap2__chap2_sect1">声明永久USE标记</a></p>
<p>
希望您已经意识到了USE标记的重要性，现在我们就让你了解怎样声明USE标记。
</p>
<p>
就像前面提到的，所有USE标记都声明在<span class="code" dir="ltr">USE</span>变量里面。为了让用户能方便地查找和选择USE标记，我们提供了一份<span class="emphasis">默认</span>的USE设定。这些设定是我们觉得Gentoo用户通常都要用到的USE标记的集合。这个默认设置在<span class="path" dir="ltr">make.defaults</span>文件──你的profile的一部分──里声明。
</p>
<p>
你的系统使用的profile是符号链接<span class="path" dir="ltr">/etc/make.profile</span>所指向的目录。每个profile叠加于某个更大的profile之上，最终的结果是这些profile的并集。初始profile是<span class="path" dir="ltr">base</span> profile（<span class="path" dir="ltr">/usr/portage/profiles/base</span>）。
</p>
<p>
让我们看看2004.3 profile的默认设定：
</p>
<a name="book_part2_chap2__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 2004.3 profile的累积make.defaults USE标记</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">(这个例子是base，default-linux，default-linux/x86和
default-linux/x86/2004.3的设定的并集)</span>
USE="x86 oss apm arts avi berkdb bitmap-fonts crypt cups encode fortran f77
     foomaticdb gdbm gif gpm gtk imlib jpeg kde gnome libg++ libwww mad
     mikmod motif mpeg ncurses nls oggvorbis opengl pam pdflib png python qt
     quicktime readline sdl spell ssl svga tcpd truetype X xml2 xmms xv zlib"
</pre></td></tr>
</tbody></table>
<p>
就像你看到的那样，这个变量已经包括了非常多的关键字。<b>不</b>要通过修改<span class="path" dir="ltr">make.defaults</span>文件里的<span class="code" dir="ltr">USE</span>变量来满足你的需要：在升级Portage的时候，这个文件将会被破坏（被覆盖）。
</p>
<p>
要改变这个默认设置，你需要在<span class="code" dir="ltr">USE</span>变量里添加或移去关键字。这是通过在<span class="path" dir="ltr">/etc/make.conf</span>里定义<span class="code" dir="ltr">USE</span>全局变量来实现的。在这个变量里，添加你需要的额外的USE标记，或者移去你不需要的USE标记。后者可通过在标记前面加个负号（“-”）前缀来实现。
</p>
<p>
例如，要移除对KDE和QT的支持，并添加对ldap的支持，可以在<span class="path" dir="ltr">/etc/make.conf </span>里声明<span class="code" dir="ltr">USE</span>如下：
</p>
<a name="book_part2_chap2__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: /etc/make.conf里关于USE设置的一个例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>USE="-kde -qt3 -qt4 ldap"
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap2__chap2_sect2">为单个包声明USE标记</a></p>
<p>
如果你想要为一个（或者几个）程序而不是系统范围内声明一个USE标记，你需要创建<span class="path" dir="ltr">/etc/portage</span>目录（如果没有这个目录的话），然后编辑<span class="path" dir="ltr">/etc/portage/package.use</span>文件。通常这是一个文件，不过它也可以是一个目录；请看<span class="code" dir="ltr">man portage</span>以获得更多信息。下面的例子假设<span class="path" dir="ltr">package.use</span>是一个文件。
</p>
<p>
比如说，如果你不想全局的启用<span class="code" dir="ltr">berkdb</span>支持，但是你想把它应用到<span class="code" dir="ltr">mysql</span>，你可以这样：
</p>
<a name="book_part2_chap2__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: /etc/portage/package.use示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>dev-db/mysql berkdb
</pre></td></tr>
</tbody></table>
<p>
你当然也可以直接为某一个程序<span class="emphasis">禁用</span>USE标记。比如说，如果你不想要PHP的<span class="code" dir="ltr">java</span>支持：
</p>
<a name="book_part2_chap2__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: /etc/portage/package.use第二个示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>dev-php/php -java
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap2__chap2_sect3">声明临时USE标记</a></p>
<p>
有时，你只想暂时改变一个USE设置。你可以仅仅把USE变量声明成一个环境变量，而不必两次修改<span class="path" dir="ltr">/etc/make.conf</span>。但是要记住，当你重新emerge或者升级这个程序的时候（不管是单独地还是作为系统升级的一部分），你的修改都会丢失！
</p>
<p>
下面的例子我们将在安装seamonkey的时候暂时性地从USE设置中移去java标记。
</p>
<a name="book_part2_chap2__chap2_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.5: 将USE作为一个环境变量使用</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">USE="-java" emerge seamonkey</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap2__chap2_sect4">优先级</a></p>
<p>
当然，我们需要一个明确的先后次序来决定何处的USE设定优先级较高。你肯定不希望在定义了<span class="code" dir="ltr">USE="-java"</span>之后，因为某个有更高优先级的设定而导致<span class="code" dir="ltr">java</span>仍然被使用。USE设定的优先级顺序是（由低到高）：
</p>
<ol>
  <li>
    <span class="path" dir="ltr">make.defaults</span>里面的USE默认设定
  </li>
  <li>
    用户在<span class="path" dir="ltr">/etc/make.conf</span>里面的USE设定
  </li>
  <li>
    用户在<span class="path" dir="ltr">/etc/portage/package.use</span>里面的USE设定
  </li>
  <li>
    作为环境变量的USE设定
  </li>
</ol>
<p>
运行<span class="code" dir="ltr">emerge --info</span>可以看到Portage识别的最终的<span class="code" dir="ltr">USE</span>设定。它会列出Portage使用的所有相关变量（包括<span class="code" dir="ltr">USE</span>变量）。
</p>
<a name="book_part2_chap2__chap2_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.6: 运行emerge --info</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --info</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap2__chap2_sect5">在你的整个系统上应用新的USE标记</a></p>
<p>
如果你已经修改了你的USE标记，而且你想用新USE标记更新你的系统，可以使用<span class="code" dir="ltr">emerge </span>的<span class="code" dir="ltr">--newuse</span>选项：
</p>
<a name="book_part2_chap2__chap2_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.7: 重新构建你的系统</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --update --deep --newuse world</span>
</pre></td></tr>
</tbody></table>
<p>
然后运行Portage的depclean来移除已经安装到你的旧系统里但是在新USE标记中被废除的条件依赖关系。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffbbbb"><p class="note"><b>警告: </b>
运行<span class="code" dir="ltr">emerge --depclean</span>是一项危险的操作，必须小心。请反复检查要删除的包的列表里确定没有你仍然需要的包。下面这个例子里，我们添加了<span class="code" dir="ltr">-p</span>选项来depclean──只列出这些包而不删除他们。
</p></td></tr></tbody></table>
<a name="book_part2_chap2__chap2_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.8: 删除不需要的包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge -p --depclean</span>
</pre></td></tr>
</tbody></table>
<p>
depclean完成之后，运行<span class="code" dir="ltr">revdep-rebuild</span>来重新构建那些动态链接到由可能已经删除的包提供的公共对象的程序。<span class="code" dir="ltr">revdep-rebuild</span>是<span class="code" dir="ltr">gentoolkit</span>包的一部分，不要忘了先emerge它。
</p>
<a name="book_part2_chap2__chap2_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.9: 运行revdep-rebuild</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">revdep-rebuild</span>
</pre></td></tr>
</tbody></table>
<p>
这些都完成之后，你的系统就已经应用上了新的USE标记设定。
</p>
<p class="chaphead"><a name="book_part2_chap2__chap3"></a><span class="chapnum">2.c. </span>包特有的USE标记</p>
<p class="secthead"><a name="book_part2_chap2__chap3_sect1">查看可用USE标记</a></p>
<p>
让我们以<span class="code" dir="ltr">seamonkey</span>来作例子，看看它接收什么USE标记。我们可以以<span class="code" dir="ltr">--pretend</span>和<span class="code" dir="ltr">--verbose</span>为选项执行<span class="code" dir="ltr">emerge</span>来查看：
</p>
<a name="book_part2_chap2__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 查看使用的USE标记</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --pretend --verbose seamonkey</span>
These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild   R   ] www-client/seamonkey-1.0.7  USE="crypt gnome java -debug -ipv6
-ldap -mozcalendar -mozdevelop -moznocompose -moznoirc -moznomail -moznopango
-moznoroaming -postgres -xinerama -xprint" 0 kB
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">emerge</span>并不是做这件事的唯一工具。事实上，我们有一个专门的包信息工具叫<span class="code" dir="ltr">equery</span>，它属于<span class="code" dir="ltr">gentoolkit</span>包。所以首先请安装<span class="code" dir="ltr">gentoolkit</span>:
</p>
<a name="book_part2_chap2__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 安装gentoolkit</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge gentoolkit</span>
</pre></td></tr>
</tbody></table>
<p>
现在以<span class="code" dir="ltr">uses</span>为参数执行<span class="code" dir="ltr">equery</span>来查看指定包的USE标记。例如：<span class="code" dir="ltr">gnumeric</span>包：
</p>
<a name="book_part2_chap2__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 用equery来查看当前使用的USE标记</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">equery --nocolor uses =gnumeric-1.6.3 -a</span>
[ Searching for packages matching =gnumeric-1.6.3... ]
[ Colour Code : set unset ]
[ Legend        : Left column  (U) - USE flags from make.conf  ]
[               : Right column (I) - USE flags packages was installed with ]
[ Found these USE variables for app-office/gnumeric-1.6.3 ]
 U I
- - debug   : Enable extra debug codepaths, like asserts and extra output.
              If you want to get meaningful backtraces see
	      http://www.gentoo.org/proj/en/qa/backtraces.xml.
- - gnome   : Adds GNOME support
+ + python   : Adds support/bindings for the Python language
- - static   : !!do not set this during bootstrap!! Causes binaries to be
                     statically linked instead of dynamically
</pre></td></tr>
</tbody></table>
<a name="book_part2_chap3"></a><h3>3. Portage特性
</h3>
<p class="chaphead"><a name="book_part2_chap3__chap1"></a><span class="chapnum">3.a. </span>Portage特性</p>
<p>
Portage有几个附加的特性，它们能够令您的Gentoo之旅更加愉快。这些特性中的大多数依赖于某些能够提高性能、可靠性、安全性等的软件工具。
</p>
<p>
为了打开或者关闭某一Portage特性您需要编辑<span class="path" dir="ltr">/etc/make.conf</span>中的<span class="code" dir="ltr">FEATURES</span>变量，这个变量包含不同的特性关键字，用空格分开。在一些情况下您可能还需要额外的安装被这个特性所依赖的工具。
</p>
<p>
并不是所有Portage所支持的特性都在这里列出。完整的概述，请查阅<span class="path" dir="ltr">make.conf</span>手册页。
</p>
<a name="book_part2_chap3__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 查阅make.conf手册页</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man make.conf</span>
</pre></td></tr>
</tbody></table>
<p>
查看特性的默认设置，运行<span class="code" dir="ltr">emerge --info</span>并且查找FEATURE变量或者用grep显示它：
</p>
<a name="book_part2_chap3__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 找出已经被设定的特性</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">emerge --info | grep FEATURE</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap3__chap2"></a><span class="chapnum">3.b. </span>分布式编译</p>
<p class="secthead"><a name="book_part2_chap3__chap2_sect1">使用distcc</a></p>
<p>
<span class="code" dir="ltr">distcc</span>是一个分布式编译程序，可以把编译任务分配给同一网络中的不同机器，这些机器的配置不必完全相同。<span class="code" dir="ltr">distcc</span>客户端发送所有必须的信息给所有可利用的distcc服务器（运行<span class="code" dir="ltr">distccd</span>的机器）。这样它们每一个都能为客户端编译一部分源码。所导致的效果就是更短的编译时间。
</p>
<p>
您可以在<a href="http://www.gentoo.org/doc/zh_cn/distcc.xml">Gentoo Distcc文档</a>里找到更多的关于<span class="code" dir="ltr">distcc</span>的信息（包括如何让它在Gentoo上工作）。
</p>
<p class="secthead"><a name="book_part2_chap3__chap2_sect2">安装distcc</a></p>
<p>
Distcc使用一个图形化监视器来监视您的机器发送出去的编译工作。如果您使用GNOME，那么将“gnome”放入您的<span class="code" dir="ltr">USE</span>设置中。但是，如果您不使用GNOME而仍然希望使用这个监视器，那么就把“gtk”放进您的<span class="code" dir="ltr">USE</span>设置中。
</p>
<a name="book_part2_chap3__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装distcc</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge distcc</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap3__chap2_sect3">激活Portage支持</a></p>
<p>
添加<span class="code" dir="ltr">distcc</span>到<span class="path" dir="ltr">/etc/make.conf</span>之中的FEATURES变量。然后，设定您合意的MAKEOPTS变量。一个众所周知的参数是"-jX"，其中<span class="code" dir="ltr">X</span>为运行<span class="code" dir="ltr">distccd</span>主机（包含当前主机）的CPU数目加上一，但是您也可能用其他的数字来得到更好的结果。
</p>
<p>
现在运行<span class="code" dir="ltr">distcc-config</span>并输入已有的DistCC服务器。作为一个简单例子，我们假设已有的DistCC服务器是<span class="code" dir="ltr">192.168.1.102</span>（当前主机）、<span class="code" dir="ltr">192.168.1.103</span>和<span class="code" dir="ltr">192.168.1.104</span>（两个远端服务器）：
</p>
<a name="book_part2_chap3__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 配置Distcc，使用已有的三个DistCC服务器</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">distcc-config --set-hosts "192.168.1.102 192.168.1.103 192.168.1.104"</span>
</pre></td></tr>
</tbody></table>
<p>
当然，也不要忘了运行<span class="code" dir="ltr">distccd</span>系统服务：
</p>
<a name="book_part2_chap3__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 开始Distcc系统服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rc-update add distccd default</span>
# <span class="code-input">/etc/init.d/distccd start</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap3__chap3"></a><span class="chapnum">3.c. </span>缓冲编译结果</p>
<p class="secthead"><a name="book_part2_chap3__chap3_sect1">关于ccache</a></p>
<p>
<span class="code" dir="ltr">ccache</span>是一个快速的编译器缓存。当您编译一个程序的时候，它会缓存中间的结果。这样，不论什么时候您重新编译同一个程序，编译所需要得时间将被大大缩短。对于普通的编译来说，这可以提高编译速度5到10倍。
</p>
<p>
如果您对<span class="code" dir="ltr">ccache</span>的工作机制有兴趣，请访问<a href="http://ccache.samba.org/">ccache主页</a>.
</p>
<p class="secthead"><a name="book_part2_chap3__chap3_sect2">安装ccache</a></p>
<p>
要安装<span class="code" dir="ltr">ccache</span>，只需要运行<span class="code" dir="ltr">emerge ccache</span>:
</p>
<a name="book_part2_chap3__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 安装ccache</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge ccache</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap3__chap3_sect3">激活Portage支持</a></p>
<p>
打开<span class="path" dir="ltr">/etc/make.conf</span>并添加<span class="code" dir="ltr">ccache</span>到FEATURES变量。然后添加一个新的变量CCACHE_SIZE并设置它为"2G":
</p>
<a name="book_part2_chap3__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 在/etc/make.conf中设定CCACHE_SIZE</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>CCACHE_SIZE="2G"
</pre></td></tr>
</tbody></table>
<p>
要检查ccache是否运行，只需让它提供给您它的统计数据。因为Portage使用一个不同的ccache主目录，您需要设定<span class="code" dir="ltr">CCACHE_DIR</span>变量：
</p>
<a name="book_part2_chap3__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: 查看ccache统计数据</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">CCACHE_DIR="/var/tmp/ccache" ccache -s</span>
</pre></td></tr>
</tbody></table>
<p>
<span class="path" dir="ltr">/var/tmp/ccache</span>是Portage的默认ccache主目录；为了修改这个设置，您可以设定<span class="path" dir="ltr">/etc/make.conf</span>中的<span class="code" dir="ltr">CCACHE_DIR</span>参数。
</p>
<p>
不过，如果您运行<span class="code" dir="ltr">ccache</span>，它使用的默认目录是<span class="path" dir="ltr">${HOME}/.ccache</span>。这就是为什么当您查询（Portage）ccache统计数据的时候您需要设定<span class="code" dir="ltr">CCACHE_DIR</span>参数的原因。
</p>
<p class="secthead"><a name="book_part2_chap3__chap3_sect4">非Portage C编译中使用ccache</a></p>
<p>
如果您需要在非Portage编译中使用ccache，添加<span class="path" dir="ltr">/usr/lib/ccache/bin</span>到您PATH参数里靠前的位置（在<span class="path" dir="ltr">/usr/bin</span>之前）。这一点可以通过编辑在您用户主目录中的<span class="path" dir="ltr">.bash_profile</span>文件来实现。使用<span class="path" dir="ltr">.bash_profile</span>是定义PATH参数的一个方式.
</p>
<a name="book_part2_chap3__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 编辑.bash_profile</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>PATH="<span class="code-input">/usr/lib/ccache/bin</span>:/opt/bin:${PATH}"
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap3__chap4"></a><span class="chapnum">3.d. </span>二进制包支持</p>
<p class="secthead"><a name="book_part2_chap3__chap4_sect1">创建预编译包</a></p>
<p>
Portage支持用预编译包安装。尽管Gentoo本身并不提供预编译包（除GRP快照之外），Portage依然能够处理预编译包。
</p>
<p>
如果某个包已经被安装在您的系统上，您可以用<span class="code" dir="ltr">quickpkg</span>来创建一个预编译包。也可以用带有<span class="code" dir="ltr">--buildpkg</span>或<span class="code" dir="ltr">--buildpkgonly</span>选项的<span class="code" dir="ltr">emerge</span>命令。
</p>
<p>
如果您希望Portage为您所安装的每一个单独的包创建预编译包，在FEATURES中添加<span class="code" dir="ltr">buildpkg</span>参数.
</p>
<p>
预编译包的更多扩展支持可以用<span class="code" dir="ltr">catalyst</span>得到。关于catalyst的更多信息请参阅<a href="http://www.gentoo.org/proj/en/releng/catalyst/faq.xml">Catalyst FAQ</a>.
</p>
<p class="secthead"><a name="book_part2_chap3__chap4_sect2">安装预编译包</a></p>
<p>
尽管Gentoo并不提供，但是您可以自己建立一个“中心仓库”来存放预编译包。如果您希望使用这个仓库，您需要设定PORTAGE_BINHOST参数使Portage能够知道它。例如，如果预编译包在ftp://buildhost/gentoo上：
</p>
<a name="book_part2_chap3__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 在/etc/make.conf中设定PORTAGE_BINHOST参数</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>PORTAGE_BINHOST="ftp://buildhost/gentoo"
</pre></td></tr>
</tbody></table>
<p>
当您需要安装预编译包的时候，在emerge命令后的<span class="code" dir="ltr">--getbinpkg</span>选项旁加入<span class="code" dir="ltr">--usepkg</span>选项。前者让emerge命令从预定的服务器上下载预编译包，后者让emerge首先试图安装预编译包，如果预编译包不存在，那么才下载并编译源码。
</p>
<p>
例如：用预编译包安装<span class="code" dir="ltr">gnumeric</span>
</p>
<a name="book_part2_chap3__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: 安装gnumeric的预编译包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge --usepkg --getbinpkg gnumeric</span>
</pre></td></tr>
</tbody></table>
<p>
关于emerge的预编译包的更多信息请参阅emerge手册页:
</p>
<a name="book_part2_chap3__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: 阅读emerge手册页</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man emerge</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap3__chap5"></a><span class="chapnum">3.e. </span>下载文件</p>
<p class="secthead"><a name="book_part2_chap3__chap5_sect1">并行下载</a></p>
<p>
当您在编译一系列软件的时候，Portage能在编译某一个包的同时下载编译列表中后面的包的源码，这样就缩短了安装时间。如果您希望使用这种功能，添加“parallel-fetch”到您的FEATURES变量里。
</p>
<p class="secthead"><a name="book_part2_chap3__chap5_sect2">Usersfetch</a></p>
<p>
当您以root身份运行Portage，FEATURES="userfetch"可以让Portage在下载源码包的时候放弃root特权。这是一个小小的安全性的提高。
</p>
<a name="book_part2_chap4"></a><h3>4. 初始化脚本</h3>
<p class="chaphead"><a name="book_part2_chap4__chap1"></a><span class="chapnum">4.a. </span>运行级别</p>
<p class="secthead"><a name="book_part2_chap4__chap1_sect1">启动你的系统</a></p>
<p>
当你启动系统时，会发现有很多的文字信息输出。如果注意观察的话，会发现每次启动时这些文字信息都是相同的。所有这些动作的顺序我们称之为<span class="emphasis">启动顺序</span>，而且它们基本上是被静态定义的。
</p>
<p>
首先，你的引导程序会把你在引导程序配置文件中定义的内核镜像加载到内存中，之后它就告诉CPU可以运行内核了。当内核被加载且运行后，内核会初始化所有内核专有的结构体和任务，并开启<span class="code" dir="ltr">init</span>进程。
</p>
<p>
然后，这个进程确保所有的文件系统（在<span class="path" dir="ltr">/etc/fstab</span>中定义的）都已被挂载且能使用。接着，该进程会执行位于<span class="path" dir="ltr">/etc/init.d</span>下的一些脚本，这些脚本会启动一些你需要的服务，以使你能获得一个成功启动的系统。
</p>
<p>
最终，当所有的脚本执行完毕，<span class="code" dir="ltr">init</span>将激活终端（大多情况下只是激活虚拟终端，可以使用<span class="code" dir="ltr">Alt-F1</span>、<span class="code" dir="ltr">Alt-F2</span>等来访问），并把一个叫<span class="code" dir="ltr">agetty</span>的特殊进程附于其上。这个进程会确保你可以通过运行<span class="code" dir="ltr">login</span>从这些终端登录到你的系统中。
</p>
<p class="secthead"><a name="book_part2_chap4__chap1_sect2">初始化脚本</a></p>
<p>
现在<span class="code" dir="ltr">init</span>不会随机的执行<span class="path" dir="ltr">/etc/init.d</span>下的脚本。甚至，它不会运行<span class="path" dir="ltr">/etc/init.d</span>下所有的脚本，它只会执行那些需要被执行的脚本。这个是由<span class="path" dir="ltr">/etc/runlevels</span>目录决定的。
</p>
<p>
首先，<span class="code" dir="ltr">init</span>会运行所有<span class="path" dir="ltr">/etc/runlevels/boot</span>目录下的符号链接所指向的<span class="path" dir="ltr">/etc/init.d</span>目录下的脚本。通常，它会按照字母顺序执行这些脚本，但是有些脚本中含有依赖关系，意味着系统要在执行另一个脚本之后才能运行此脚本。
</p>
<p>
当<span class="path" dir="ltr">/etc/runlevels/boot</span>目录所引用的脚本都执行完毕后，<span class="code" dir="ltr">init</span>将继续运行<span class="path" dir="ltr">/etc/runlevels/default</span>目录下的符号链接所指向的脚本。同样它们会按照字母顺序执行这些脚本，除非一个脚本有依赖关系，那样的话现有次序就会被改变以使启动顺序更加合理。
</p>
<p class="secthead"><a name="book_part2_chap4__chap1_sect3">Init进程是如何工作的</a></p>
<p>
当然<span class="code" dir="ltr">init</span>自己不会决定所有的启动顺序。它需要一个配置文件来指定它的工作流程。这个配置文件就是<span class="path" dir="ltr">/etc/inittab</span>。
</p>
<p>
如果你还记得我们刚刚描述的启动顺序，你会记得<span class="code" dir="ltr">init</span>首先做的是挂载所有的文件系统。这个功能其实是在<span class="path" dir="ltr">/etc/inittab</span>这个配置文件中定义好的。如下：
</p>
<a name="book_part2_chap4__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: /etc/inittab中系统初始化行</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>si::sysinit:/sbin/rc sysinit
</pre></td></tr>
</tbody></table>
<p>
这一行告诉<span class="code" dir="ltr">init</span>必须运行<span class="code" dir="ltr">/sbin/rc sysinit</span>来初始化系统。<span class="path" dir="ltr">/sbin/rc</span>脚本是负责系统初始化的，所以你可能会说<span class="code" dir="ltr">init</span>它本身并没做太多的事情——它只是把初始化系统任务交给了另一个进程。
</p>
<p>
接下来，<span class="code" dir="ltr">init</span>会执行所有在<span class="path" dir="ltr">/etc/runlevels/boot</span>目录下的具有符号链接的脚本。这是由下面这行定义的：
</p>
<a name="book_part2_chap4__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 系统初始化，承上</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>rc::bootwait:/sbin/rc boot
</pre></td></tr>
</tbody></table>
<p>
同样，<span class="code" dir="ltr">rc</span>脚本将完成必要的工作。注意：给rc脚本的参数（<span class="emphasis">boot</span>）和要用的<span class="path" dir="ltr">/etc/runlevels</span>的子目录是一样的。
</p>
<p>
现在<span class="code" dir="ltr">init</span>进程将检查配置文件来判断应该运行哪个<span class="emphasis">运行级别（runlevel）</span>。它是通过读取<span class="path" dir="ltr">/etc/inittab</span>中的下面这行来决定的：
</p>
<a name="book_part2_chap4__chap1_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.3: 系统默认运行级别行</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>id:3:initdefault:
</pre></td></tr>
</tbody></table>
<p>
在这个例子（绝大部分的Gentoo用户将使用）里，<span class="emphasis">运行级别</span>id为3。根据这个信息，<span class="code" dir="ltr">init</span>进程会检查该执行什么来启动<span class="emphasis">运行级别3</span>：
</p>
<a name="book_part2_chap4__chap1_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.4: 运行级别的定义</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
</pre></td></tr>
</tbody></table>
<p>
定义了级别3的行将再次调用<span class="code" dir="ltr">rc</span>脚本来启动服务（现在参数为<span class="emphasis">default</span>）。请再次注意：<span class="code" dir="ltr">rc</span>使用的参数和<span class="path" dir="ltr">/etc/runlevels</span>下的子目录是一样的。
</p>
<p>
当<span class="code" dir="ltr">rc</span>执行完毕后，<span class="code" dir="ltr">init</span>将会决定哪些虚拟终端需要被激活以及每个终端需要运行什么样的命令：
</p>
<a name="book_part2_chap4__chap1_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.5: 虚拟终端定义</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap4__chap1_sect4">什么是运行级别？</a></p>
<p>
你已经看到<span class="code" dir="ltr">init</span>使用一种数字的方式来决定需要激活的运行级别。<span class="emphasis">运行级别</span>表示你系统运行的状态，它包含了你进入或退出一个运行级别时需要执行的一组脚本（运行级别脚本或者<span class="emphasis">初始化脚本</span>）。
</p>
<p>
在Gentoo中定义了七种运行级别：三个内部运行级别和四个用户自定义运行级别。这些内部运行级别分别叫做<span class="emphasis">sysinit</span>、<span class="emphasis">shutdown</span>和<span class="emphasis">reboot</span>，它们所做的就如同像它们的名字那样：初始化系统、关闭系统和重启系统。
</p>
<p>
用户定义的运行级别都在<span class="path" dir="ltr">/etc/runlevels</span>目录下有同名的子目录：<span class="path" dir="ltr">boot</span>、<span class="path" dir="ltr">default</span>、<span class="path" dir="ltr">nonetwork</span>和<span class="path" dir="ltr">single</span>。运行级别<span class="path" dir="ltr">boot</span>会启动所有其他运行级别必须要使用到的系统服务。其余的三个运行级别的不同之处主要在于它们要启动的服务：<span class="path" dir="ltr">default</span>是用来日常工作用的；<span class="path" dir="ltr">nonetwork</span>是在无网络的情况下使用的；还有<span class="path" dir="ltr">single</span>是用户修复系统时用的。
</p>
<p class="secthead"><a name="book_part2_chap4__chap1_sect5">使用初始化脚本</a></p>
<p>
实际上<span class="code" dir="ltr">rc</span>进程调用的脚本都称为<span class="emphasis">初始化脚本</span>。每个在<span class="path" dir="ltr">/etc/init.d</span>下的脚本都可以在执行时带上以下参数，如：<span class="emphasis">start</span>、<span class="emphasis">stop</span>、<span class="emphasis">restart</span>、<span class="emphasis">pause</span>、<span class="emphasis">zap</span>、<span class="emphasis">status</span>、<span class="emphasis">ineed</span>、<span class="emphasis">iuse</span>、<span class="emphasis">needsme</span>、<span class="emphasis">usesme</span>或者<span class="emphasis">broken</span>。
</p>
<p>
要启动、停止或者重启一个服务（和所有依赖于它的服务），应该用参数<span class="code" dir="ltr">start</span>、<span class="code" dir="ltr">stop</span>和<span class="code" dir="ltr">restart</span>。示例如下：
</p>
<a name="book_part2_chap4__chap1_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.6: 启动Postfix服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix start</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
只有那些<span class="emphasis">需要</span>给定服务的服务会被暂停或重启。而其他依赖（<span class="emphasis">使用</span>但不需要）于它的服务则不会被暂停或重启。
</p></td></tr></tbody></table>
<p>
如果你想要停止一个服务，但是不想影响依赖于它的服务，可以用<span class="code" dir="ltr">pause</span>这个参数：
</p>
<a name="book_part2_chap4__chap1_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.7: 停止Postfix服务但又保持相关依赖着的服务继续运行</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix pause</span>
</pre></td></tr>
</tbody></table>
<p>
如果你要查看一个服务的运行状态（如：启动、停止、暂停……），你可以使用参数<span class="code" dir="ltr">status</span>：
</p>
<a name="book_part2_chap4__chap1_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.8: 查看postfix服务的运行状态</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix status</span>
</pre></td></tr>
</tbody></table>
<p>
如果状态信息告诉你服务正在运行，但是你知道它实际上没有运行，这种情况下你可以使用参数<span class="code" dir="ltr">zap</span>将状态信息重设为“停止”：
</p>
<a name="book_part2_chap4__chap1_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.9: 重设postfix的状态信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix zap</span>
</pre></td></tr>
</tbody></table>
<p>
有些时候我们也需要知道某个服务的依赖性，这时可以使用参数<span class="code" dir="ltr">iuse</span>或者<span class="code" dir="ltr">ineed</span>。使用<span class="code" dir="ltr">ineed</span>你可以查看这个服务正常工作真正必要的服务，而另一个方面<span class="code" dir="ltr">iuse</span>将会显示这个服务可能使用到的所有服务，但这并不一定是正常工作所必需的。
</p>
<a name="book_part2_chap4__chap1_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.10: 列出Postfix服务所依赖的所有必要服务列表</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix ineed</span>
</pre></td></tr>
</tbody></table>
<p>
同样的，我们也可以知道哪些服务需要这个服务（<span class="code" dir="ltr">needsme</span>）或者哪些服务可以使用这个服务（<span class="code" dir="ltr">usesme</span>）：
</p>
<a name="book_part2_chap4__chap1_pre11"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.11: 列出哪些服务需要Postfix服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix needsme</span>
</pre></td></tr>
</tbody></table>
<p>
最后，我们还可以知道这个服务需要但又缺少的依赖关系：
</p>
<a name="book_part2_chap4__chap1_pre12"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.12: 列出Postfix所缺少的依赖关系</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/postfix broken</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap4__chap2"></a><span class="chapnum">4.b. </span>使用rc-update</p>
<p class="secthead"><a name="book_part2_chap4__chap2_sect1">什么是rc-update？</a></p>
<p>
Gentoo的初始化系统使用依赖关系树（dependency-tree）来决定什么服务会首先被启动。因为这是个很乏味的工作，我们不想让我们的用户去手动来完成它，所以我们创建了简化运行级别和初始化脚本的管理工具（<span class="emphasis">rc-update</span>）。
</p>
<p>
使用<span class="code" dir="ltr">rc-update</span>你可以从一个运行级别中添加或删除初始化脚本。<span class="code" dir="ltr">rc-update</span>工具会自动调用<span class="path" dir="ltr">/sbin/depscan.sh</span>脚本来重新创建依赖关系树。
</p>
<p class="secthead"><a name="book_part2_chap4__chap2_sect2">添加和删除服务</a></p>
<p>
在Gentoo的安装过程中你已经添加初始化脚本到“default”运行级别。那时你可能还不清楚“default”是干什么的，但是现在你应该知道了。<span class="code" dir="ltr">rc-update</span>脚本需要由第二个参数来决定其行为：<span class="emphasis">add</span>、<span class="emphasis">del</span>或者是<span class="emphasis">show</span>。
</p>
<p>
要添加或删除一个初始化脚本，只需要给<span class="code" dir="ltr">rc-update</span> <span class="emphasis">add</span>或者<span class="emphasis">del</span>参数，并随后跟上初始化脚本和运行级别。如下：
</p>
<a name="book_part2_chap4__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 从default级别中删除Postfix服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rc-update del postfix default</span>
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">rc-update -v show</span>命令将会显示出所有已存在的初始化脚本，并列出它们在哪个运行级别中运行：
</p>
<a name="book_part2_chap4__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 获得初始化脚本的信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rc-update -v show</span>
</pre></td></tr>
</tbody></table>
<p>
你也可以运行<span class="code" dir="ltr">rc-update show</span>（没有<span class="code" dir="ltr">-v</span>参数）来只查看已经启用的初始化脚本和他们的运行级别。
</p>
<p class="chaphead"><a name="book_part2_chap4__chap3"></a><span class="chapnum">4.c. </span>配置服务</p>
<p class="secthead"><a name="book_part2_chap4__chap3_sect1">我们为什么需要额外的配置？</a></p>
<p>
初始化脚本有时候是很复杂的。因此我们不想让用户自己直接编辑初始化脚本，这样将更容易出错。然而能够配置这样的一个服务也挺重要。比如：你可能想给某个服务本身添加更多的选项。
</p>
<p>
把配置信息独立于脚本之外存放的另一个原因是，你不用担心升级初始化脚本会覆盖掉你之前所做的改动。
</p>
<p class="secthead"><a name="book_part2_chap4__chap3_sect2">/etc/conf.d目录</a></p>
<p>
Gentoo提供了一个简单的方法来配置这样的一个服务：每一个可以配置的初始化脚本在<span class="path" dir="ltr">/etc/conf.d</span>里有一个文件。比如：apache2的初始化脚本（叫做<span class="path" dir="ltr">/etc/init.d/apache2</span>）有一个配置文件叫<span class="path" dir="ltr">/etc/conf.d/apache2</span>，它包含了Apache 2服务器启动时你要给它的选项：
</p>
<a name="book_part2_chap4__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 在/etc/conf.d/apache2中定义的变量</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>APACHE2_OPTS="-D PHP5"
</pre></td></tr>
</tbody></table>
<p>
这样的一个配置文件包含了变量，且只含有变量（就如同<span class="path" dir="ltr">/etc/make.conf</span>一样），可以使得配置服务非常简便。它还允许我们提供更多有关这个变量的信息（以注释形式）。
</p>
<p class="chaphead"><a name="book_part2_chap4__chap4"></a><span class="chapnum">4.d. </span>撰写初始化脚本</p>
<p class="secthead"><a name="book_part2_chap4__chap4_sect1">需要这样吗？</a></p>
<p>
当然不是，自己写一个初始化脚本通常情况下不是必需的，因为Gentoo给已提供的服务准备了一个立刻就能使用的初始化脚本。但是，你可能没有通过Portage来安装一个服务，在这种情况下你通常将需要创建一个初始化脚本。
</p>
<p>
如果服务软件提供者提供的初始化脚本不是明确地专为Gentoo而写的，请不要使用它，因为Gentoo的初始化脚本和其他发行版的初始化脚本是不兼容的！

</p>
<p class="secthead"><a name="book_part2_chap4__chap4_sect2">布局</a></p>
<p>
一个初始化脚本的基本布局如下所示:
</p>
<a name="book_part2_chap4__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 初始化脚本的基本布局</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>#!/sbin/runscript

depend() {
  <span class="code-comment">（依赖关系信息）</span>
}

start() {
  <span class="code-comment">（启动服务所必需的命令）</span>
}

stop() {
  <span class="code-comment">（停止服务所必需的命令）</span>
}

restart() {
  <span class="code-comment">（重启服务所必需的命令）</span>
}
</pre></td></tr>
</tbody></table>
<p>
所有的初始化脚本都<span class="emphasis">需要</span>定义函数<span class="code" dir="ltr">start()</span>函数。其他所有的部分都是可选的。
</p>
<p class="secthead"><a name="book_part2_chap4__chap4_sect3">依赖关系</a></p>
<p>
在这里我们可以定义两种依赖关系：<span class="code" dir="ltr">use</span>和<span class="code" dir="ltr">need</span>。我们之前提到过，依赖关系中<span class="code" dir="ltr">need</span>比<span class="code" dir="ltr">use</span>要更加严格。紧跟着依赖关系类型之后你需要输入你所依赖的服务，或者<span class="emphasis">虚拟</span>依赖关系。
</p>
<p>
一个<span class="emphasis">虚拟</span>依赖关系是由一个服务提供的，但它不仅仅只有那个服务提供。我们自己定制的初始化脚本可以依赖于一个系统日志服务，但是可能我们有很多可用的系统日志程序（如：metalogd、syslog-ng、sysklogd……）。你不可能同时<span class="code" dir="ltr">需要</span>所有的系统日志程序（因为没有一个系统会同时安装和运行所有的系统日志程序），我们确保所有的这些服务都<span class="code" dir="ltr">提供</span>了一个虚拟依赖关系。
</p>
<p>
让我们来看看postfix服务的依赖关系信息：
</p>
<a name="book_part2_chap4__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: Postfix的依赖关系信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>depend() {
  need net
  use logger dns
  provide mta
}
</pre></td></tr>
</tbody></table>
<p>
就像你看到的，postfix服务信息如下：
</p>
<ul>
  <li>
    需要（虚拟）依赖关系<span class="code" dir="ltr">net</span>（比如可由<span class="path" dir="ltr">/etc/init.d/net.eth0</span>提供）
  </li>
  <li>
    使用到的（虚拟）依赖关系<span class="code" dir="ltr">logger</span>（比如可由<span class="path" dir="ltr">/etc/init.d/syslog-ng</span>提供）
  </li>
  <li>
    使用到的（虚拟）依赖关系<span class="code" dir="ltr">dns</span>（比如可由<span class="path" dir="ltr">/etc/init.d/named</span>提供）
  </li>
  <li>
    提供（虚拟）依赖关系<span class="code" dir="ltr">mta</span>（所有的mail服务器一样）
  </li>
</ul>
<p class="secthead"><a name="book_part2_chap4__chap4_sect4">控制执行顺序</a></p>
<p>
在一些情况下你可能并不需要某一个服务，但是，你可能需要这个服务在系统中其他某<span class="emphasis">可能</span>存在的服务<span class="code" dir="ltr">之前</span>（或<span class="code" dir="ltr">之后</span>）启动（注意这个条件——这不再是依赖关系了）<span class="emphasis">以及</span>运行在同一个运行级别（注意这个条件——只牵扯到同一运行级别的服务）。你可以使用<span class="code" dir="ltr">before</span>或者<span class="code" dir="ltr">after</span>设置用来提供这个信息。
</p>
<p>
下面我们来看一下Portmap服务的配置情况：
</p>
<a name="book_part2_chap4__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: Portmap服务的depend()函数</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>depend() {
  need net
  before inetd
  before xinetd
}
</pre></td></tr>
</tbody></table>
<p>
你也可以使用“*”来代替相同运行级别的所有服务，虽然这种做法不是很明智。
</p>
<a name="book_part2_chap4__chap4_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.4: 让初始化脚本在它所属的运行级别中第一个运行</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>depend() {
  before *
}
</pre></td></tr>
</tbody></table>
<p>
如果你的服务需要写入本地磁盘，则需要<span class="code" dir="ltr">localmount</span>服务。如果它在<span class="path" dir="ltr">/var/run</span>目录下放置文件，例如一个pid文件（pidfile），那么我们需要它在<span class="code" dir="ltr">bootmisc</span>之后运行。示例如下：
</p>
<a name="book_part2_chap4__chap4_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.5: depend()函数示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>depend() {
  need localmount
  after bootmisc
}
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap4__chap4_sect5">标准函数</a></p>
<p>
紧随函数<span class="code" dir="ltr">depend()</span>，你还需要定义函数<span class="code" dir="ltr">start()</span>。它包含了初始化该服务所需要的所有命令。我们推荐使用函数<span class="code" dir="ltr">ebegin</span>和<span class="code" dir="ltr">eend</span>函数来通知用户要发生的事情：
</p>
<a name="book_part2_chap4__chap4_pre6"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.6: start()函数示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>start() {
  ebegin "Starting my_service"
  start-stop-daemon --start --exec /path/to/my_service \
    --pidfile /path/to/my_pidfile
  eend $?
}
</pre></td></tr>
</tbody></table>
<p>
<span class="code" dir="ltr">--exec</span>和<span class="code" dir="ltr">--pidfile</span>都应该用在start和stop函数中。如果这个服务并没有创建一个pidfile，那么如果可能的话就用<span class="code" dir="ltr">--make-pidfile</span>创建一个，不过你应该进行必要的测试以确保可行。否则，就不要使用pid文件（pidfile）。你也可以添加<span class="code" dir="ltr">--quiet</span>选项到<span class="code" dir="ltr">start-stop-daemon</span>中，但是通常我们不建议使用它，除非这个服务输出的信息极端冗长。使用<span class="code" dir="ltr">--quiet</span>选项的服务如果启动失败，那么可能会给调试带来困难。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
我们要确保<span class="code" dir="ltr">--exec</span>选项实际上调用的是一个服务，而不仅仅是一个启动和退出服务的shell脚本——那是初始化脚本应该做的事。
</p></td></tr></tbody></table>
<p>
如果你需要更多的<span class="code" dir="ltr">start()</span>函数示例，可以阅读<span class="path" dir="ltr">/etc/init.d</span>目录下的初始化脚本源代码。
</p>
<p>
你还可以定义其他的函数：<span class="code" dir="ltr">stop()</span>和<span class="code" dir="ltr">restart()</span>。但你不是一定要定义这些函数，因为如果我们使用<span class="code" dir="ltr">start-stop-daemon</span>时我们的初始化系统可以足够智能地填充这些函数。
</p>
<p>
虽然你不<span class="emphasis">必</span>创建一个<span class="code" dir="ltr">stop</span>函数，但下面还是给出了示例：
</p>
<a name="book_part2_chap4__chap4_pre7"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.7: stop()函数示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>stop() {
  ebegin "Stopping my_service"
  start-stop-daemon --stop --exec /path/to/my_service \
    --pidfile /path/to/my_pidfile
  eend $?
}
</pre></td></tr>
</tbody></table>
<p>
如果你的服务运行了一些其他语言的脚本（例如：bash、python、或者是perl），并且这个脚本之后改了名字（例如：<span class="code" dir="ltr">foo.py</span>改为<span class="code" dir="ltr">foo</span>），那么你需要给<span class="code" dir="ltr">start-stop-daemon</span>添加<span class="code" dir="ltr">--name</span>选项。同时，你必须要明确说明改过的名字。在这个例子中，一个服务启动了<span class="code" dir="ltr">foo.py</span>脚本，之后该脚本改名为<span class="code" dir="ltr">foo</span>：
</p>
<a name="book_part2_chap4__chap4_pre8"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.8: 一个启动foo脚本的服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>start() {
  ebegin "Starting my_script"
  start-stop-daemon --start --exec /path/to/my_script \
    --pidfile /path/to/my_pidfile --name foo
  eend $?
}
</pre></td></tr>
</tbody></table>
<p>
关于<span class="code" dir="ltr">start-stop-daemon</span>更多的信息你可以从man手册中得到：
</p>
<a name="book_part2_chap4__chap4_pre9"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.9: 获得start-stop-daemon的man帮助</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">$ man start-stop-daemon</span>
</pre></td></tr>
</tbody></table>
<p>
Gentoo初始化脚本的语法是基于Bourne Again Shell(bash)的，所以你可以自由地在你的初始化脚本中使用bash兼容的结构。
</p>
<p class="secthead"><a name="book_part2_chap4__chap4_sect6">添加自定义选项</a></p>
<p>
如果你想要初始化脚本支持比我们当前所看到的更多的选项，你可以添加选项名称到<span class="code" dir="ltr">opts</span>变量中，然后创建一个与选项同名的函数。示例：支持一个名为<span class="code" dir="ltr">restartdelay</span>的选项：
</p>
<a name="book_part2_chap4__chap4_pre10"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.10: 支持restartdelay选项</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>opts="${opts} restartdelay"

restartdelay() {
  stop
  sleep 3    <span class="code-comment">#在再次启动前等待3秒钟</span>
  start
}
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part2_chap4__chap4_sect7">服务配置变量</a></p>
<p>
要支持<span class="path" dir="ltr">/etc/conf.d</span>里的配置文件，你不需要作任何操作：当你的初始化脚本执行的时候，下面的文件将会被自动source（也就是说可以使用里面的变量）：
</p>
<ul>
  <li><span class="path" dir="ltr">/etc/conf.d/&lt;你的初始化脚本&gt;</span></li>
  <li><span class="path" dir="ltr">/etc/conf.d/basic</span></li>
  <li><span class="path" dir="ltr">/etc/rc.conf</span></li>
</ul>
<p>
而且，如果你的初始化脚本提供了一个虚拟依赖关系（如：<span class="code" dir="ltr">net</span>），那么和这个依赖关系相关的文件（如：<span class="path" dir="ltr">/etc/conf.d/net</span>）也会被source。
</p>
<p class="chaphead"><a name="book_part2_chap4__chap5"></a><span class="chapnum">4.e. </span>改变运行级别的行为</p>
<p class="secthead"><a name="book_part2_chap4__chap5_sect1">谁可能从此获益？</a></p>
<p>
许多笔记本用户会遇到这样的情形：在家时你需要启动<span class="code" dir="ltr">net.eth0</span>，而在路上你就不需要启动<span class="code" dir="ltr">net.eth0</span>（因为没有网络可用）。使用Gentoo，你可以根据你的意愿来改变运行级别的行为。
</p>
<p>
例如：你可以创建另一个可以启动的“default”运行级别，并分配其他的一些初始化脚本给它。然后你可以在启动时选择你想要运行哪个“default”运行级别。
</p>
<p class="secthead"><a name="book_part2_chap4__chap5_sect2">使用softlevel</a></p>
<p>
首先，给你的另一个“default”运行级别创建一个运行级别目录。作为一个例子我们创建<span class="path" dir="ltr">offline</span>运行级别：
</p>
<a name="book_part2_chap4__chap5_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.1: 创建一个运行级别目录</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mkdir /etc/runlevels/offline</span>
</pre></td></tr>
</tbody></table>
<p>
下面我们添加必要的初始化脚本到新创建的运行级别中。示例：如果你需要一个与你当前的<span class="code" dir="ltr">default</span>运行级别一模一样的副本，但不包括<span class="code" dir="ltr">net.eth0</span>：
</p>
<a name="book_part2_chap4__chap5_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.2: 添加必要的初始化脚本</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（复制所有在default运行级别中的服务到offline运行级别中）</span>
# <span class="code-input">cd /etc/runlevels/default</span>
# <span class="code-input">for service in *; do rc-update add $service offline; done</span>
<span class="code-comment">（删除在offline运行级别中不需要的服务）</span>
# <span class="code-input">rc-update del net.eth0 offline</span>
<span class="code-comment">（显示在offline运行级别中活动的服务）</span>
# <span class="code-input">rc-update show offline</span>
<span class="code-comment">（部分输出示例）</span>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |
</pre></td></tr>
</tbody></table>
<p>
虽然<span class="code" dir="ltr">net.eth0</span>已经从offline运行级别中被移除了，<span class="code" dir="ltr">udev</span>仍然尝试启动任何它检测到的设备并启动对应的服务。因此，你将需要把每一个你不想启动的网络服务（还有其他任何udev可能启动的设备的服务）加入<span class="path" dir="ltr">/etc/conf.d/rc</span>，如下所示。
</p>
<a name="book_part2_chap4__chap5_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.3: 在/etc/conf.d/rc里禁用设备启动的服务</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>RC_COLDPLUG="yes"
<span class="code-comment">（下面指定你不想自动启动的服务名称）</span>
RC_PLUG_SERVICES="!net.eth0"
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
欲知更多有关设备启动的服务的信息，请看<span class="path" dir="ltr">/etc/conf.d/rc</span>文件中的注释。
</p></td></tr></tbody></table>
<p>
现在可以编辑你的引导程序的配置文件并且添加一个<span class="code" dir="ltr">offline</span>运行级别的条目。示例：在<span class="path" dir="ltr">/boot/grub/grub.conf</span>中：
</p>
<a name="book_part2_chap4__chap5_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.4: 增加一个offline运行级别的条目</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>title Gentoo Linux Offline Usage
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <span class="code-input">softlevel=offline</span>
</pre></td></tr>
</tbody></table>
<p>
至此，所有的设置都好了。如果你启动你的系统并在启动时选择新添的条目，将会使用运行级别<span class="code" dir="ltr">offline</span>而不是<span class="code" dir="ltr">default</span>。
</p>
<p class="secthead"><a name="book_part2_chap4__chap5_sect3">使用bootlevel</a></p>
<p>
使用<span class="code" dir="ltr">bootlevel</span>完全类似于<span class="code" dir="ltr">softlevel</span>。仅仅不同的是在这里你要定义另一个“boot”运行级别而不是另一个的“default”运行级别。
</p>
<a name="book_part2_chap5"></a><h3>5. 环境变量
</h3>
<p class="chaphead"><a name="book_part2_chap5__chap1"></a><span class="chapnum">5.a. </span>环境变量？</p>
<p class="secthead"><a name="book_part2_chap5__chap1_sect1">什么是环境变量</a></p>
<p>
环境变量是一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。许多用户（特别是那些刚接触Linux的新手）发现这些变量有些怪异或者难以控制。其实，这是个误会：通过使用环境变量，你可以很容易的修改一个牵涉到一个或多个应用程序的配置信息。
</p>
<p class="secthead"><a name="book_part2_chap5__chap1_sect2">重要的例子</a></p>
<p>
下表罗列了一些Linux系统使用的变量并说明了它们的用处。在表格后面将列举一些变量例值。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>变量</b></th>
  <th class="infohead" style="text-align: left;"><b>说明</b></th>
</tr>
<tr>
  <td class="tableinfo">PATH</td>
  <td class="tableinfo">
    这个变量包含了一系列由冒号分隔开的目录，系统就从这些目录里寻找可执行文件。如果你输入的可执行文件（例如<span class="code" dir="ltr">ls</span>、<span class="code" dir="ltr">rc-update</span>或者<span class="code" dir="ltr">emerge</span>）不在这些目录中，系统就无法执行它（除非你输入这个命令的完整路径，如<span class="code" dir="ltr">/bin/ls</span>）。
  </td>
</tr>
<tr>
  <td class="tableinfo">ROOTPATH</td>
  <td class="tableinfo">
    这个变量的功能和<span class="code" dir="ltr">PATH</span>相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。
  </td>
</tr>
<tr>
  <td class="tableinfo">LDPATH</td>
  <td class="tableinfo">
    这个变量包含了一系列用冒号隔开的目录，动态链接器将在这些目录里查找库文件。
  </td>
</tr>
<tr>
  <td class="tableinfo">MANPATH</td>
  <td class="tableinfo">
    这个变量包含了一系列用冒号隔开的目录，命令<span class="code" dir="ltr">man</span>会在这些目录里搜索man页面。
  </td>
</tr>
<tr>
  <td class="tableinfo">INFODIR</td>
  <td class="tableinfo">
    这个变量包含了一系列用冒号隔开的目录，命令<span class="code" dir="ltr">info</span>将在这些目录里搜索info页面。
  </td>
</tr>
<tr>
  <td class="tableinfo">PAGER</td>
  <td class="tableinfo">
    这个变量包含了浏览文件内容的程序的路径（例如<span class="code" dir="ltr">less</span>或者<span class="code" dir="ltr">more</span>）。
  </td>
</tr>
<tr>
  <td class="tableinfo">EDITOR</td>
  <td class="tableinfo">
    这个变量包含了修改文件内容的程序（文件编辑器）的路径（比如<span class="code" dir="ltr">nano</span>或者<span class="code" dir="ltr">vi</span>）。
  </td>
</tr>
<tr>
  <td class="tableinfo">KDEDIRS</td>
  <td class="tableinfo">
    这个变量包含了一系列用冒号隔开的目录，里面放的是KDE相关的资料。
  </td>
</tr>
<tr>
  <td class="tableinfo">CONFIG_PROTECT</td>
  <td class="tableinfo">
    这个变量包含了一系列用<span class="emphasis">空格</span>隔开的目录，它们在更新的时候会被Portage保护起来。
  </td>
</tr>
<tr>
  <td class="tableinfo">CONFIG_PROTECT_MASK</td>
  <td class="tableinfo">
    这个变量包含了一系列用<span class="emphasis">空格</span>隔开的目录，它们在更新的时候不会被Portage保护起来。
  </td>
</tr>
</tbody></table>
<p>
下面你可以找到所有这些变量定义的范例：
</p>
<a name="book_part2_chap5__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 定义范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>PATH="/bin:/usr/bin:/usr/local/bin:/opt/bin:/usr/games/bin"
ROOTPATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"
LDPATH="/lib:/usr/lib:/usr/local/lib:/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"
MANPATH="/usr/share/man:/usr/local/share/man"
INFODIR="/usr/share/info:/usr/local/share/info"
PAGER="/usr/bin/less"
EDITOR="/usr/bin/vim"
KDEDIRS="/usr"
CONFIG_PROTECT="/usr/X11R6/lib/X11/xkb /opt/tomcat/conf \
                /usr/kde/3.1/share/config /usr/share/texmf/tex/generic/config/ \
                /usr/share/texmf/tex/platex/config/ /usr/share/config"
CONFIG_PROTECT_MASK="/etc/gconf"
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part2_chap5__chap2"></a><span class="chapnum">5.b. </span>全局变量的定义</p>
<p class="secthead"><a name="book_part2_chap5__chap2_sect1">/etc/env.d目录</a></p>
<p>
Gentoo采用了<span class="path" dir="ltr">/etc/env.d</span>目录来集中定义全局变量。在这个目录里，你会发现很多类似<span class="path" dir="ltr">00basic</span>、<span class="path" dir="ltr">05gcc</span>等等这样的文件，它们包含了文件名中提到的应用程序需要的变量。
</p>
<p>
举个例子，当你安装<span class="code" dir="ltr">gcc</span>时，一个名为<span class="path" dir="ltr">05gcc</span>的文件就会被ebuild所创建，里面包含了如下一些变量：
</p>
<a name="book_part2_chap5__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: /etc/env.d/05gcc</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>PATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"
ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"
MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/man"
INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/info"
CC="gcc"
CXX="g++"
LDPATH="/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"
</pre></td></tr>
</tbody></table>
<p>
其他的发行版会让你到<span class="path" dir="ltr">/etc/profile</span>或者其他地方修改和添加这些变量的定义。而Gentoo为用户（还有为Portage）提供了更加便捷的方式来维护和管理环境变量，以后你不再需要把精力放在那些众多的包含环境变量的文件身上了。
</p>
<p>
比如，当你更新完<span class="code" dir="ltr">gcc</span>的时候，<span class="path" dir="ltr">/etc/env.d/05gcc</span>也会被同时更新，而不需要你手工来完成。
</p>
<p>
这不仅对Portage有益，作为用户，你也是受益者。有时候你需要设置某个系统范围的环境变量。我们拿<span class="code" dir="ltr">http_proxy</span>变量来做例子，为了避免把<span class="path" dir="ltr">/etc/profile</span>搞乱，你只要新建一个文件（<span class="path" dir="ltr">/etc/env.d/99local</span>）然后添加你的定义：
</p>
<a name="book_part2_chap5__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: /etc/env.d/99local</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>http_proxy="proxy.server.com:8080"
</pre></td></tr>
</tbody></table>
<p>
通过使用同一个文件来定义你所有的变量，你对如何定义自己的变量有了个大概的了解。
</p>
<p class="secthead"><a name="book_part2_chap5__chap2_sect2">env-update脚本</a></p>
<p>
<span class="path" dir="ltr">/etc/env.d</span>中的好几个文件都定义了<span class="code" dir="ltr">PATH</span>变量。这并没有错：当你运行<span class="code" dir="ltr">env-update</span>的时候，它会在更新环境变量之前把这些定义都追加到PATH里，因此对于软件包（或者用户）来说将会很容易地设置他们自己的环境变量，而不影响到现有变量的值。
</p>
<p>
<span class="code" dir="ltr">env-update</span>脚本会根据<span class="path" dir="ltr">/etc/env.d</span>里文件的字母顺序来附加变量的值。这些文件名必须要以两位数字开头。
</p>
<a name="book_part2_chap5__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: env-update所用的更新顺序</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>         00basic        99kde-env       99local
     +-------------+----------------+-------------+
PATH="/bin:/usr/bin:/usr/kde/3.2/bin:/usr/local/bin"
</pre></td></tr>
</tbody></table>
<p>
变量并不总是被串联起来，只有下列变量才会被串联：<span class="code" dir="ltr">KDEDIRS</span>、<span class="code" dir="ltr">PATH</span>、<span class="code" dir="ltr">LDPATH</span>、<span class="code" dir="ltr">MANPATH</span>、<span class="code" dir="ltr">INFODIR</span>、<span class="code" dir="ltr">INFOPATH</span>、<span class="code" dir="ltr">ROOTPATH</span>、<span class="code" dir="ltr">CONFIG_PROTECT</span>、<span class="code" dir="ltr">CONFIG_PROTECT_MASK</span>、<span class="code" dir="ltr">PRELINK_PATH</span>以及<span class="code" dir="ltr">PRELINK_PATH_MASK</span>。对于（<span class="path" dir="ltr">/etc/env.d</span>里的文件中按照字母顺序排列后）其他所有变量，最新定义的值才会被使用到。
</p>
<p>
当你运行<span class="code" dir="ltr">env-update</span>的时候，它会在文件<span class="path" dir="ltr">/etc/profile.env</span>里（会被<span class="path" dir="ltr">/etc/profile</span>使用）创建所有的环境变量。它也会从变量<span class="code" dir="ltr">LDPATH</span>中获取信息用来建立<span class="path" dir="ltr">/etc/ld.so.conf</span>。这些完成以后，它将运行<span class="code" dir="ltr">ldconfig</span>来重建动态链接器需要的文件<span class="path" dir="ltr">/etc/ld.so.cache</span>。
</p>
<p>
如果你想在运行<span class="code" dir="ltr">env-update</span>后立即看到效果，执行下面的命令来更新你的环境。自己安装过Gentoo的用户可能已经记住了这个安装指南中提到过的命令：
</p>
<a name="book_part2_chap5__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 更新环境</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">env-update &amp;&amp; source /etc/profile</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
上面的命令只会更新你当前终端里的环境变量、<span class="emphasis">新</span>控制台以及它们的子程序。因此，假如你正在X11里工作，你要么在每一个你打开的终端里输入<span class="code" dir="ltr">source /etc/profile</span>，要么重新启动X，这样所有新的终端才能引用到新的变量。如果你使用了登录管理器，登陆成root然后输入<span class="code" dir="ltr">/etc/init.d/xdm restart</span>。如果不是这样，你需要注销然后重新登录回X这样才能产生使用新变量值的子程序。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
你在定义其他变量时不能使用shell变量。这意味着这样的定义<span class="code" dir="ltr">FOO="$BAR"</span>（此处<span class="code" dir="ltr">$BAR</span>是另外一个变量）是不允许的。
</p></td></tr></tbody></table>
<p class="chaphead"><a name="book_part2_chap5__chap3"></a><span class="chapnum">5.c. </span>本地变量的定义</p>
<p class="secthead"><a name="book_part2_chap5__chap3_sect1">特定用户</a></p>
<p>
你并不是一直都想定义全局变量。比如你想把<span class="path" dir="ltr">/home/my_user/bin</span>和当前目录（你当前所在的目录）添加到<span class="code" dir="ltr">PATH</span>变量中，但又不想让其他用户的<span class="code" dir="ltr">PATH</span>变量中也有这个。如果你想定义一个本地变量，可以使用<span class="path" dir="ltr">~/.bashrc</span>或者<span class="path" dir="ltr">~/.bash_profile</span>：
</p>
<a name="book_part2_chap5__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 在~/.bashrc中扩展PATH做为本地使用</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（冒号后面不跟任何目录就代表了当前目录）</span>
PATH="${PATH}:/home/my_user/bin:"
</pre></td></tr>
</tbody></table>
<p>
当你重新登录的时候，你的<span class="code" dir="ltr">PATH</span>变量将被更新。
</p>
<p class="secthead"><a name="book_part2_chap5__chap3_sect2">特定会话</a></p>
<p>
有时候甚至需要更加严格的定义。你可能要使用一个你临时创建的目录里面的程序，而又不想输入它的路径或者为此短时间内内修改<span class="path" dir="ltr">~/.bashrc</span>。
</p>
<p>
在这种情况下，你只需要在当前会话中使用<span class="code" dir="ltr">export</span>来定义<span class="code" dir="ltr">PATH</span>变量。只要你不注销，<span class="code" dir="ltr">PATH</span>变量将保持这个临时的设置。
</p>
<a name="book_part2_chap5__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 定义特定会话中的环境变量</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">export PATH="${PATH}:/home/my_user/tmp/usr/bin"</span>
</pre></td></tr>
</tbody></table>
<a name="book_part3"></a><h2>C. 使用Portage</h2>
<a name="book_part3_chap1"></a><h3>1. 文件和目录</h3>
<p class="chaphead"><a name="book_part3_chap1__chap1"></a><span class="chapnum">1.a. </span>Portage文件</p>
<p class="secthead"><a name="book_part3_chap1__chap1_sect1">配置指南</a></p>
<p>
Portage附带了一个默认的配置文件<span class="path" dir="ltr">/etc/make.globals</span>。当你打开它时，你就会发现所有的Portage配置选项都是通过变量来控制的。Portage读取的是什么变量，这些变量分别又是什么意思，下面将详细解释。
</p>
<p>
因为许多配置命令在不同的架构下是不同的，Portage也有相应的各组默认配置文件，它们是你的profile的一部分。你的profile是<span class="path" dir="ltr">/etc/make.profile</span>这个链接文件指向的目录；Portage的配置选项是在你的profile以及所有被继承的profile中的<span class="path" dir="ltr">make.defaults</span>文件中设定的。我们稍后将详细解释profile及<span class="path" dir="ltr">/etc/make.profile</span>目录。
</p>
<p>
如果打算改变配置变量，<span class="emphasis">不要</span>变更<span class="path" dir="ltr">/etc/make.globals</span>或是<span class="path" dir="ltr">make.defaults</span>。而应该修改<span class="path" dir="ltr">/etc/make.conf</span>，它比前面的几个文件有更高的优先级。你也会发现有一个<span class="path" dir="ltr">/etc/make.conf.example</span>。顾名思义，它是一个范例文件而已——Portage并不读取这个文件。
</p>
<p>
你也可以将一个Portage的配置变量定义为环境变量，但我们并不推荐这样做。
</p>
<p class="secthead"><a name="book_part3_chap1__chap1_sect2">Profile特定的信息</a></p>
<p>
我们已经见到过<span class="path" dir="ltr">/etc/make.profile</span>目录了。不过，这并不是一个真正的目录，而是一个指向profile的符号链接，默认情况下是一个位于<span class="path" dir="ltr">/usr/portage/profiles</span>里的目录，虽然你也可以在其他地方创建自己的profile并指向他们。这个符号链接指向的profile就是你的系统所使用的。
</p>
<p>
一个profile包含了Portage需要的与架构相关的信息，比如该profile对应的system包含的软件包的列表，以及对这个profile来说不能运行的（或者被屏蔽掉）的软件列表，等等。
</p>
<p class="secthead"><a name="book_part3_chap1__chap1_sect3">用户特定的配置</a></p>
<p>
当你需要变更Portage安装软件的行为时，你需要做的就是编辑<span class="path" dir="ltr">/etc/portage</span> 中的文件。我们<span class="emphasis">强烈建议</span>你使用<span class="path" dir="ltr">/etc/portage</span>中的文件而<span class="emphasis">不是</span>通过修改环境变量来变更这些行为！
</p>
<p>
在<span class="path" dir="ltr">/etc/portage</span>目录中，你可以创建下列文档：
</p>
<ul>
  <li>
    <span class="path" dir="ltr">package.mask</span>它列出了你永远不希望Portage安装的软件包。
  </li>
  <li>
    <span class="path" dir="ltr">package.unmask</span>它列出了本来Gentoo的开发者不建议安装的，但是你希望能安装的软件包。
  </li>
  <li>
    <span class="path" dir="ltr">package.keywords</span>它列出了还未被确认适合你的系统或架构，但是你希望能安装的软件包。
  </li>
  <li>
    <span class="path" dir="ltr">package.use</span>它列出了你希望某些特定软件包使用的而不是整个系统使用的USE标记。
  </li>
</ul>
<p>
这些并不需要一定是文件；它们也可以是有包含单个软件包信息文件的目录。更多关于<span class="path" dir="ltr">/etc/portage</span>目录的信息及你能创建的文件的完整列表可以在Portage的手册页中找到：
</p>
<a name="book_part3_chap1__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 阅读Portage的手册页</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man portage</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part3_chap1__chap1_sect4">改变Portage文件和目录的位置</a></p>
<p>
先前提到的配置文件不能保存在其他地方——Portage总是会在这些特定的位置搜索配置文件。不过Portage还用了许多其他的位置来满足不同的目的：编译、保存源代码、保存portage树。
</p>
<p>
所有的这些目的都有众所周知的默认位置，不过你可以根据你自己的喜好通过<span class="path" dir="ltr">/etc/make.conf</span>来改变它们。本章中的其他部分将解释Portage使用哪些特定的位置存放它们以及怎样改变它们在你的文件系统中的存放地点。
</p>
<p>
这篇文档并不是一份全面的参考。如果你需要100%范围的说明，请参看Portage和<span class="path" dir="ltr">make.conf</span>的手册页:
</p>
<a name="book_part3_chap1__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 阅读Portage和make.conf的手册页</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man portage</span>
$ <span class="code-input">man make.conf</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part3_chap1__chap2"></a><span class="chapnum">1.b. </span>储存文件</p>
<p class="secthead"><a name="book_part3_chap1__chap2_sect1">Portage树</a></p>
<p>
Portage树的默认位置是<span class="path" dir="ltr">/usr/portage</span>。这是PORTDIR变量定义的。当你把Portage树保存在其他位置（通过改变这个变量），不要忘了相应地改变符号链接<span class="path" dir="ltr">/etc/make.profile</span>指向的位置。
</p>
<p>
如果你改变了PORTDIR变量，你可能也需要改变下面几个变量，因为它们不会知道PORTDIR变量的改变。这是Portage处理这些变量的方式导致的：PKGDIR、DISTDIR、RPMDIR。
</p>
<p class="secthead"><a name="book_part3_chap1__chap2_sect2">预编译二进制包</a></p>
<p>
虽然Portage并不默认使用预编译的二进制包，但却对其有多方面的支持。当你要求Portage使用预编译的二进制包时，它就会在<span class="path" dir="ltr">/usr/portage/packages</span>中寻找它们。这个位置是通过PKGDIR变量定义的。
</p>
<p class="secthead"><a name="book_part3_chap1__chap2_sect3">源代码</a></p>
<p>
程序的源代码默认保存于<span class="path" dir="ltr">/usr/portage/distfiles</span>。这个位置是通过DISTDIR变量定义的。
</p>
<p class="secthead"><a name="book_part3_chap1__chap2_sect4">Portage数据库</a></p>
<p>
Portage将你系统的状态（装了哪些软件包，什么文件属于哪个软件包……）保存在<span class="path" dir="ltr">/var/db/pkg</span>。<span class="emphasis">不要</span>手动改变这些文件！它可能破坏Portage对你系统的了解。
</p>
<p class="secthead"><a name="book_part3_chap1__chap2_sect5">Portage缓存</a></p>
<p>
Portage缓存（包括修改时间、虚拟包、依赖关系树信息……）储存在<span class="path" dir="ltr">/var/cache/edb</span>。这个位置就是一个缓存：如果你没有正在运行portage相关的程序，你就可以清空它。
</p>
<p class="chaphead"><a name="book_part3_chap1__chap3"></a><span class="chapnum">1.c. </span>编译软件</p>
<p class="secthead"><a name="book_part3_chap1__chap3_sect1">Portage的临时文件</a></p>
<p>
Portage的临时文件默认保存在<span class="path" dir="ltr">/var/tmp</span>。这是通过PORTAGE_TMPDIR变量定义的。
</p>
<p>
如果你改变了PORTAGE_TMPDIR变量，你也需要改变下列的变量，因为它们不会知道PORTAGE_TMPDIR变量的改变。这是由于PORTAGE处理这些变量的方式导致的：BUILD_PREFIX。
</p>
<p class="secthead"><a name="book_part3_chap1__chap3_sect2">编译目录</a></p>
<p>
Portage为每一个它所安装的软件包在<span class="path" dir="ltr">/var/tmp/portage</span>里创建特定的编译目录。这一位置是通过BUILD_PREFIX变量定义的。
</p>
<p class="secthead"><a name="book_part3_chap1__chap3_sect3">Live文件系统位置</a></p>
<p>
默认情况下，Portage将所有的文件安装到当前文件系统（<span class="path" dir="ltr">/</span>）里。但是你可以通过改变环境变量ROOT来改变它。这在你想要创建一个新的编译镜像时是很有用的。
</p>
<p class="chaphead"><a name="book_part3_chap1__chap4"></a><span class="chapnum">1.d. </span>日志特性</p>
<p class="secthead"><a name="book_part3_chap1__chap4_sect1">Ebuild日志</a></p>
<p>Portage能为每一个ebuild建立日志文件，但只有当PORT_LOGDIR变量设定的位置是portage可写的才行。默认情况下，这个
变量没有设定。如果你没有设定PORT_LOGDIR，你就不会收到当前日志系统报告的任何编译日志，然而你可能收到一些来自新的<span class="code" dir="ltr">elog</span>机制的日志。如果你定义了PORT_LOGDIR并且你也使用elog，你就将收到编译日志以及elog保存的任何日志，就像下文解释的一样。
</p>
<p>
Portage通过<span class="code" dir="ltr">elog</span>对日志记录提供精确的控制：
</p>
<ul>
  <li>
    PORTAGE_ELOG_CLASSES：这是你设置什么信息被记入日志的地方。你可以使用任何用空格分隔的<span class="code" dir="ltr">info</span>、<span class="code" dir="ltr">warn</span>、<span class="code" dir="ltr">error</span>、<span class="code" dir="ltr">log</span>和<span class="code" dir="ltr">qa</span>的组合。
    <ul>
      <li>
<span class="code" dir="ltr">info</span>: 记录下ebuild打印的“einfo”信息</li>
      <li>
<span class="code" dir="ltr">warn</span>: 记录下ebuild打印的“ewarn”信息</li>
      <li>
<span class="code" dir="ltr">error</span>: 记录下ebuild打印的“eerror”信息</li>
      <li>
<span class="code" dir="ltr">log</span>: 记录下一些ebuild中的“elog”信息</li>
      <li>
<span class="code" dir="ltr">qa</span>: 记录下ebuild打印的“QA Notice”信息</li>
    </ul>
  </li>
  <li>
    PORTAGE_ELOG_SYSTEM：这是用来选择处理日志信息的模块的。如果留空，则日志记录就被取消。你可以使用任何用空格分隔开的<span class="code" dir="ltr">save</span>、<span class="code" dir="ltr">custom</span>、<span class="code" dir="ltr">syslog</span>、<span class="code" dir="ltr">mail</span>、<span class="code" dir="ltr">save_summary</span>和<span class="code" dir="ltr">mail_summary</span>的组合。你必须至少选择一个模块以使用elog。
    <ul>
      <li>
        <span class="code" dir="ltr">save</span>：表示将每一个软件包的日志保存在<span class="path" dir="ltr">$PORT_LOGDIR/elog</span>中，或者是在$PORT_LOGDIR 没有配置的情况下保存在<span class="path" dir="ltr">/var/log/portage/elog</span> 目录下面。
      </li>
      <li>
	<span class="code" dir="ltr">custom</span>：将所有的信息传递给用户在$PORTAGE_ELOG_COMMAND中定义的命令，这将在随后讨论。
      </li>
      <li>
        <span class="code" dir="ltr">syslog</span>：把所有的信息发送给已安装的系统日志软件。
      </li>
      <li>
        <span class="code" dir="ltr">mail</span>：把所有的信息传递给用户在$PORTAGE_ELOG_MAILURI中定义的邮件服务器；这将在随后讨论。这一elog的邮件特性需要&gt;=<span class="code" dir="ltr">portage-2.1.1</span>。
      </li>
      <li>
        <span class="code" dir="ltr">save_summary</span>： 和<span class="code" dir="ltr">save</span>类似，不过它把所有的信息保存在<span class="path" dir="ltr">$PORT_LOGDIR/elog/summary.log</span>里，或者<span class="path" dir="ltr">/var/log/portage/elog/summary.log</span>里，如果$PORT_LOGDIR没有定义的话。
      </li>
      <li>
        <span class="code" dir="ltr">mail_summary</span>： 和<span class="code" dir="ltr">mail</span>类似，不过它会在emerge结束时把所有的信息在一个邮件里发送出去。
      </li>
    </ul>
  </li>
  <li>
    PORTAGE_ELOG_COMMAND：这个仅仅在<span class="code" dir="ltr">custom</span>模块被激活时使用。在这里你指定一个命令来处理日志信息。注意，你可以利用两个变量：${PACKAGE}是软件包的名字和版本，而${LOGFILE}是日志文件的绝对路径。这里是一个可能的用法：
    <ul>
      <li>
        PORTAGE_ELOG_COMMAND="/path/to/logger -p '\${PACKAGE}' -f '\${LOGFILE}'"
      </li>
    </ul>
  </li>
  <li>
    PORTAGE_ELOG_MAILURI：这包含了<span class="code" dir="ltr">mail</span>模块的设定，如地址、用户、密码、邮件服务器、端口。默认配置是 “root@localhost localhost”。
  </li>
  <li>
    这里是一个使用smtp服务器的例子，基于用户名和密码认证并使用特定端口(默认端口是25)：
    <ul>
      <li>
        PORTAGE_ELOG_MAILURI="user@some.domain username:password@smtp.some.domain:995"
      </li>
    </ul>
  </li>
  <li>
    PORTAGE_ELOG_MAILFROM：允许你配置日志邮件的“from”地址；如果没有配置的话，默认是“portage”。
  </li>
  <li>
    PORTAGE_ELOG_MAILSUBJECT：允许你为日志邮件生成一个主题行。注意你可以使用两个变量：${PACKAGE}将会显示软件包的名子和版本，而${HOST}则是运行Portage的主机的FQDN。
  </li>
  <li>
    这里是一个可能的应用：
    <ul>
      <li>
	PORTAGE_ELOG_MAILSUBJECT="package \${PACKAGE} was merged on \${HOST} with some messages"
      </li>
    </ul>
  </li>
</ul>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
如果你使用Portage-2.0.*中的<span class="code" dir="ltr">enotice</span>，你必须完全移除enotice，因为它和elog不兼容。
</p></td></tr></tbody></table>
<a name="book_part3_chap2"></a><h3>2. 通过变量来配置</h3>
<p class="chaphead"><a name="book_part3_chap2__chap1"></a><span class="chapnum">2.a. </span>Portage的配置</p>
<p>
如前面所述，你可以在<span class="path" dir="ltr">/etc/make.conf</span>中定义许多变量来配置Portage。请参考<span class="path" dir="ltr">make.conf</span>的手册页以获得更详细和完整的信息：
</p>
<a name="book_part3_chap2__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 阅读make.conf的手册页</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man make.conf</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part3_chap2__chap2"></a><span class="chapnum">2.b. </span>构建相关的选项</p>
<p class="secthead"><a name="book_part3_chap2__chap2_sect1">配置和编译器选项</a></p>
<p>
当Portage构建应用程序时，他会将下面变量的内容传给编译器和configure脚本：
</p>
<ul>
  <li>
    CFLAGS和CXXFLAGS定义了编译器编译C和C++程序所使用的参数。
  </li>
  <li>
    CHOST为程序的configure脚本定义了build和host信息。
  </li>
  <li>
    MAKEOPTS参数被传递给<span class="code" dir="ltr">make</span>命令，通常用来设定编译时并行处理线程的数量。更多关于make的参数可在<span class="code" dir="ltr">make</span>的手册页中找到。
  </li>
</ul>
<p>
USE变量也会在配置和编译的过程中被用到，不过这在前面的章节中已经详细解释过了。
</p>
<p class="secthead"><a name="book_part3_chap2__chap2_sect2">安装相关选项</a></p>
<p>
当Portage在安装了一个某软件的新版本后，会把属于旧版本的已经过时的文件从你的系统中删除。在此之前Portage会给用户5秒钟时间撤销此操作，这5秒钟由CLEAN_DELAY变量定义。
</p>
<p>
你可以通过设定EMERGE_DEFAULT_OPTS变量以使<span class="code" dir="ltr">emerge</span>每次运行时都使用某些特定的选项。一些常用的选项是--ask，--verbose，--tree，等等。
</p>
<p class="chaphead"><a name="book_part3_chap2__chap3"></a><span class="chapnum">2.c. </span>配置文件的保护</p>
<p class="secthead"><a name="book_part3_chap2__chap3_sect1">Portage的保护位置</a></p>
<p>
Portage一般会用新文件覆盖掉旧文件，除非这些旧文件位于<span class="emphasis">受保护的</span>位置里。这些受保护的位置由CONFIG_PROTECT变量设定，通常是配置文件的位置。在设置时，多个目录间用空格分开。
</p>
<p>
当受保护的位置里的文件有新版本时，新文件被保存前将会被更名，同时用户会被告知此新配置文件的存在。
</p>
<p>
你可以利用<span class="code" dir="ltr">emerge --info</span>来获得目前CONFIG_PROTECT的设置：
</p>
<a name="book_part3_chap2__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 获得CONFIG_PROTECT的设定</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">emerge --info | grep 'CONFIG_PROTECT='</span>
</pre></td></tr>
</tbody></table>
<p>
更多关于Portage配置文件保护的信息可以查看<span class="code" dir="ltr">emerge</span>手册页的CONFIGURATION FILES部分：
</p>
<a name="book_part3_chap2__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 更多关于Portage配置文件保护的信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man emerge</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part3_chap2__chap3_sect2">解除对某些目录的保护</a></p>
<p>
你可以通过变量CONFIG_PROTECT_MASK来解除对受保护目录下某些子目录的保护。
</p>
<p class="chaphead"><a name="book_part3_chap2__chap4"></a><span class="chapnum">2.d. </span>下载的选项</p>
<p class="secthead"><a name="book_part3_chap2__chap4_sect1">服务器的地址</a></p>
<p>
当你的系统上没有所需要的信息和数据时，Portage就会从网络上获取数据。含有这些信息和数据的服务器的位置定义在以下变量中：
</p>
<ul>
  <li>
    GENTOO_MIRRORS定义了一些提供源代码（distfiles）的服务器地址。
  </li>
  <li>
    PORTAGE_BINHOST定义了一个特定的服务器地址，此服务器可为你的系统提供预先编译好的软件包。
  </li>
</ul>
<p>
第3个变量设定rsync服务器的地址，此服务器用来更新你的Portage树：
</p>
<ul>
  <li>
    SYNC定义了一个特定的服务器，Portage用此服务器获取Portage树。
  </li>
</ul>
<p>
GENTOO_MIRRORS和SYNC变量可以由程序<span class="code" dir="ltr">mirrorselect</span>自动设定。首先你要<span class="code" dir="ltr">emerge mirrorselect</span>。更多信息参考mirrorselect的在线帮助：
</p>
<a name="book_part3_chap2__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 更多关于mirrorselect的信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">mirrorselect --help</span>
</pre></td></tr>
</tbody></table>
<p>
如果你需要使用代理服务器，你可以用http_proxy、ftp_proxy和RSYNC_PROXY变量来设定它们。
</p>
<p class="secthead"><a name="book_part3_chap2__chap4_sect2">获取源代码的命令</a></p>
<p>
当Portage需要获取源代码时，默认使用<span class="code" dir="ltr">wget</span>来下载。你可以通过定义FETCHCOMMAND变量来改变它。
</p>
<p>
Portage支持断点续传。默认是使用<span class="code" dir="ltr">wget</span>来实现，但你可以通过定义RESUMECOMMAND来变量来改变它。
</p>
<p>
确保你的FETCHCOMMAND和RESUMECOMMAND把源代码存放到正确的位置。在这些变量中你应该用\${URI}和\${DISTDIR}分别指定源代码和distfiles的位置。
</p>
<p>
你可以对不同的传输协议使用不同的设置，相关的参数有FETCHCOMMAND_HTTP、FETCHCOMMAND_FTP、RESUMECOMMAND_HTTP和RESUMECOMMAND_FTP等等。
</p>
<p class="secthead"><a name="book_part3_chap2__chap4_sect3">Rsync的设置</a></p>
<p>
你不能改变Portage用来更新Portage树所使用的rsync命令,但你可以设定一些与rsync命令相关的变量：
</p>
<ul>
  <li>
    PORTAGE_RSYNC_OPTS定义了一些在sync过程中使用的变量，变量之间用空格分开。不要做任何改变除非你<span class="emphasis">十分清楚</span>会有什么后果。注意某些必要的选项总会起作用，即使PORTAGE_RSYNC_OPTS的设置是空的。
  </li>
  <li>
    PORTAGE_RSYNC_EXTRA_OPTS可以用于在同步过程中设置附加选项。选项之间用空格分开。
    <ul>
      <li>--timeout=&lt;number&gt;： 这里设定rsync连接超时的秒数。此变量默认为180秒。如果用户是使用拨号上网或者一台处理速度慢的电脑，这个值需要设到300或者更高。</li>
      <li>--exclude-from=/etc/portage/rsync_excludes： 这个参数指定一个文件，内容是rsync在更新过程中需要忽略的软件包和/或者类别的列表。这个例子指定的是<span class="path" dir="ltr">/etc/portage/rsync_excludes</span>。请参考<a href="#book_part3_chap5">使用Portage树的子集</a>以了解此文件的格式。</li>
      <li>--quiet： 减少屏幕输出</li>
      <li>--verbose： 在屏幕上输出完整的文件列表</li>
      <li>--progress： 为每个文件显示一个进度条</li>
    </ul>
  </li>
  <li>
    PORTAGE_RSYNC_RETRIES定义了rsync程序试图连接到由SYNC变量所指定的服务器的次数，默认为3。
  </li>
</ul>
<p>
更多有关这些参数的信息请阅读<span class="code" dir="ltr">man rsync</span>.
</p>
<p class="chaphead"><a name="book_part3_chap2__chap5"></a><span class="chapnum">2.e. </span>Gentoo的设置</p>
<p class="secthead"><a name="book_part3_chap2__chap5_sect1">分支的选则</a></p>
<p>
你可以用ACCEPT_KEYWORDS变量改变默认的系统分支。此变量的默认设置为你的电脑体系结构的稳定分支。更多关于Gentoo分支的信息可以在下一章节找到。
</p>
<p class="secthead"><a name="book_part3_chap2__chap5_sect2">Portage的特性</a></p>
<p>
你可以通过FEATURES变量激活Portage的某个特性。这些已在前面的章节中讨论过，如<a href="#book_part2_chap3">Portage的特性</a>.
</p>
<p class="chaphead"><a name="book_part3_chap2__chap6"></a><span class="chapnum">2.f. </span>Portage的行为</p>
<p class="secthead"><a name="book_part3_chap2__chap6_sect1">资源管理</a></p>
<p>
通过PORTAGE_NICENESS变量，你可以增加或减少Portage运行时的nice值。PORTAGE_NICENESS变量的值会被<span class="emphasis">加到</span>目前的nice值上。
</p>
<p>
更多关于nice值的信息, 请参考nice的手册页：
</p>
<a name="book_part3_chap2__chap6_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;6.1: 更多关于nice的信息</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man nice</span>
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part3_chap2__chap6_sect2">输出行为</a></p>
<p>
NOCLOR变量的默认值为“false”，如果你想禁用Portage的彩色输出，请把这个变量设为“true”。
</p>
<a name="book_part3_chap3"></a><h3>3. 使用多个软件分支</h3>
<p class="chaphead"><a name="book_part3_chap3__chap1"></a><span class="chapnum">3.a. </span>使用一个分支</p>
<p class="secthead"><a name="book_part3_chap3__chap1_sect1">稳定的分支</a></p>
<p>
Gentoo提供了一个ACCEPT_KEYWORDS变量来定义您系统所使用的软件分支。默认情况下，系统会选择您的体系结构的稳定软件分支。例如<span class="code" dir="ltr">x86</span>。
</p>
<p>
我们推荐您只使用默认的稳定软件分支。不过，如果您不是那么注重稳定性，并且愿意向<a href="http://bugs.gentoo.org/">http://bugs.gentoo.org</a>提交一些bug报告来帮助和完善Gentoo，请继续阅读下面的内容。
</p>
<p class="secthead"><a name="book_part3_chap3__chap1_sect2">测试的分支</a></p>
<p>
如果您想用最新版本的软件，您可以考虑转向使用测试分支。要让Portage转而使用测试分支的软件，您只需在您的体系结构名称前加上一个~符号。
</p>
<p>
顾名思义，“测试分支”就是带有测试性质的。如果一个包正处于测试中，这代表软件的开发人员认为它虽然已经具有了相当的功能但还没有经过完全的测试。使用这样的软件，您当然可能会第一个发现它的bug，并可以提交一个<a href="http://bugs.gentoo.org/">bug报告</a>来通知相关的开发者。
</p>
<p>
要小心的是，您可能会遇到不稳定性、不完美的软件包处理（例如错误或者缺失的依赖关系）、过于频繁的更新（导致大量的编译）和损坏的包等问题。如果您还不是很清楚Gentoo的工作方式以及如何去解决这些问题，我们推荐您还是使用稳定且测试过分支。
</p>
<p>
例如，要选择针对x86体系结构的测试分支，请修改<span class="path" dir="ltr">/etc/make.conf</span>文件并设定如下内容：
</p>
<a name="book_part3_chap3__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 设定ACCEPT_KEYWORDS变量</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>ACCEPT_KEYWORDS="~x86"
</pre></td></tr>
</tbody></table>
<p>
之后如果您更新系统，您将会发现有<span class="emphasis">大量</span>的包需要更新。要提醒您注意的是：您使用测试分支更新系统后，再想转回使用官方的稳定分支将不是一件容易的事情（当然您使用系统的备份的情况除外）。
</p>
<p class="chaphead"><a name="book_part3_chap3__chap2"></a><span class="chapnum">3.b. </span>混合使用稳定和测试分支</p>
<p class="secthead"><a name="book_part3_chap3__chap2_sect1">package.keywords文件的位置</a></p>
<p>
您可以让Portage使用某些软件的测试分支中的版本，对于系统的其他软件则使用稳定分支。要实现这样的目的，您需要在<span class="path" dir="ltr">/etc/portage/package.keywords</span>文件里加入那些软件包的名字及其所属分类的名称。您也可以建立一个同名文件夹，并在里面建立的文件里加入上述内容。例如，要使用<span class="code" dir="ltr">gnumeric</span>属于测试分支中的版本：
</p>
<a name="book_part3_chap3__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: /etc/portage/package.keywords中针对gnumeric设置，一行完整内容</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>app-office/gnumeric ~x86
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part3_chap3__chap2_sect2">测试特定版本</a></p>
<p>
如果您希望Portage使用测试分支中某软件的特定版本，但后续版本不再这么做，你可以在<span class="path" dir="ltr">package.keywords</span>里加入相应的版本号来实现这个目的。在此情况下您<span class="emphasis">必须</span>使用 = 运算符。您也可以通过使用&lt;=，&lt;，&gt;或&gt;=运算符来指定一个要使用的版本范围。
</p>
<p>
任何情况下，如果您添加了版本号，您<span class="emphasis">必须</span>使用一个运算符；如果您忽略了版本号，您就<span class="emphasis">不能</span>使用运算符。
</p>
<p>
在如下的例子中，我们要求Portage接受版本号为1.2.13的gnumeric：
</p>
<a name="book_part3_chap3__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 允许gnumeric的测试版本</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>=app-office/gnumeric-1.2.13 ~x86
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part3_chap3__chap3"></a><span class="chapnum">3.c. </span>使用被屏蔽的包</p>
<p class="secthead"><a name="book_part3_chap3__chap3_sect1">package.unmask文件的位置</a></p>
<p>
Gentoo的开发者们<b>不</b>支持您使用这个文件。如果您要使用它请千万小心。开发者们将不会回应有关于<span class="code" dir="ltr">package.unmask</span>和／或<span class="code" dir="ltr">package.mask</span>的支持请求。您已经被提醒过了。
</p>
<p>
当一个包被Gentoo的开发者们屏蔽，但你不考虑<span class="path" dir="ltr">package.mask</span>文件（默认保存于<span class="path" dir="ltr">/usr/portage/profiles</span>目录下）里所陈述的原因，仍然想使用它的话，请在<span class="path" dir="ltr">/etc/portage/package.unmask</span>文件（如果是一个文件夹，就在此文件夹下的文件中）中加入与package.mask里那行<span class="emphasis">一模一样</span>的内容。
</p>
<p>
比如说，软件包<span class="code" dir="ltr">=net-mail/hotwayd-0.8</span>被屏蔽了，但是您想解除这个屏蔽，需要做的只是在<span class="path" dir="ltr">package.unmask</span>中加入相同的一行内容就可以了。
</p>
<a name="book_part3_chap3__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: /etc/portage/package.unmask</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>=net-mail/hotwayd-0.8
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part3_chap3__chap3_sect2">package.mask文件的位置</a></p>
<p>
当您希望Portage忽略一个特定的软件包或者一个软件包的特定版本，您可以在<span class="path" dir="ltr">/etc/portage/package.mask</span>文件（或者此目录下的一个文件）中加入一行适当的内容来屏蔽它。
</p>
<p>
例如，当您不希望Portage安装比<span class="code" dir="ltr">gentoo-sources-2.6.8.1</span>更新版本的内核时，您只需要在<span class="path" dir="ltr">package.mask</span>文件里加入下面一行内容：
</p>
<a name="book_part3_chap3__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: /etc/portage/package.mask的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>&gt;sys-kernel/gentoo-sources-2.6.8.1
</pre></td></tr>
</tbody></table>
<a name="book_part3_chap4"></a><h3>4. Portage附加工具</h3>
<p class="chaphead"><a name="book_part3_chap4__chap1"></a><span class="chapnum">4.a. </span>dispatch-conf</p>
<p>
<span class="code" dir="ltr">dispatch-conf</span>是一个帮助合并<span class="path" dir="ltr">._cfg0000_&lt;名称&gt;</span>文件的工具。<span class="path" dir="ltr">._cfg0000_&lt;名称&gt;</span>文件是由Portage在它要覆盖被CONFIG_PROTECT变量所保护的某个目录里的文件时建立的。
</p>
<p>
使用<span class="code" dir="ltr">dispatch-conf</span>能够在合并配置文件并升级更新的同时保持所有更新记录。<span class="code" dir="ltr">dispatch-conf</span>以RCS版本管理系统或是补丁的方式来保存配置文件间的差别。这意味着如果你在升级配置文件犯下错误时，你可以随时退回到你的配置文件的之前版本。
</p>
<p>
使用<span class="code" dir="ltr">dispatch-conf</span>，你可以保持配置文件原来的样子，或者使用新的配置文件，你还可以编辑当前文件或交互式地合并更新。除此之外，<span class="code" dir="ltr">dispatch-conf</span>还有一些很棒的特性：
</p>
<ul>
  <li>
    可以自动合并仅有注释变更的文件；
  </li>
  <li>
    可自动合并仅有空白符数量的不同的文件；
  </li>
</ul>
<p>
确定你先编辑了<span class="path" dir="ltr">/etc/dispatch-conf.conf</span>并创建了archive-dir变量设定的目录。
</p>
<a name="book_part3_chap4__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 运行dispatch-conf</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">dispatch-conf</span>
</pre></td></tr>
</tbody></table>
<p>
当运行<span class="code" dir="ltr">dispatch-conf</span>的时候，程序会带你把每个改变了的配置文件挨个过一边。按<span class="code" dir="ltr">u</span>来用新配置文件更新（替换）现在的配置文件，然后继续处理下一个。按<span class="code" dir="ltr">z</span>来删除新配置文件，然后继续处理下一个。当处理完所有的配置文件之后，<span class="code" dir="ltr">dispatch-conf</span>就会退出。你也可以随时按<span class="code" dir="ltr">q</span>来退出。
</p>
<p>
更多信息，请查阅<span class="code" dir="ltr">dispatch-conf</span>手册页。它会告诉你交互式的合并新旧配置文件，编辑新配置文件，检查两个文件间的差异等等。
</p>
<a name="book_part3_chap4__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 阅读dispatch-conf手册页</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>$ <span class="code-input">man dispatch-conf</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part3_chap4__chap2"></a><span class="chapnum">4.b. </span>etc-update</p>
<p>
你也可以使用<span class="code" dir="ltr">etc-update</span>来合并配置文件。它不像<span class="code" dir="ltr">dispatch-conf</span>那样简单易用，功能也少，但是它也能提供交互式合并功能并且能自动合并一些简单的改变。
</p>
<p>
不过，和<span class="code" dir="ltr">dispatch-conf</span>不同的是，<span class="code" dir="ltr">etc-update</span><span class="emphasis">不</span>保留你的配置文件的旧版本。一旦你更新了文件，旧版本就永远丢失了。所以要非常小心，因为使用<span class="code" dir="ltr">etc-update</span>与使用<span class="code" dir="ltr">dispatch-conf</span>相比<span class="emphasis">明显</span>的不安全。
</p>
<a name="book_part3_chap4__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 运行etc-update</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">etc-update</span>
</pre></td></tr>
</tbody></table>
<p>
在整合简单直观的更动后，系统会提示你一个需要更新的受保护的文件列表。在最底下会提示你可选的操作选项：
</p>
<a name="book_part3_chap4__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: etc-update选项</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Please select a file to edit by entering the corresponding number.
              (-1 to exit) (-3 to auto merge all remaining files)
                           (-5 to auto-merge AND not use 'mv -i'):
</pre></td></tr>
</tbody></table>
<p>
如果你输入<span class="code" dir="ltr">-1</span>，<span class="code" dir="ltr">etc-update</span>将直接退出且不执行任何变更。如果你输入<span class="code" dir="ltr">-3</span>或<span class="code" dir="ltr">-5</span>，所有列出的配置文件将被更新的版本覆盖。因此先选出无需自动升级的配置文件非常重要，而具体步骤也很简单，只需要输入在该配置文件左边显示的数字就可以了。
</p>
<p>
我们选择配置文件<span class="path" dir="ltr">/etc/pear.conf</span>作为范例:
</p>
<a name="book_part3_chap4__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 更新指定的配置文件</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
<span class="code-comment">[...]</span>
End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
1) Replace original with update
2) Delete update, keeping original as is
3) Interactively merge original with update
4) Show differences again
</pre></td></tr>
</tbody></table>
<p>
现在你可以看到这两个文件之间的差别。如果你认为升级的配置文件可以正确无误的投入使用，输入<span class="code" dir="ltr">1</span>。如果你认为升级的配置文件是不必要的，或者它也没有提供任何新的或有用的信息，输入<span class="code" dir="ltr">2</span>。如果你想交互地升级你当前的配置文件，输入<span class="code" dir="ltr">3</span>。
</p>
<p>
这里我们就不再赘述交互性整合的详细过程。出于完整性的考虑，我们将列出在整合两个文件时可以用到的所有的命令。你将看到来自新旧文件的两行内容和一个提示符，在提示符这里你可以输入以下命令：
</p>
<a name="book_part3_chap4__chap2_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.4: 用交互方式配置时可以使用的命令</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>ed:     编辑并使用两种版本，每一个版本都加上一个不同的标题头。
eb:     编辑并使用两个版本。
el:     编辑并使用左边的版本。
er:     编辑并使用右边的版本。
e:      编辑一个新的版本。
l:      使用左边的版本。
r:      使用右边的版本。
s:      包含相同的行。
v:      包含相同的行，并列出来源。
q:      退出。
</pre></td></tr>
</tbody></table>
<p>
当你完成重要的配置文件的更新后，余下的其它配置文件你就可以采用自动更新的方法了。当无法再找到任何可更新的配置文件时<span class="code" dir="ltr">etc-update</span>将退出。
</p>
<p class="chaphead"><a name="book_part3_chap4__chap3"></a><span class="chapnum">4.c. </span>quickpkg</p>
<p>
利用<span class="code" dir="ltr">quickpkg</span>可以对系统中已安装的包进行打包归档。这些归档文件可以作为预编译包使用。运行<span class="code" dir="ltr">quickpkg</span>非常简单：只要加上你想要制作的软件包的名字就可以了。
</p>
<p>
例如，要打包<span class="code" dir="ltr">curl</span>,<span class="code" dir="ltr">arts</span>,<span class="code" dir="ltr">procps</span>
</p>
<a name="book_part3_chap4__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: quickpkg的使用范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">quickpkg curl arts procps</span>
</pre></td></tr>
</tbody></table>
<p>
预编译包会保存在<span class="path" dir="ltr">$PKGDIR/All</span>（默认为<span class="path" dir="ltr">/usr/portage/packages/All</span>)。指向这些包的符号链接保存在<span class="path" dir="ltr">$PKGDIR/&lt;category&gt;</span>中。
</p>
<a name="book_part3_chap5"></a><h3>5. 改造Portage树</h3>
<p class="chaphead"><a name="book_part3_chap5__chap1"></a><span class="chapnum">5.a. </span>使用Portage树的一个子集</p>
<p class="secthead"><a name="book_part3_chap5__chap1_sect1">排除软件包/类别</a></p>
<p>
你可以有选择地更新特定的类别/软件包并且忽略其他类别/软件包。我们通过让<span class="code" dir="ltr">emerge --sync</span>在执行<span class="code" dir="ltr">rsync</span>的时候排除个别类别/软件包来实现这个功能。
</p>
<p>
你需要在<span class="path" dir="ltr">/etc/make.conf</span>中赋予<span class="code" dir="ltr">--exclude-from</span>变量一个文件名，该文件应包含你想要排除的软件包。
</p>
<a name="book_part3_chap5__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 在/etc/make.conf中指定包含排除软件包条目的文件</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>PORTAGE_RSYNC_EXTRA_OPTS="--exclude-from=/etc/portage/rsync_excludes"
</pre></td></tr>
</tbody></table>
<a name="book_part3_chap5__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: 在/etc/portage/rsync_excludes中设定排除所有游戏</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>games-*/*
</pre></td></tr>
</tbody></table>
<p>
然而要注意的是这可能导致依赖性问题，因为新的、允许安装的软件包可能依赖于那些新的、但被排除的软件包。
</p>
<p class="chaphead"><a name="book_part3_chap5__chap2"></a><span class="chapnum">5.b. </span>添加非官方Ebuild</p>
<p class="secthead"><a name="book_part3_chap5__chap2_sect1">定义一个Portage Overlay目录</a></p>
<p>
可以让你的Portage使用官方Portage树里面没有的ebuild。创建一个新的目录（比如<span class="path" dir="ltr">/usr/local/portage</span>）用以存放第三方ebuild。请在新目录中使用跟官方Portage树一样的目录结构！
</p>
<p>
然后在<span class="path" dir="ltr">/etc/make.conf</span>中定义PORTDIR_OVERLAY变量，使它指向刚才创建的目录。现在，每当你用到Portage的时候，这些ebuilds也会被同时计算在内，并且当你下次运行<span class="code" dir="ltr">emerge --sync</span>时，不会删除/覆盖这些ebuild。
</p>
<p class="secthead"><a name="book_part3_chap5__chap2_sect2">使用多个Overlay仓库</a></p>
<p>
对于开发多个Overlay的许多高级用户而言，他们会在更新Portage树之前测试软件包或是想使用来源广泛的非官方ebuild。<span class="code" dir="ltr">app-portage/gentoolkit-dev</span>软件包提供了<span class="code" dir="ltr">gensync</span>工具，帮助你的overlay仓库时时都处于最新的状态。
</p>
<p>
可以用<span class="code" dir="ltr">gensync</span>一次更新所有的仓库，也可以选择更新其中的几个。每个仓库会有一个<span class="path" dir="ltr">.syncsource</span>文件于<span class="path" dir="ltr">/etc/gensync/</span>配置目录下，其内容包含仓库的存放位置、名字、ID等。
</p>
<p>
假设你有两个额外的仓库，分别名为<span class="code" dir="ltr">java</span>（存放开发中的java ebuild）和<span class="code" dir="ltr">entapps</span>（存放在家中为你给公司开发的应用程序）。那么可以通过以下命令来更新这些仓库：
</p>
<a name="book_part3_chap5__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 使用gensync更新仓库</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">gensync java entapps</span>
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part3_chap5__chap3"></a><span class="chapnum">5.c. </span>非Portage维护的软件</p>
<p class="secthead"><a name="book_part3_chap5__chap3_sect1">Portage环境下使用自己维护的软件</a></p>
<p>
尽管Portage以及提供了某些软件，但是某些情况下你还是想自己配置、安装和维护这些软件，而不是希望Portage为你自动完成这些过程。典型的例
子是内核源码和nvidia驱动程序。你可以配置一下Portage让它知道某个软件包已经通过手动安装到系统中了。这个过程叫做<span class="emphasis">注入</span>”，Portage是通过<span class="path" dir="ltr">/etc/portage/profile/package.provided</span>文件来实现这个功能的。
</p>
<p>
举个例子，如果你想告诉Portage已经手动安装了<span class="code" dir="ltr">gentoo-sources-2.6.11.6</span>，那么把下面一行添加到<span class="path" dir="ltr">/etc/portage/profile/package.provided</span>文件里：
</p>
<a name="book_part3_chap5__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: package.provided范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>sys-kernel/gentoo-sources-2.6.11.6
</pre></td></tr>
</tbody></table>
<a name="book_part4"></a><h2>D. Gentoo网络配置</h2>
<a name="book_part4_chap1"></a><h3>1. 新手上路</h3>
<p class="chaphead"><a name="book_part4_chap1__chap1"></a><span class="chapnum">1.a. </span>新手上路</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
本文假定你已经配置好了你的内核，包括你的硬件的模块，并且你知道你的硬件（译注：这里指网卡）的接口名。我们同时假定你已经设置了<span class="code" dir="ltr">eth0</span>，当然它也可以是<span class="code" dir="ltr">eth1</span>、<span class="code" dir="ltr">wlan0</span>等等。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
本文档要求你正在运行的是<span class="code" dir="ltr">baselayout-1.11.11</span>或更高版本。
</p></td></tr></tbody></table>
<p>
要开始配置你的网卡，你首先需要告诉Gentoo RC系统你的网卡。这可以通过在<span class="path" dir="ltr">/etc/init.d</span>目录里建立一个指向<span class="path" dir="ltr">net.lo</span>的名叫<span class="path" dir="ltr">net.eth0</span>的符号链接来实现。
</p>
<a name="book_part4_chap1__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 建立符号连接net.eth0指向net.lo</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">cd /etc/init.d</span>
# <span class="code-input">ln -s net.lo net.eth0</span>
</pre></td></tr>
</tbody></table>
<p>
现在Gentoo的RC系统知道了这个接口。它还需要知道怎么来配置这个接口。所有的网络接口都在<span class="path" dir="ltr">/etc/conf.d/net</span>文件里设置。下面是一个设置DHCP和静态地址的简单配置：</p>
<a name="book_part4_chap1__chap1_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.2: /etc/conf.d/net文件的一个示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># DHCP</span>
config_eth0=( "dhcp" )

<span class="code-comment"># 使用CIDR形式表示的静态IP</span>
config_eth0=( "192.168.0.7/24" )
routes_eth0=( "default via 192.168.0.1" )

<span class="code-comment"># 使用netmask形式表示的静态IP</span>
config_eth0=( "192.168.0.7 netmask 255.255.255.0" )
routes_eth0=( "default via 192.168.0.1" )
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>如果你没有指定，DHCP是默认选项。</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>CIDR
代表无级别Internet域路由（Classless InterDomain
Routing）。一开始，IPv4地址被归类为A，B或者C类。最初的分类系统没有考虑到Internet如此流行，会有耗尽IP的危险。CIDR允许
一个IP地址可以表达多个IP地址。除了以一个斜线跟着一个数字结束外，CIDR
IP地址跟普通IP地址是一样的；例如：192.168.0.0/16。CIDR是<a href="http://rfc.net/rfc1519.html">RFC 1519</a>定义的。
</p></td></tr></tbody></table>
<p>
现在我们已经配置好了接口，可以用下面的命令启动、停止它
</p>
<a name="book_part4_chap1__chap1_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.3: 启动和停止网络脚本</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">/etc/init.d/net.eth0 start</span>
# <span class="code-input">/etc/init.d/net.eth0 stop</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
我们建议你在<span class="path" dir="ltr">/etc/conf.d/rc</span>文件里设置<span class="code" dir="ltr">RC_VERBOSE="yes"</span>。这样你可以在网络出现故障的时候，得到关于故障的更多信息。
</p></td></tr></tbody></table>
<p>
现在已经成功地启动并停止了你的网络接口，你可能希望在Gentoo启动的时候启动它。这样做就可以了：（最后那个“rc”命令通知Gentoo启动当前runlevel中还没有被启动的脚本）
</p>
<a name="book_part4_chap1__chap1_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.4: 配置网络接口以便在启动的时候装载它</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">rc-update add net.eth0 default</span>
# <span class="code-input">rc</span>
</pre></td></tr>
</tbody></table>
<a name="book_part4_chap2"></a><h3>2. 高级配置</h3>
<p class="chaphead"><a name="book_part4_chap2__chap1"></a><span class="chapnum">2.a. </span>高级配置</p>
<p>
<span class="code" dir="ltr">config_eth0</span>变量是一个网络接口配置的核心。它包含了一组用来配置接口的高级指令列表（我们用<span class="code" dir="ltr">eth0</span>作为示例）。指令列表中的每一条命令都是顺序执行的。该列表中只要至少有一条命令正常工作，则这个网络接口就被认为是可以使用的。
</p>
<p>
这里列出了一些可用的指令。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>命令</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">null</span></td>
  <td class="tableinfo">不做任何事</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">noop</span></td>
  <td class="tableinfo">
    如果网络接口已经开启并且也绑定好地址的话，则中止配置过程，配置成功。
  </td>
</tr>
<tr>
  <td class="tableinfo">一个IPv4或是IPv6的地址</td>
  <td class="tableinfo">绑定地址到接口上</td>
</tr>
<tr>
  <td class="tableinfo">
    <span class="code" dir="ltr">dhcp</span>、<span class="code" dir="ltr">adsl</span>或<span class="code" dir="ltr">apipa</span>（或者一个第三方模块提供的自定义命令）
  </td>
  <td class="tableinfo">
    运行提供这些命令的模块，例如<span class="code" dir="ltr">dhcp</span>这个命令会运行一个提供DHCP功能的模块，它可能是<span class="code" dir="ltr">dhcpcd</span>、<span class="code" dir="ltr">udhcpc</span>、<span class="code" dir="ltr">dhclient</span>或者<span class="code" dir="ltr">pump</span>中的一个。
  </td>
</tr>
</tbody></table>
<p>
如果一条命令执行失败，你可以指定一条fallback指令。这条fallback指令必须完全符合配置的结构。
</p>
<p>
你可以连在一起使用这些指令，下面是一些真实应用的例子。
</p>
<a name="book_part4_chap2__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 配置示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 加上三个IPv4的地址</span>
config_eth0=(
  "192.168.0.2/24"
  "192.168.0.3/24"
  "192.168.0.4/24"
)

<span class="code-comment"># 加上一个IPv4的地址和两个IPv6的地址</span>
config_eth0=(
  "192.168.0.2/24"
  "4321:0:1:2:3:4:567:89ab"
  "4321:0:1:2:3:4:567:89ac"
)

<span class="code-comment"># 保持使用内核分配的地址，除非网络接口没有启动。如果是这样则改用DHCP获
#取。如果DHCP失败的话则由APIPA指定一个网络地址。</span>
config_eth0=(
  "noop"
  "dhcp"
)
fallback_eth0=(
  "null"
  "apipa"
)
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
当你使用的是<span class="code" dir="ltr">ifconfig</span>模块并且绑定了一个以上的网络地址，系统会为每一个网络地址建立一个别名。在上面的两个例子中你将会得到这几个网络接口：<span class="code" dir="ltr">eth0</span>、<span class="code" dir="ltr">eth0:1</span>和<span class="code" dir="ltr">eth0:2</span>。由于内核和其他程序会把<span class="code" dir="ltr">eth0:1</span>和<span class="code" dir="ltr">eth0:2</span>看作<span class="code" dir="ltr">eth0</span>，所以你将无法对这些接口做什么特殊的事情。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
fallback中的顺序相当重要！如果我们没有指定<span class="code" dir="ltr">null</span>选项，那么<span class="code" dir="ltr">apipa</span>只会在<span class="code" dir="ltr">noop</span>命令失败后才会执行。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
<a href="#apipa">APIPA</a>和<a href="#dhcp">DHCP</a>稍后会讨论。
</p></td></tr></tbody></table>
<p class="chaphead"><a name="book_part4_chap2__chap2"></a><span class="chapnum">2.b. </span>网络依赖性</p>
<p>
<span class="path" dir="ltr">/etc/init.d</span>中的初始化脚本可能依赖于某个特定的网络接口或只是net服务。可以通过定义在<span class="path" dir="ltr">/etc/conf.d/rc</span>中的<span class="code" dir="ltr">RC_NET_STRICT_CHKING</span>这个变量，来使<span class="code" dir="ltr">net</span>代表不同的意思。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>值</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">none</span></td>
  <td class="tableinfo">系统始终认为<span class="path" dir="ltr">net</span>服务已经启动了</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">no</span></td>
  <td class="tableinfo">
    这是说除了<span class="path" dir="ltr">net.lo</span>之外，至少还需要再启动一个<span class="path" dir="ltr">net.*</span>服务。同时拥有WIFI网络和静态NIC网络的笔记本用户可使用这个值。对他们来说某一时间只要有一个网络接口启动，那么net服务就应被视为启动了。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">lo</span></td>
  <td class="tableinfo">
    这和<span class="code" dir="ltr">no</span>选项相同，不过就是把<span class="path" dir="ltr">net.lo</span>也考虑在内了。它对那些不怎么在意在系统启动时哪个网络接口会被启动的用户很有用。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">yes</span></td>
  <td class="tableinfo">
    所有的网络接口都启动后，net服务才算启动。
  </td>
</tr>
</tbody></table>
<p>
可是需要依赖<span class="path" dir="ltr">net.eth0</span>和<span class="path" dir="ltr">net.eth1</span>的<span class="path" dir="ltr">net.br0</span>应该怎么处理呢？<span class="path" dir="ltr">net.eth1</span>可能是一个无线网络或是一个PPP设备，且需要在桥接前先设定好。这不能在<span class="path" dir="ltr">/etc/init.d/net.br0</span>中定义，因为它只是一个到<span class="path" dir="ltr">net.lo</span>的符号连接。
</p>
<p>
答案是在<span class="path" dir="ltr">/etc/conf.d/net</span>里定义一个自己的<span class="code" dir="ltr">depend()</span>函数。
</p>
<a name="book_part4_chap2__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: /etc/conf.d/net中net.br0的依赖关系</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 你可以使用目前脚本里能用的任何依赖关系（use、after、before）</span>
depend_br0() {
  need net.eth0 net.eth1
}
</pre></td></tr>
</tbody></table>
<p>
要获得更多关于依赖性的讨论。请参考Gentoo手册中的这一节<a href="#book_part2_chap4__chap4">撰写初始化脚本</a> 
</p>
<p class="chaphead"><a name="variable_name"></a><a name="book_part4_chap2__chap3"></a><span class="chapnum">2.c. </span>变量名称和值</p>
<p>
变量的名称是动态的，它们通常的结构是<span class="code" dir="ltr">variable_${interface|mac|essid|apmac}</span>。例如<span class="code" dir="ltr">dhcpcd_eth0</span>变量代表eth0的dhcpcd命令参数。而<span class="code" dir="ltr">dhcpcd_essid</span>变量代表连接到ESSID为"essid"的AP的网络接口的dhcpcd命令参数。
</p>
<p>
不过，没有什么强制性的和快速的标准规定了网络接口名称必须是ethx。事实上，许多无线网络接口除了使用ethx之外，也会使用类似于wlanx、
rax之类的名称。而且一些用户自定义的网络接口（比如网桥接口）可以被命名为任何名字（比如foo）。更有趣的是，无线网络接入点可以在ESSID中使
用非英文字符或数字字符——这一点很重要，因为你可以为每一个ESSID设定网络参数。
</p>
<p>
不幸的是Gentoo在网络设定方面使用的是bash的变量名——而bash不能使用数字、英文字母之外的任何字符。为了突破这样的一个限制，我们把所有除数字、英文字母之外的字符用<span class="code" dir="ltr">_</span>字符表示。
</p>
<p>
bash的另一个问题是变量的内容——一些字符需要转义。这可以通过在需要转义的字符前面加<span class="code" dir="ltr">\</span>来解决。下面列出的是需要转义的字符列表：<span class="code" dir="ltr">"</span>、<span class="code" dir="ltr">'</span>和<span class="code" dir="ltr">\</span>。
</p>
<p>
在这个例子中，我们使用无线网络ESSID，因为它可以包含的字符范围最广。我们使用<span class="code" dir="ltr">My "\ NET</span>这个ESSID：
</p>
<a name="book_part4_chap2__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 变量名示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（这样确实可以传递域名，但是域名的值是非法的）</span>
dns_domain_My____NET="My \"\\ NET"

<span class="code-comment">（上面的例子意思是当一块无线网卡连接到ESSID为My "\ NET的无线接入点时
把dns域名设置为My "\NET）</span>
</pre></td></tr>
</tbody></table>
<a name="book_part4_chap3"></a><h3>3. 模块化网络</h3>
<p class="chaphead"><a name="book_part4_chap3__chap1"></a><span class="chapnum">3.a. </span>网络模块</p>
<p>
我们现在支持模块化的网络脚本，这意味着我们可以很方便地增添新的网络接口和配置模块，同时和原来已存在的模块或是接口保持良好的兼容性。
</p>
<p>
只要模块需要的软件包已安装，它就会被默认载入。如果你指定一个模块而它需要的软件包未被安装，则你就会收到一个错误信息通知你需要安装哪一个软件包。一般来说，只有当你安装了提供相同服务的两个及以上的软件包时，你才需要使用模块设定来选择你想使用其中的哪一个。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
除非有特别说明，这里所讨论的全部设定都保存在<span class="path" dir="ltr">/etc/conf.d/net</span>中。
</p></td></tr></tbody></table>
<a name="book_part4_chap3__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: 模块选择</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 选择iproute2而不用ifconfig</span>
modules=( "iproute2" )

<span class="code-comment"># 你也可以为一个网络接口指定其他的模块
# 这个例子中我们希望使用udhcpc来代替dhcpcd</span>
modules_eth0=( "udhcpc" )

<span class="code-comment"># 你也可以指定不使用哪一个模块——例如你一方面想使用supplicant或是
# linux-wlan-ng来控制无线网络配置，一方面又想配置每一个ESSID相关联的网络设定。</span>
modules=( "!iwconfig" )
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap2"></a><span class="chapnum">3.b. </span>网络接口处理程序</p>
<p>
目前我们提供了两个网络接口处理程序：<span class="code" dir="ltr">ifconfig</span>和<span class="code" dir="ltr">iproute2</span>。你可以使用i这两个程序中的一个进行任意种类的网络配置。
</p>
<p>
<span class="code" dir="ltr">ifconfig</span>是目前Gentoo默认使用的网络接口处理程序，而且它也包含在系统的profile之中。<span class="code" dir="ltr">iproute2</span>是另一个灵活且强大的软件包，但是默认的系统配置中并不包含它。
</p>
<a name="book_part4_chap3__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装iproute2</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge sys-apps/iproute2</span>

<span class="code-comment"># 在iproute2和ifconfig都已安装的情况下，选用iproute2</span>
modules=( "iproute2" )
</pre></td></tr>
</tbody></table>
<p>
由于<span class="code" dir="ltr">ifconfig</span>和<span class="code" dir="ltr">iproute2</span>的功能很类似，我们允许使用它们的基本配置功能以使二者可以通用。例如说下面的代码片段对于它们之中的任何一个来说都是起效的。
</p>
<a name="book_part4_chap3__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: ifconfig和iproute2示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>config_eth0=( "192.168.0.2/24" )
config_eth0=( "192.168.0.2 netmask 255.255.255.0" )

<span class="code-comment"># 我们也可以指定广播地址</span>
config_eth0=( "192.168.0.2/24 brd 192.168.0.255" )
config_eth0=( "192.168.0.2 netmask 255.255.255.0 broadcast 192.168.0.255" )
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="dhcp"></a><a name="book_part4_chap3__chap3"></a><span class="chapnum">3.c. </span>DHCP</p>
<p>DHCP是一种通过DHCP服务器来获得相关的网络信息（比如IP地址、DNS服务器、网关等）的方式。这意味着如果在网络上存在着一个DHCP服
务器的话，你只要让每一个客户端使用DHCP，这些客户端就会自动地配置好相关的网络设置。当然，如果在使用DHCP之前还需要配置无线网络或是PPP等
其他设定的话，你就必须先配置好这些才行。
</p>
<p>
<span class="code" dir="ltr">dhclient</span>、<span class="code" dir="ltr">dhcpcd</span>、<span class="code" dir="ltr">pump</span>或者<span class="code" dir="ltr">udhcpc</span>都可以提供DHCP功能。每一种DHCP模块都有各自的优缺点——下面是一个快速的检阅。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>DHCP模块</b></th>
  <th class="infohead" style="text-align: left;"><b>软件包</b></th>
  <th class="infohead" style="text-align: left;"><b>优点</b></th>
  <th class="infohead" style="text-align: left;"><b>缺点</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">dhclient</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">net-misc/dhcp</span></td>
  <td class="tableinfo">
    由ISC（也是BIND DNS软件的开发人员）制作；高度可配置性。
  </td>
  <td class="tableinfo">
    配置起来过于复杂；软件十分臃肿；无法通过DHCP获得NTP服务器；默认不发送主机名。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">dhcpcd</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">net-misc/dhcpcd</span></td>
  <td class="tableinfo">
    Gentoo一直以来的预设软件；不依赖其他外部软件；由Gentoo开发的。
  </td>
  <td class="tableinfo">有时很慢；当租约为无穷大时不会变成守护进程。</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">pump</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">net-misc/pump</span></td>
  <td class="tableinfo">
    轻量级的；不依赖其他外部软件
  </td>
  <td class="tableinfo">
    不再被上游维护，不可靠，尤其在使用modem的时候；不能通过DHCP获得NIS服务器。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">udhcpc</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">net-misc/udhcp</span></td>
  <td class="tableinfo">
    轻量级的——最小的DHCP客户端，为嵌入式系统设计。
  </td>
  <td class="tableinfo">
    未经考验——没有任何发行版默认使用它，不能定义3秒以上的超时。
  </td>
</tr>
</tbody></table>
<p>
当你在系统上安装有不止一种DHCP客户端，你需要指定使用哪一个——否则如果系统装有<span class="code" dir="ltr">dhcpcd</span>，我们将默认使用它。
</p>
<p>
你可以使用<span class="code" dir="ltr">module_eth0="..."</span><span class="emphasis">（把module改成你所使用DHCP模块的名称——例如：<span class="code" dir="ltr">dhcpcd_eth0</span>）</span>为DHCP模块指定选项。
</p>
<p>
我们尝试使DHCP的配置更加灵活——所以我们通过<span class="code" dir="ltr">dhcp_eth0</span>变量来支持下面这些命令，默认不使用它们中的任何一个：
</p>
<ul>
  <li>
<span class="code" dir="ltr">release</span> - 释放IP地址以便它可以被重新使用</li>
  <li>
<span class="code" dir="ltr">nodns</span> - 不覆盖<span class="path" dir="ltr">/etc/resolv.conf</span>
</li>
  <li>
<span class="code" dir="ltr">nontp</span> - 不覆盖<span class="path" dir="ltr">/etc/ntp.conf</span>
</li>
  <li>
<span class="code" dir="ltr">nonis</span> - 不覆盖<span class="path" dir="ltr">/etc/yp.conf</span>
</li>
</ul>
<a name="book_part4_chap3__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 在/etc/conf.d/net中的DHCP配置范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 只在你安装了一个以上的DHCP模块后才需要</span>
modules=( "dhcpcd" ) 

config_eth0=( "dhcp" )
dhcpcd_eth0="-t 10" <span class="code-comment"># 10秒后超时</span>
dhcp_eth0="release nodns nontp nonis" <span class="code-comment"># 只获取IP地址</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
由于<span class="code" dir="ltr">dhcpcd</span>、<span class="code" dir="ltr">udhcpc</span>和<span class="code" dir="ltr">pump</span>默认会把主机名发送给DHCP服务器，所以你就可以不用去指定它了。
</p></td></tr></tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap4"></a><span class="chapnum">3.d. </span>基于PPPoE/PPPoA的ADSL</p>
<p>
首先我们安装ADSL软件。
</p>
<a name="book_part4_chap3__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 安装ppp软件包</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge net-dialup/ppp</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果你需要PPPoA，确保你使用的是&gt;=<span class="code" dir="ltr">baselayout-1.12.x</span>。
</p></td></tr></tbody></table>
<p>
其次，创建PPP网络脚本和PPP所使用的以太网卡的网络脚本：
</p>
<a name="book_part4_chap3__chap4_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.2: 创建PPP和以太网卡网络脚本</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">ln -s /etc/init.d/net.lo /etc/init.d/net.ppp0</span>
# <span class="code-input">ln -s /etc/init.d/net.lo /etc/init.d/net.eth0</span>
</pre></td></tr>
</tbody></table>
<p>
确保在<span class="path" dir="ltr">/etc/conf.d/rc</span>设定RC_NET_STRICT_CHECKING="yes"。
</p>
<p>
现在我们需要配置<span class="path" dir="ltr">/etc/conf.d/net</span>。
</p>
<a name="book_part4_chap3__chap4_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.3: 一个基本的PPPoE设定</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>config_eth0=( null ) <span class="code-comment">（指定你的以太网卡）</span>
config_ppp0=( "ppp" )
link_ppp0="eth0" <span class="code-comment">（指定你的以太网卡）</span>
plugins_ppp0=( "pppoe" )
username_ppp0='user'
password_ppp0='password'
pppd_ppp0=(
       "noauth"
       "defaultroute"
       "usepeerdns"
       "holdoff 3"
       "child-timeout 60"
       "lcp-echo-interval 15"
       "lcp-echo-failure 3"
       noaccomp noccp nobsdcomp nodeflate nopcomp novj novjccomp
)

depend_ppp0() {
    need net.eth0
}
</pre></td></tr>
</tbody></table>
<p>
你也可以在<span class="path" dir="ltr">/etc/ppp/pap-secrets</span>中定义你的密码。
</p>
<a name="book_part4_chap3__chap4_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.4: /etc/ppp/pap-secrets范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># *号非常重要</span>
"username"  *  "password"
</pre></td></tr>
</tbody></table>
<p>
如果你通过一个USB调制解调器来使用PPPoE，你需要emerge <span class="code" dir="ltr">br2684ctl</span>。请阅读<span class="path" dir="ltr">/usr/portage/net-dialup/speedtouch-usb/files/README</span>来了解如果正确的配置它。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
请仔细阅读<span class="path" dir="ltr">/etc/conf.d/net.example</span>里有关ADSL和PPP的部分。它包含了你的PPP设定可能需要的设置的详尽解释。
</p></td></tr></tbody></table>
<p class="chaphead"><a name="apipa"></a><a name="book_part4_chap3__chap5"></a><span class="chapnum">3.e. </span>APIPA（自动获得私有的IP地址）</p>
<p>
APIPA通过在某网络接口arping在169.254.0.0-169.254.255.255范围内的某个随机地址的方式来在该范围内尝试寻找空闲地址。如果没有收到任何ARP应答，该IP地址就会被绑定到这个网络接口上。
</p>
<p>
只有在网络上不存在DHCP服务器，同时本机不直接连接到internet并且其他所有的计算机都使用APIPA时才适用。
</p>
<p>
为了支持APIPA，请emerge <span class="code" dir="ltr">net-misc/iputils</span>或<span class="code" dir="ltr">net-analyzer/arping</span>。
</p>
<a name="book_part4_chap3__chap5_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;5.1: /etc/conf.d/net中的APIPA配置</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 首先尝试DHCP——如果DHCP失败则使用APIPA</span>
config_eth0=( "dhcp" )
fallback_eth0=( "apipa" )

<span class="code-comment"># 只使用APIPA</span>
config_eth0=( "apipa" )
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap6"></a><span class="chapnum">3.f. </span>绑定</p>
<p>
为了使用连接绑定，请emerge <span class="code" dir="ltr">net-misc/ifenslave</span>。
</p>
<p>
绑定可以用来增加网络带宽。如果你有两块网卡连接到同一个网络，你可以把它们绑定在一起这样你的应用程序只看到一个网卡，但实际上却是在同时使用两个物理网卡传送数据。
</p>
<a name="book_part4_chap3__chap6_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;6.1: 在/etc/conf.d/net中配置绑定</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 把网络接口绑定在一起</span>
slaves_bond0="eth0 eth1 eth2"

<span class="code-comment"># 你可以不为绑定而得的网络接口配置IP地址</span>
config_bond0=( "null" )

<span class="code-comment"># 依赖eth0、eth1和eth2， 因为它们需要额外的配置</span>
depend_bond0() {
  need net.eth0 net.eth1 net.eth2
}
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap7"></a><span class="chapnum">3.g. </span>桥接（802.1d的支持）</p>
<p>
为了获得对桥接支持，请emerge <span class="code" dir="ltr">net-misc/bridge-utils</span>。
</p>
<p>
桥接是用来把两个网络连接在一起。举例来说，你有一台通过ADSL modem接入internet的服务器，它同时通过无线网卡为其他计算机提供internet接入服务。你就可以创建桥接把这两个网络接口连接在一起。
</p>
<a name="book_part4_chap3__chap7_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;7.1: /etc/conf.d/net中桥接的配置</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 配置桥接——可以使用"man brctl"来获得更多信息</span>
brctl_br0=( "setfd 0" "sethello 0" "stp off" )

<span class="code-comment"># 增加端口到网桥br0中</span>
bridge_br0="eth0 eth1"

<span class="code-comment"># 你需要把端口配置成null，这样dhcp就不会启动了</span>
config_eth0=( "null" )
config_eth1=( "null" )

<span class="code-comment"># 最后为网桥配置一个IP地址——你也可以使用DHCP</span>
config_br0=( "192.168.0.1/24" )

<span class="code-comment"># 依赖eth0和eth1，因为它们需要额外的配置</span>
depend_br0() {
  need net.eth0 net.eth1
}
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
在使用一些桥接的设定时，你可能需要参考文档<a href="#variable_name">变量名称</a>
</p></td></tr></tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap8"></a><span class="chapnum">3.h. </span>MAC地址</p>
<p>
如果你使用的是<span class="code" dir="ltr">sys-apps/baselayout-1.11.14</span>或者更新版本的话，你无需安装任何软件就可以更改网络接口对应的MAC地址或者为某个网络接口指定一个MAC地址。不过，如果你需要为网络接口指定一个随机的MAC地址或者你的baselayout的版本比上述版本要旧的话，你需要安装好<span class="code" dir="ltr">net-analyzer/macchanger</span>后才能使用这些功能。
</p>
<a name="book_part4_chap3__chap8_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;8.1: MAC地址变更示例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 设置网络接口的MAC地址</span>
mac_eth0="00:11:22:33:44:55"

<span class="code-comment"># 只随机选择MAC地址的最后3个字节</span>
mac_eth0="random-ending"

<span class="code-comment"># 在同种物理连接类型(比如: 光纤、铜缆、无线)中随机选择，范围至所有制造商</span>
mac_eth0="random-samekind"

<span class="code-comment"># 在任意物理连接类型(比如: 光纤、铜缆、无线)中随机选择，范围至所有制造商</span>
mac_eth0="random-anykind"

<span class="code-comment"># 完全随机——警告: 一些通过这个方式获得的MAC地址有可能无法正常工作</span>
mac_eth0="random-full"
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap9"></a><span class="chapnum">3.i. </span>隧道</p>
<p>
你不需要安装任何软件就可以使用隧道，因为网络接口处理程序会帮你做好这些事。
</p>
<a name="book_part4_chap3__chap9_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;9.1: 在/etc/conf.d/net中配置隧道</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># GRE隧道</span>
iptunnel_vpn0="mode gre remote 207.170.82.1 key 0xffffffff ttl 255"

<span class="code-comment"># IPIP隧道</span>
iptunnel_vpn0="mode ipip remote 207.170.82.2 ttl 255"

<span class="code-comment"># 配置网络接口</span>
config_vpn0=( "192.168.0.2 peer 192.168.1.1" ) 
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap3__chap10"></a><span class="chapnum">3.j. </span>VLAN（802.1q的支持）</p>
<p>
为了获得对VLAN的支持，请emerge <span class="code" dir="ltr">net-misc/vconfig</span>.
</p>
<p>
虚拟局域网（Virtual LAN）是一组有如运作在同个网段的一组网络设备的集合——尽管实际上可能不是。VLAN成员只能看到同一VLAN的成员，哪怕和其他VLAN成员处于同一物理网段中。
</p>
<a name="book_part4_chap3__chap10_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;10.1: 在/etc/conf.d/net中配置VLAN</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 像这样为网络接口指定VLAN号</span>
<span class="code-comment"># 请确认每个VLAN号前面没有以0填充</span>
vlans_eth0="1 2"

<span class="code-comment"># 你也可以配置VLAN</span>
<span class="code-comment"># 查看vconfig的手册页获取更多的信息</span>
vconfig_eth0=( "set_name_type VLAN_PLUS_VID_NO_PAD" )
vconfig_vlan1=( "set_flag 1" "set_egress_map 2 6" )

<span class="code-comment"># 按通常方法配置网络接口</span>
config_vlan1=( "172.16.3.1 netmask 255.255.254.0" )
config_vlan2=( "172.16.2.1 netmask 255.255.254.0" )
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
在使用一些VLAN的设定时，你可能需要查看文档<a href="#variable_name">变量名称</a>。
</p></td></tr></tbody></table>
<a name="book_part4_chap4"></a><h3>4. 无线网络</h3>
<p class="chaphead"><a name="book_part4_chap4__chap1"></a><span class="chapnum">4.a. </span>介绍</p>
<p>
目前您可以使用我们提供的<span class="code" dir="ltr">wireless-tools</span> 或<span class="code" dir="ltr">wpa_supplicant</span>工具来配置无线网络。请记住重要的一点是，您对无线网络的配置是全局性的，而非针对具体的接口。
</p>
<p>
<span class="code" dir="ltr">wpa_supplicant</span>是一个最好的选择，但缺点是它不支持所有的驱动。请浏览<a href="http://hostap.epitest.fi/wpa_supplicant">wpa_supplicant网站</a>获得它所支持的驱动列表。另外，<span class="code" dir="ltr">wpa_supplicant</span>目前只能连接到那些你已经配置好ESSID的无线网络。
</p>
<p>
<span class="code" dir="ltr">wireless-tools</span>支持几乎所有的无线网卡和驱动，但它不能连接到那些只支持WPA的AP。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffbbbb"><p class="note"><b>警告: </b>
由于<span class="code" dir="ltr">linux-wlan-ng</span>驱动有其自己特有的安装和配置方式，而且与其他软件的方式完全不同，因此目前它并不被baselayout所支持。有传闻说<span class="code" dir="ltr">linux-wlan-ng</span>的开发者要将它的设置方式改成<span class="code" dir="ltr">wireless-tools</span>的方式——到时候您就可以在baselayout中使用<span class="code" dir="ltr">linux-wlan-ng</span>了。
</p></td></tr></tbody></table>
<p class="chaphead"><a name="book_part4_chap4__chap2"></a><span class="chapnum">4.b. </span>WPA Supplicant</p>
<p>
<a href="http://hostap.epitest.fi/wpa_supplicant">WPA Supplicant</a>工具包可以让您连接到那些使用WPA的AP。因为还只是beta版，所以它的配置方法仍会常常变化——尽管如此，在大部分情况下它已经能很好的工作。
</p>
<a name="book_part4_chap4__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装wpa_supplicant</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge net-wireless/wpa_supplicant</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
要让<span class="code" dir="ltr">wpa_supplicant</span>正常工作，您必须在内核中打开<span class="code" dir="ltr">CONFIG_PACKET</span>支持。
</p></td></tr></tbody></table>
<p>
现在我们需要配置一下<span class="path" dir="ltr">/etc/conf.d/net</span>文件以便我们可以选择使用<span class="code" dir="ltr">wpa_supplicant</span>而不用<span class="code" dir="ltr">wireless-tools</span>（两者都安装在系统中时，默认使用的是<span class="code" dir="ltr">wireless-tools</span>）。
</p>
<a name="book_part4_chap4__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: 在/etc/conf.d/net中配置wpa_supplicant</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 使用wpa_supplicant代替wireless-tools</span>
modules=( "wpa_supplicant" )

<span class="code-comment"># 因为wpa_supplicant还不能很好的自动侦测驱动，所以需要我们为其指定正在使用的驱动。</span>
wpa_supplicant_eth0="-Dmadwifi"
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
如果您用host-ap驱动，您首先要将无线设备卡设置成<span class="emphasis">Managed模式</span>以便能正确地配合<span class="code" dir="ltr">wpa_supplicant</span>工作。你可以在<span class="path" dir="ltr">/etc/conf.d/net</span>中设置<span class="code" dir="ltr">iwconfig_eth0="mode managed"</span>来实现这一点。
</p></td></tr></tbody></table>
<p>
看起来这很简单，不是么？不过我们还需要配置<span class="code" dir="ltr">wpa_supplicant</span>本身，这将会比较麻烦一些，具体取决于你要连接的AP的安全程度。下面的例子是从<span class="path" dir="ltr">/usr/share/doc/wpa_supplicant-&lt;version&gt;/wpa_supplicant.conf.gz</span>中抽取并简化而来的，此文件出自<span class="code" dir="ltr">wpa_supplicant</span>软件包。
</p>
<a name="book_part4_chap4__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 一个/etc/wpa_supplicant/wpa_supplicant.conf的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 请不要修改下面这一行内容，否则将不能正常工作</span>
ctrl_interface=/var/run/wpa_supplicant

<span class="code-comment"># 确保只有root用户能读取WPA的配置</span>
ctrl_interface_group=0

<span class="code-comment"># 使用wpa_supplicant来扫描和选择AP</span>
ap_scan=1

<span class="code-comment"># 简单的情形：WPA-PSk密码验证方式，PSK是ASCII密码短语，所有合法的加密方式都允许连接</span>
network={
  ssid="simple"
  psk="very secret passphrase"
  <span class="code-comment"># 优先级越高，就能越早匹配到。</span>
  priority=5
}

<span class="code-comment"># 与前面的设置相同，但要求对特定的SSID进行扫描（针对那些拒绝广播SSID的AP）</span>
network={
  ssid="second ssid"
  scan_ssid=1
  psk="very secret passphrase"
  priority=2
}

<span class="code-comment"># 仅使用WPA-PSK方式。允许使用任何合法的加密方式的组合</span>
network={
  ssid="example"
  proto=WPA
  key_mgmt=WPA-PSK
  pairwise=CCMP TKIP
  group=CCMP TKIP WEP104 WEP40
  psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
  priority=2
}

<span class="code-comment"># 明文连接方式（不使用WPA和IEEE802.1X）</span>
network={
  ssid="plaintext-test"
  key_mgmt=NONE
}

<span class="code-comment"># 共享WEP秘钥连接方式（不使用WPA和IEEE802.1X）</span>
network={
  ssid="static-wep-test"
  key_mgmt=NONE
  wep_key0="abcde"
  wep_key1=0102030405
  wep_key2="1234567890123"
  wep_tx_keyidx=0
  priority=5
}

<span class="code-comment"># 共享WEP秘钥连接方式（无WPA和IEEE802.1X），使用共享秘钥IEEE802.11验证方式</span>
network={
  ssid="static-wep-test2"
  key_mgmt=NONE
  wep_key0="abcde"
  wep_key1=0102030405
  wep_key2="1234567890123"
  wep_tx_keyidx=0
  priority=5
  auth_alg=SHARED
}

<span class="code-comment"># 在IBSS/ad-hoc网络中使用WPA-None/TKIP</span>
network={
  ssid="test adhoc"
  mode=1
  proto=WPA
  key_mgmt=WPA-NONE
  pairwise=NONE
  group=TKIP
  psk="secret passphrase"
}
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap4__chap3"></a><span class="chapnum">4.c. </span>Wireless Tools</p>
<p class="secthead"><a name="book_part4_chap4__chap3_sect1">初始设置和管理模式</a></p>
<p>
<a href="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html">Wireless Tools</a>提供了一个通用的方法设置无线网络接口，最高可达WEP安全等级。虽然WEP是一种较弱的安全方式，但它也是最普遍使用的加密方式。
</p>
<p>
Wireless Tools的配置由几个主要变量来控制，以下配置文件的例子描述了您所需要了解的所有内容。要牢记于心的是：可确保“连接到没有加密的并且信号最强的AP”的配置并不存在——但我们会一直尝试并帮您连接到某个AP。
</p>
<a name="book_part4_chap4__chap3_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.1: 安装wireless-tools</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge net-wireless/wireless-tools</span>
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
尽管您可以将无线设置保存在<span class="path" dir="ltr">/etc/conf.d/wireless</span>中，但是本指南还是推荐您将它们保存在<span class="path" dir="ltr">/etc/conf.d/net</span>之中。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
您<span class="emphasis">将</span>需要参阅文档<a href="#variable_name">变量名称</a>。
</p></td></tr></tbody></table>
<a name="book_part4_chap4__chap3_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.2: 在/etc/conf.d/net中配置iwconfig的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 使用iwconfig而不用wpa_supplicant</span>
modules=( "iwconfig" )

<span class="code-comment"># 为名为ESSID1和ESSID2的AP配置WEP秘钥</span>
<span class="code-comment"># 您最多可以配置4个WEP密钥，但任何时候只有其中1个起作用。
# 所以我们提供一个默认的下标[1]来设置秘钥[1]，之后紧接着把活动秘钥设置为[1]。
# 我们这么做以备你让其他ESSID使用[1]以外的WEP秘钥。
#
# key加上前缀s：意味着它是一个ASCII秘钥，否则它就是一个16进制秘钥。
#
# enc open 指定开放安全性（最安全）
# enc restricted 指定限制安全性（较不安全）</span>
key_ESSID1="[1] s:yourkeyhere key [1] enc open"
key_ESSID2="[1] aaaa-bbbb-cccc-dd key [1] enc restricted"

<span class="code-comment"># 以下仅在我们扫描可用的AP时起作用</span>

<span class="code-comment"># 有时有多个AP可见，所以我们需要规定一个首选的连接次序。</span>
preferred_aps=( "ESSID1" "ESSID2" )
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part4_chap4__chap3_sect2">细致调整AP选择</a></p>
<p>
您可以添加一些额外的选项来细致的调整AP的选择，不过正常情况下并不需要这么做。
</p>
<p>
您可以决定是否只连接首选的AP。默认情况下，当配置中列出的所有AP的连接都失败后，这时如果环境中有一个非加密的AP，系统将会与其连接。这个行为可以用<span class="code" dir="ltr">associate_order</span>变量来进行控制。下面给出一个相关的值的列表以及它们如何控制AP的选择。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>值</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">any</span></td>
  <td class="tableinfo">默认行为</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">preferredonly</span></td>
  <td class="tableinfo">只连接首选列表里的可见AP</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">forcepreferred</span></td>
  <td class="tableinfo">
    按首选列表里的顺序强制连接AP，如果扫描不到的话
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">forcepreferredonly</span></td>
  <td class="tableinfo">
    不进行扫描——按首选列表里的顺序直接尝试连接AP 
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">forceany</span></td>
  <td class="tableinfo">和<span class="code" dir="ltr">forcepreferred</span>一样，外加连接到任何其他可用的AP</td>
</tr>
</tbody></table>
<p>
最后我们还提供了一些<span class="code" dir="ltr">blacklist_aps</span>和<span class="code" dir="ltr">unique_ap</span>的选择。<span class="code" dir="ltr">blacklist_aps</span>的工作方式和<span class="code" dir="ltr">preferred_aps</span>类似。<span class="code" dir="ltr">unique_ap</span>是一个<span class="code" dir="ltr">yes</span>或<span class="code" dir="ltr">no</span>的值，它决定了是否允许两个无线接口同时接入一个AP。
</p>
<a name="book_part4_chap4__chap3_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.3: blacklist_aps和unique_ap的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 有时您根本不想连接到某些AP</span>
blacklist_aps=( "ESSID3" "ESSID4" )

<span class="code-comment">#如果您有多个无线网卡，您可以决定是否允许每个卡都能连接到同一个无线AP
# 可以取的值是"yes"或者"no"
# 默认设置为"yes"</span>
unique_ap="yes"
</pre></td></tr>
</tbody></table>
<p class="secthead"><a name="book_part4_chap4__chap3_sect3">Ad-Hoc和Master模式</a></p>
<p>
当您在管理模式中无法连接到任何AP时，您也可以将自己的设备设置成Ad-Hoc节点。
</p>
<a name="book_part4_chap4__chap3_pre4"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.4: 失败后转用ad-hoc模式</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>adhoc_essid_eth0="This Adhoc Node"
</pre></td></tr>
</tbody></table>
<p>
那么，要如何连接到Ad-Hoc网络，或者干脆运行于Master模式使自身成为一个无线接入点呢？这里有这样一个设置！您可能需要参照本章前面的内容来指定WEP秘钥。</p>
<a name="book_part4_chap4__chap3_pre5"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;3.5: ad-hoc/master配置的例子</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment"># 设定模式为managed（默认）、ad-hoc或者master。并不是所有的设备都支持所有的模式。
</span>
mode_eth0="ad-hoc"

<span class="code-comment"># 设定接口的ESSID
# 在managed模式中，这将强制此接口只尝试连接特定的ESSID。
</span>
essid_eth0="This Adhoc Node"

<span class="code-comment"># 指定使用的频道，否则将默认使用频道3。
</span>
channel_eth0="9"
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
以下是从<a href="http://www.netbsd.org/Documentation/network/wavelan.html">NetBSD 文档</a>的BSD
wavelan文档中逐字逐句复制过来的内容。目前共计有14个可用的频道；1-11频道在北美是合法的，而在欧洲大部分地区则是频道1-13，在法国是
频道10-13，在日本只允许使用频道14。如果有疑问，请参考随您所购买的无线网卡或AP附带的说明书。确保调整您的无线网卡与AP（或工作于ad-
hoc模式的另一块无线网卡）使用同一个频道。默认情况下，在北美和欧洲大部分地区销售的无线网卡使用频道3；在法国使用频道11，在日本使用频道14。
</p></td></tr></tbody></table>
<p class="secthead"><a name="book_part4_chap4__chap3_sect4">Wireless Tools故障修除</a></p>
<p>
一些环境或驱动的问题可能会使无线网络不能正常工作，下表多给出一些变量，可能有助于你解决问题。
</p>
<table class="ntable">
<tbody><tr>
  <th class="infohead" style="text-align: left;"><b>参数</b></th>
  <th class="infohead" style="text-align: left;"><b>默认值</b></th>
  <th class="infohead" style="text-align: left;"><b>描述</b></th>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">iwconfig_eth0</span></td>
  <td class="tableinfo"></td>
  <td class="tableinfo">请参看<span class="code" dir="ltr">iwconfig</span>的man page了解<span class="code" dir="ltr">iwconfig</span>各项参数</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">iwpriv_eth0</span></td>
  <td class="tableinfo"></td>
  <td class="tableinfo">请参看<span class="code" dir="ltr">iwpriv</span>的man pages了解<span class="code" dir="ltr">iwpriv</span>各项参数</td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">sleep_scan_eth0</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">0</span></td>
  <td class="tableinfo">
    在尝试扫描前的休眠时间（以秒为单位）。当驱动／固件需要时间激活时设置这个值。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">sleep_associate_eth0</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">5</span></td>
  <td class="tableinfo">
    无线网络尝试连接到AP等待的秒数，超时则转向下一个AP。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">associate_test_eth0</span></td>
  <td class="tableinfo"><span class="code" dir="ltr">MAC</span></td>
  <td class="tableinfo">
    一些驱动程序在失去连接或尝试连接时不会重置无效AP的MAC地址，而有一些驱动程序在碰到这些情况时不会重设quality level。这里有效的设定是<span class="code" dir="ltr">MAC</span>，<span class="code" dir="ltr">quality</span>和<span class="code" dir="ltr">all</span>。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">scan_mode_eth0</span></td>
  <td class="tableinfo"></td>
  <td class="tableinfo">
    某些驱动必须在ad-hoc模式下扫描，因此若扫描失败的话请尝试把此变量设置成<span class="code" dir="ltr">ad-hoc</span> 
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">iwpriv_scan_pre_eth0</span></td>
  <td class="tableinfo"></td>
  <td class="tableinfo">
    扫描前先向接口发送一些<span class="code" dir="ltr">iwpriv</span>命令。更多细节请参看iwpriv的man page。
  </td>
</tr>
<tr>
  <td class="tableinfo"><span class="code" dir="ltr">iwpriv_scan_post_eth0</span></td>
  <td class="tableinfo"></td>
  <td class="tableinfo">
    扫描后向接口发送一些<span class="code" dir="ltr">iwpriv</span>命令。更多细节请参看iwpriv的man page。
  </td>
</tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap4__chap4"></a><span class="chapnum">4.d. </span>针对每个ESSID的网络配置</p>
<p>
有时，您连接<span class="emphasis">ESSID1</span>需要使用一个固定IP，而连接<span class="emphasis">ESSID2</span>要使用DHCP。实际上，大多数模块变量可以针对每个ESSID来定义。下面我们给出具体的做法。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
只有使用WPA Supplicant或者Wireless Tools时，这些设定才起作用。
</p></td></tr></tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#ffffbb"><p class="note"><b>重要: </b>
您<span class="emphasis">将</span>需要参阅文档<a href="#variable_name">变量名称</a>。
</p></td></tr></tbody></table>
<a name="book_part4_chap4__chap4_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;4.1: 覆盖每一个ESSID的配置</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>config_ESSID1=( "192.168.0.3/24 brd 192.168.0.255" )
routes_ESSID1=( "default via 192.168.0.1" )

config_ESSID2=( "dhcp" )
fallback_ESSID2=( "192.168.3.4/24" )
fallback_route_ESSID2=( "default via 192.168.3.1" )

<span class="code-comment"># 我们可以定义DNS服务器和其他的一些东西</span>
<span class="code-comment"># 注意:DHCP将覆盖这些设定，除非我们要求它不要覆盖</span>
dns_servers_ESSID1=( "192.168.0.1" "192.168.0.2" )
dns_domain_ESSID1="some.domain"
dns_search_domains_ESSID1="search.this.domain search.that.domain"

<span class="code-comment"># 根据无线AP的MAC地址来覆盖相关设定
# 这在不同地点有相同ESSID的情况下非常有用</span>
config_001122334455=( "dhcp" )
dhcpcd_001122334455="-t 10"
dns_servers_001122334455=( "192.168.0.1" "192.168.0.2" )
</pre></td></tr>
</tbody></table>
<a name="book_part4_chap5"></a><h3>5. 附加功能</h3>
<p class="chaphead"><a name="book_part4_chap5__chap1"></a><span class="chapnum">5.a. </span>标准函数钩子</p>
<p>
你可以定义4个函数，它们将会在<span class="code" dir="ltr">start</span>/<span class="code" dir="ltr">stop</span>操作前后被调用。这些函数将会以接口名称作为参数被调用，以便于一个函数可以控制多个适配器。
</p>
<p>
<span class="code" dir="ltr">preup()</span>和<span class="code" dir="ltr">predown()</span>函数的返回值必须为0（成功），这意味着可以使一个网络接口进入配置状态或退出配置状态。如果<span class="code" dir="ltr">preup()</span>返回一个非0值，则网络接口配置过程将被中止。如果<span class="code" dir="ltr">predown()</span>返回一个非0值，则停止该网络接口运行的操作将被终止。
</p>
<p>
<span class="code" dir="ltr">postup()</span>和<span class="code" dir="ltr">postdown()</span>函数的返回值会被忽略，因为就算它们返回失败，系统也没有什么可以做的。
</p>
<p>
<span class="code" dir="ltr">${IFACE}</span>表示要打开/关闭的接口。<span class="code" dir="ltr">${IFVAR}</span>是<span class="code" dir="ltr">${IFACE}</span>转化而来的bash允许的变量名。
</p>
<a name="book_part4_chap5__chap1_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;1.1: pre/post up/down函数范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>preup() {
  <span class="code-comment"># 在打开接口之前先测试它的网络物理连接是否已连接上。这只在某些网络
  # 适配器上有效，而且需要安装ethtool包。</span>
  if ethtool ${IFACE} | grep -q 'Link detected: no'; then
    ewarn "No link on ${IFACE}, aborting configuration"
    return 1
  fi

  <span class="code-comment"># 记得返回0以表示操作成功</span>
  return 0
}

predown() {
  <span class="code-comment"># 脚本默认内容是测试根文件系统是否是NFS提供的。在此情况下系统是不会允
  # 许你关闭接口的。注意，如果你定义了一个predown()函数，你就覆盖了这个逻辑。
  # 如果你仍然需要它的话，请往下看……
  </span>
  if is_net_fs /; then
    eerror "root filesystem is network mounted -- can't stop ${IFACE}"
    return 1
  fi

  <span class="code-comment"># 记得返回0以表示操作成功</span>
  return 0
}

postup() {
  <span class="code-comment"># 这个函数可以被用来实现一些功能，比如注册一个动态DNS服务。
  # 而另一个可能是在网络接口一启动时就开始传送/接收邮件。</span>
  return 0
}

postdown() {
  <span class="code-comment"># 这个函数出现在这主要是为了完整性……我还没有想到任何可以用它来做的好玩的事情 ;-)</span>
  return 0
}
</pre></td></tr>
</tbody></table>
<p class="chaphead"><a name="book_part4_chap5__chap2"></a><span class="chapnum">5.b. </span>无线工具函数钩子</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
此功能不适用于WPA Supplicant──但是<span class="code" dir="ltr">${ESSID}</span>和<span class="code" dir="ltr">${ESSIDVAR}</span>变量在<span class="code" dir="ltr">postup()</span>函数中是可用的。
</p></td></tr></tbody></table>
<p>
你可以定义2个函数，它们将会在执行相关的操作前后被调用。这些函数将会以接口名称作为参数被调用，以便于一个函数可以控制多个适配器。
</p>
<p>
<span class="code" dir="ltr">preassociate()</span>函数的返回值应该为0（成功），这意味着一个网络接口的配置或取消配置过程可以继续。如果<span class="code" dir="ltr">preassociate()</span>返回一个非0值，则网络接口的配置过程将被中止。
</p>
<p>
<span class="code" dir="ltr">postassociate()</span>函数的返回值是被忽略的，因为就算它们返回失败，系统也没有什么可以做的。
</p>
<p>
<span class="code" dir="ltr">${ESSID}</span>被设置为你所连接到的AP的ESSID。<span class="code" dir="ltr">${ESSIDVAR}</span>是<span class="code" dir="ltr">${ESSID}</span>转化而来的bash允许的变量名。
</p>
<a name="book_part4_chap5__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: pre/post association functions</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre>preassociate() {
  <span class="code-comment"># 下面添加了两个配置变量leap_user_ESSID和leap_pass_ESSID。
  # 当你已经连接的ESSID的这两个变量都被配置时，我们就执行CISCO LEAP脚本。
  </span>

  local user pass
  eval user=\"\$\{leap_user_${ESSIDVAR}\}\"
  eval pass=\"\$\{leap_pass_${ESSIDVAR}\}\"

  if [[ -n ${user} &amp;&amp; -n ${pass} ]]; then
    if [[ ! -x /opt/cisco/bin/leapscript ]]; then
      eend "For LEAP support, please emerge net-misc/cisco-aironet-client-utils"
      return 1
    fi
    einfo "Waiting for LEAP Authentication on \"${ESSID//\\\\//}\""
    if /opt/cisco/bin/leapscript ${user} ${pass} | grep -q 'Login incorrect'; then
      ewarn "Login Failed for ${user}"
      return 1
    fi
  fi

  return 0
}

postassociate() {
  <span class="code-comment"># 这个函数出现在这主要是为了完整性……我还没有想到任何可以用它来做的好玩的事情 ;-)</span>

  return 0
}
</pre></td></tr>
</tbody></table>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
<span class="code" dir="ltr">${ESSID}</span>和<span class="code" dir="ltr">${ESSIDVAR}</span>在<span class="code" dir="ltr">predown()</span>和<span class="code" dir="ltr">postdown()</span>函数中不可用。
</p></td></tr></tbody></table>
<a name="book_part4_chap6"></a><h3>6. 网络管理</h3>
<p class="chaphead"><a name="book_part4_chap6__chap1"></a><span class="chapnum">6.a. </span>网络管理</p>
<p>
如果你经常移动你的电脑，你可能会遇到没有网线和没有插入网线或者没有无线网络可用的情况。你也许希望在插入网线或无线网络可用时网络能够自动连上。
</p>
<p>
在这里你可以找到帮助你实现这个功能的一些工具。
</p>
<table class="ncontent" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#bbffbb"><p class="note"><b>注意: </b>
本章只介绍<span class="code" dir="ltr">ifplugd</span>，但还有一些工具如<span class="code" dir="ltr">netplug</span>可供选择。<span class="code" dir="ltr">netplug</span>是<span class="code" dir="ltr">ifplugd</span>的轻量级替代者，但是它依赖于你的内核网络驱动的正常工作，而很多驱动不能正常工作。
</p></td></tr></tbody></table>
<p class="chaphead"><a name="book_part4_chap6__chap2"></a><span class="chapnum">6.b. </span>ifplugd</p>
<p>
<a href="http://0pointer.de/lennart/projects/ifplugd/">ifplugd</a>是一个在插入或拔出网线时启动或停止网络连接的程序。它也可以检测你的无线网卡和AP的关联，或者是在AP进入范围时检测。
</p>
<a name="book_part4_chap6__chap2_pre1"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.1: 安装ifplugd</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge sys-apps/ifplugd</span>
</pre></td></tr>
</tbody></table>
<p>
ifplugd的配置相当简单。配置文件放置在<span class="path" dir="ltr">/etc/conf.d/net</span>中。运行<span class="code" dir="ltr">man ifplugd</span>以获得详细的变量信息。同时，请查看<span class="path" dir="ltr">/etc/conf.d/net.example</span>以获得更多例子。
</p>
<a name="book_part4_chap6__chap2_pre2"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.2: ifplug设置范例</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre><span class="code-comment">（把eth0替换成要监控的网卡）</span>
ifplugd_eth0="..."

<span class="code-comment">（监控一个无限网卡）</span>
ifplugd_eth0="--api-mode=wlan"
</pre></td></tr>
</tbody></table>
<p>
除了管理多个网络连接之外，你可能需要增加一个工具来使得管理多个DNS服务器和配置更加容易。当你通过DHCP来获取IP地址时，这将非常有用。只需要emerge <span class="code" dir="ltr">openresolv</span>.
</p>
<a name="book_part4_chap6__chap2_pre3"></a><table class="ntable" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#7a5ada"><p class="codetitle">代码&nbsp;2.3: 安装openresolv</p></td></tr>
<tr><td dir="ltr" align="left" bgcolor="#eeeeff"><pre># <span class="code-input">emerge openresolv</span>
</pre></td></tr>
</tbody></table>
<p>
查看<span class="code" dir="ltr">man resolvconf</span>来学习他更多的特性。
</p>
<p class="copyright">本文档的内容遵循<a href="http://creativecommons.org/licenses/by-sa/2.5">知识共享-署名-相同方式共享</a>许可协议</p>
<!--
  <rdf:RDF xmlns="http://web.resource.org/cc/"
      xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
  <License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/">
     <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
     <permits rdf:resource="http://web.resource.org/cc/Distribution" />
     <requires rdf:resource="http://web.resource.org/cc/Notice" />
     <requires rdf:resource="http://web.resource.org/cc/Attribution" />
     <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
     <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
  </License>
  </rdf:RDF>
-->
</td>
<td bgcolor="#dddaec" valign="top" width="1%"><table border="0" cellpadding="4" cellspacing="4">
<tbody><tr><td class="topsep" align="center"><p class="altmenu"><a title="查看利于打印版本" class="altlink" href="http://www.gentoo.org/doc/zh_cn/handbook/handbook-x86.xml?full=1&amp;style=printable">打印</a></p></td></tr>
<tr><td class="topsep" align="center"><p class="alttext">更新于2008年 10月 12日 </p></td></tr>
<tr><td class="topsep" align="left"><p class="alttext"><b>总结: </b>
这是Gentoo手册，一个集中了Gentoo/Linux信息的地方。这份手册包含了在x86系统上的基于网络安装的系统安装指南，以及讲述如何使用Gentoo和Portage的章节。
</p></td></tr>
<tr><td class="topsep" align="left"><p class="alttext">
  <a href="mailto:swift@gentoo.org" class="altlink"><b>Sven Vermeulen</b></a>
<br><i>作者</i><br><br>
  <a href="mailto:g2boojum@gentoo.org" class="altlink"><b>Grant Goodyear</b></a>
<br><i>作者</i><br><br>
  Roy Marples
<br><i>作者</i><br><br>
    <a href="mailto:drobbins.daniel@gmail.com" class="altlink"><b>Daniel Robbins</b></a>
<br><i>作者</i><br><br>
  <a href="mailto:chouser@bluweb.com" class="altlink"><b>Chris Houser</b></a>
<br><i>作者</i><br><br>
  <a href="mailto:jalexand@wlgore.com" class="altlink"><b>Jerry Alexandratos</b></a>
<br><i>作者</i><br><br>
  <a href="mailto:seemant@kulleen.org" class="altlink"><b>Seemant Kulleen</b></a>
<br><i>Gentoo x86开发人员</i><br><br>
  <a href="mailto:taviso@gmail.com" class="altlink"><b>Tavis Ormandy</b></a>
<br><i>Gentoo Alpha开发人员</i><br><br>
  Jason Huebel
<br><i>Gentoo AMD64开发人员</i><br><br>
  <a href="mailto:gmsoft@gentoo.org" class="altlink"><b>Guy Martin</b></a>
<br><i>Gentoo HPPA开发人员</i><br><br>
   <a href="mailto:pvdabeel@gentoo.org" class="altlink"><b>Pieter Van den Abeele</b></a>
<br><i>Gentoo PPC开发人员</i><br><br>
  <a href="mailto:jkallar@yahoo.com" class="altlink"><b>Joe Kallar</b></a>
<br><i>Gentoo SPARC开发人员</i><br><br>
    <a href="mailto:john_davis@pauldavisautomation.com" class="altlink"><b>John P. Davis</b></a>
<br><i>编辑</i><br><br>Pierre-Henri Jondot<br><i>编辑</i><br><br>
    <a href="mailto:stocke2@gmail.com" class="altlink"><b>Eric Stockbridge</b></a>
<br><i>编辑</i><br><br>
    <a href="mailto:rajiv@gentoo.org" class="altlink"><b>Rajiv Manglani</b></a>
<br><i>编辑</i><br><br>
    <a href="mailto:seo@gentoo.or.kr" class="altlink"><b>Jungmin Seo</b></a>
<br><i>编辑</i><br><br>
    <a href="mailto:zhware@hotpop.com" class="altlink"><b>Stoyan Zhekov</b></a>
<br><i>编辑</i><br><br>
    Jared Hudson
<br><i>编辑</i><br><br>
    <a href="mailto:peitolm@gentoo.org" class="altlink"><b>Colin Morey</b></a>
<br><i>编辑</i><br><br>
    Jorge Paulo
<br><i>编辑</i><br><br>
    <a href="mailto:canderson@wayne.edu" class="altlink"><b>Carl Anderson</b></a>
<br><i>编辑</i><br><br>
    <a href="mailto:avenj@tellink.net" class="altlink"><b>Jon Portnoy</b></a>
<br><i>编辑</i><br><br>
     Zack Gilburd
<br><i>编辑</i><br><br>
  <a href="mailto:jack@bonyari.com" class="altlink"><b>Jack Morgan</b></a>
<br><i>编辑</i><br><br>
  <a href="mailto:benny@coolbee.net" class="altlink"><b>Benny Chuang</b></a>
<br><i>编辑</i><br><br>
  <a href="mailto:erw1n@pmail.ntu.edu.sg" class="altlink"><b>Erwin</b></a>
<br><i>编辑</i><br><br>
  <a href="mailto:kumba@gentoo.org" class="altlink"><b>Joshua Kinard</b></a>
<br><i>编辑</i><br><br>
  <a href="mailto:dertobi123@gentoo.org" class="altlink"><b>Tobias Scherbaum</b></a>
<br><i>编辑</i><br><br>
  <a href="mailto:neysx@gentoo.org" class="altlink"><b>Xavier Neys</b></a>
<br><i>编辑</i><br><br>
  <a href="mailto:nightmorph@gentoo.org" class="altlink"><b>Joshua Saddler</b></a>
<br><i>编辑</i><br><br>
    Gerald J. Normandin Jr.
<br><i>审校</i><br><br>
    <a href="mailto:dberkholz@gentoo.org" class="altlink"><b>Donnie Berkholz</b></a>
<br><i>审校</i><br><br>
    <a href="mailto:drake_stuff@yahoo.com" class="altlink"><b>Ken Nowack</b></a>
<br><i>审校</i><br><br>
   <a href="mailto:lars@weiler-online.name" class="altlink"><b>Lars Weiler</b></a>
<br><i>投稿</i><br><br>
  <a href="mailto:joanphan@gmail.com" class="altlink"><b>Hans Joanphan</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:wcw8410@gmail.com" class="altlink"><b>吴传文</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:gnuguys@gmail.com" class="altlink"><b>杨珂</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:greyeye.cn@gmail.com" class="altlink"><b>陈永骥</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:dongbin.lou@gmail.com" class="altlink"><b>娄东斌</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:daqiehexigua@gmail.com" class="altlink"><b>余雷</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:tysnoo@gmail.com" class="altlink"><b>叶宝泰</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:druggo@gmail.com" class="altlink"><b>杨小广</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:vivian.ye@gmail.com" class="altlink"><b>vivian.ye</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:zhudingshibai@gmail.com" class="altlink"><b>王国辉</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:linuxjia@gmail.com" class="altlink"><b>贾震</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:acevery@gmail.com" class="altlink"><b>余鈺炜</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:coolshoulder@gmail.com" class="altlink"><b>陈代焱</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:linuxfans.linky@gmail.com" class="altlink"><b>范华</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:r0bertz@gentoo.org" class="altlink"><b>张乐</b></a>
<br><i>译者</i><br><br>
  <a href="mailto:chenjun.shen@gmail.com" class="altlink"><b>沈辰俊</b></a>
<br><i>译者</i><br></p></td></tr>
<tr lang="en"><td class="topsep" align="center">
<p class="alttext"><b>Donate</b> to support our development efforts.
        </p>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input name="cmd" value="_xclick" type="hidden"><input name="business" value="paypal@gentoo.org" type="hidden"><input name="item_name" value="Gentoo Linux Support" type="hidden"><input name="item_number" value="1000" type="hidden"><input name="image_url" value="/images/paypal.png" type="hidden"><input name="no_shipping" value="1" type="hidden"><input name="return" value="http://www.gentoo.org" type="hidden"><input name="cancel_return" value="http://www.gentoo.org" type="hidden"><input src="gentoo-2008.0-handbook-x86_files/x-click-but21.gif" name="submit" alt="Donate to Gentoo" type="image">
</form>
</td></tr>
<tr lang="en"><td class="topsep" align="center">
<a href="http://osuosl.org/contribute"><img src="gentoo-2008.0-handbook-x86_files/osuosl.png" alt="Support OSL" border="0" height="50" width="125"></a><p class="alttext"><a href="http://osuosl.org/contribute">Support OSL</a></p>
</td></tr>
<tr lang="en"><td class="topsep" align="center">
<a href="http://www.vr.org/"><img src="gentoo-2008.0-handbook-x86_files/vr-ad.png" alt="Gentoo Centric Hosting: vr.org" border="0" height="144" width="125"></a><p class="alttext"><a href="http://www.vr.org/">VR Hosted</a></p>
</td></tr>
<tr lang="en"><td class="topsep" align="center">
<a href="http://www.tek.net/" target="_top"><img src="gentoo-2008.0-handbook-x86_files/tek-gentoo.gif" alt="Tek Alchemy" border="0" height="125" width="125"></a><p class="alttext"><a href="http://www.tek.net/">Tek Alchemy</a></p>
</td></tr>
<tr lang="en"><td class="topsep" align="center">
<a href="http://www.sevenl.net/" target="_top"><img src="gentoo-2008.0-handbook-x86_files/sevenl.gif" alt="SevenL.net" border="0" height="144" width="125"></a><p class="alttext"><a href="http://www.sevenl.net/">SevenL.net</a></p>
</td></tr>
<tr lang="en"><td class="topsep" align="center">
<a href="http://www.gni.com/" target="_top"><img src="gentoo-2008.0-handbook-x86_files/gni_logo.png" alt="Global Netoptex Inc." border="0" width="125"></a><p class="alttext"><a href="http://www.gni.com/">Global Netoptex Inc.</a></p>
</td></tr>
<tr lang="en"><td class="topsep" align="center">
<a href="http://www.bytemark.co.uk/r/gentoo-home" target="_top"><img src="gentoo-2008.0-handbook-x86_files/bytemark_ad.png" alt="Bytemark" border="0" width="125"></a><p class="alttext"><a href="http://www.bytemark.co.uk/r/gentoo-home">Bytemark</a></p>
</td></tr>
<tr><td class="topsep" align="center"></td></tr>
</tbody></table></td>
</tr></tbody></table></td></tr>
<tr><td colspan="2" class="infohead" align="right">
Copyright 2001-2008 Gentoo Foundation, Inc. Questions, Comments? <a class="highlight" href="http://www.gentoo.org/main/en/contact.xml">Contact us</a>.
</td></tr>
</tbody></table></body></html>
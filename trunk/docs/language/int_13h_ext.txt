1. 简介
   int 0x13扩展主要是为了磁盘LBA寻址而提出的.

2. DAP(磁盘地址数据包)

   struct DAP {
       BYTE  PacketSize; // DAP的大小, 始终为16(字节)
       BYTE  Reserved;   // 保留字节, 始终为0
       WORK  BlockCount; // 需要传输的数据块数目(以扇区为单位)
       DWORD BufferAddr; // 传输缓冲区的地址 (segment:offset)
       QWORD BlockNum;   // 磁盘传输的起始地址(以扇区为单位, 从0开始)
   };

3. BlockNum 与 CHS的转换

   BlockNum = cylinder * NumberofHeads + head * SectorsPerTrack + sector - 1;
   其中 cylinder, head, sector 是 CHS 地址, NumberOfHeads 是磁盘的磁头数, 
   SectorsPerTrack 是磁盘每磁道的扇区数.
   也就是说 BlockNum 是沿着 扇区->磁道->柱面 的顺序记数的.这一顺序是由磁盘控制器虚拟的,
   磁盘表面数据块的实际排列顺序可能与此不同(如为了提高磁盘速度而设置的间隔因子将会打乱扇区的
   排列顺序).

4. DPP(驱动器参数数据包)

   struct DPP {
       WORD  InfoSize;   // DPP的大小, 始终为26(字节)
       WORD  Flags;      // 信息标志
       DWORD Cylinders;  // 磁盘柱面数
       DWORD Heads;      // 磁头磁盘数
       DWORD SectorsPerTrack; // 每磁道扇区数
       QWORD Sectors;    // 磁盘总扇区数
       WORD  SectorSize; // 扇区大小(以字节为单位)
   };

   信息标志用于返回磁盘的附加信息, 每一位的定义如下:
   
   0 位: 0 = 可能发生 DMA 边界错误, 1 = DMA 边界错误将被透明处理
     如果这位置 1, 表示 BIOS 将自动处理 DMA 边界错误, 也就是说
     错误代码 09H 永远也不会出现.
   1 位: 0 = 未提供 CHS 信息, 1 = CHS 信息合法
     如果块设备的传统 CHS 几何信息不适当的话, 该位将置 0.
   2 位: 0 = 驱动器不可移动, 1 = 驱动器可移动
   3 位: 表示该驱动器是否支持写入时校验.
   4 位: 0 = 驱动器不具备介质更换检测线, 1 = 驱动器具备介质更换检测线
   5 位: 0 = 驱动器不可锁定, 1 = 驱动器可以锁定
     要存取驱动器号大于 0x80 的可移动驱动器, 该位必须置 1 (某些驱动器号为 0 到 
     0x7F 的设备也需要置位)
   6 位: 0 = CHS 值是当前存储介质的值 (仅对于可移动介质), 如果
     驱动器中有存储介质, CHS 值将被返回. 1 = CHS 值是驱动器支持的最大值
     (此时驱动器中没有介质).
   7 - 15 位: 保留, 必须置 0. 

5 寄存器
  
  在扩展 Int13H 调用中一般使用如下寄存器约定:
  DS:SI ==>磁盘地址数据包(DAP)
  DL    ==>驱动器号   
  AH    ==>功能代码 / 返回码
  在基本 Int13H 调用中, 0 - 0x7F 之间的驱动器号代表可移动驱动器 
  0x80 - 0xFF 之间的驱动器号代表固定驱动器.
  但在扩展 Int13H 调用中 0x80 - 0xFF 之间还包括一些新出现的可移动驱动器, 
  比如活动硬盘等. 这些驱动器支持先进的锁定,解锁等功能.

  AH 返回的错误码

6 错误代码

  0xb0: 驱动器中的介质未被锁定
  0xb1: 驱动器中的介质已经锁定
  0xb2: 介质是可移动的
  0xb3: 介质正在被使用
  0xb4: 锁定记数溢出
  0xb5: 合法的弹出请求失败

7 API
  
  1.x 版的扩展 Int13H 调用中规定了两个主要的 API 子集.
  第一个子集提供了访问大硬盘所必须的功能, 包括:
  1. 检查扩展 In13H 是否存在( 0x41 ) 
  2. 扩展读( 0x42 )
  3. 扩展写( 0x43 ) 
  4. 校验扇区( 0x44 ) 
  5. 扩展定位( 0x47 ) 
  6. 取得驱动器参数( 0x48 )
  
  第二个子集提供了对软件控制驱动器锁定和弹出的支持,包括:
  1. 检查扩展 Int13H 是否存在( 0x41 ), 
  2. 锁定/解锁驱动器( 0x45 ), 
  3. 弹出驱动器( 0x46 ), 
  4. 取得驱动器参数( 0x48 ), 
  5. 取得扩展驱动器改变状态( 0x49 ).
 
 如果使用了调用规范中不支持的功能, BIOS 将返回错误码 ah = 0x01, CF = 1.


8 检查扩展功能是否存在(0x41)
  
  入口
  AH = 0x41   
  BX = 0x55AA   
  DL = 驱动器号

  返回
  CF = 0    
  AH = 扩展功能的主版本号    
  AL = 内部使用    
  BX = AA55h    
  CX = API 子集支持位图   
  
  错误
  CF = 1    
  AH = 错误码 01h, 无效命令 

  这个调用检验对特定的驱动器是否存在扩展功能. 如果进位标志置 1 则此驱动器不支持扩展功能. 
  如果进位标志为 0, 同时 BX = AA55h, 则存在扩展功能. 
  此时 CX 的 0 位表示是否支持第一个子集, 1位表示是否 支持第二个子集.
  对于 1.x 版的扩展 Int13H 来说, 主版本号 AH = 1. AL 是副版本号, 
  但这仅限于 BIOS内部使用, 任何软件不得检查 AL 的值.


9 扩展读(0x42)

  入口
  AH = 42h
  DL = 驱动器号
  DS:SI = 磁盘地址数据包(Disk Address Packet)

  返回
  CF = 0, 
  AH = 0 成功

  错误
  CF =1 
  AH = 错误码
  
  这个调用将磁盘上的数据读入内存. 如果出现错误, DAP 的 BlockCount 项中则记录了出错
  前实际读取的数据块个数.

10 扩展写(0x43)

   入口
   AH = 0x43h
   AL 
       0 位 = 0 关闭写校验,1 打开写校验
       1 - 7 位保留, 置 0
   DL = 驱动器号
   DS:SI = 磁盘地址数据包(DAP)

   返回
   CF = 0
   AH = 0 成功

   错误
   CF = 1
   AH = 错误码
   
   这个调用将内存中的数据写入磁盘. 如果打开了写校验选项,但 BIOS 不支持, 
   则会返回错误码 AH = 01h, CF = 1. 功能 48h 可以检测BIOS是否 支持写校验. 
   
   如果出现错误, DAP 的 BlockCount 项中则记录了出错前实际写入的数 据块个数.

11 效验扇区(0x44)

   入口
   AH = 0x44
   DL = 驱动器号
   DS:SI = 磁盘地址数据包(Disk Address Packet)


   返回
   CF = 0
   AH = 0 成功

   错误
   CF= 1
   AH = 错误码
  
   这个调用校验磁盘数据, 但并不将数据读入内存. 如果出现错误, DAP 的 BlockCount 
   项中则记录了出错前实际校验的数据块个数.

12 锁定/解锁驱动器(0x45)

   入口
   AH = 0x45
   AL = 0 锁定驱动器, = 1 驱动器解锁, = 02 返回锁定/解锁状态, = 03h-FFh - 保留
   DL = 驱动器号 

   返回
   CF = 0
   AH = 0 成功

   错误
   CF = 1
   AH = 错误码

   这个调用用来缩定指定驱动器中的介质. 所有标号大于等于 0x80 的可移动驱动器必须支持这个功能.
   如果在支持可移动驱动器控制功能子集的固定驱动器上使用这个功能调用, 将会成功返回.
   驱动器必须支持最大255次锁定, 在所有锁定被解锁之前, 不能在物理上将驱动器解锁. 解锁一个未
   锁定的驱动器,将返回错误码 AH= B0h. 
   如果锁定一 个已锁定了255次的驱动器, 将返回错误码 AH = B4h. 
   锁定一个没有介质的驱动器是合法的


13 弹出可移动驱动器中的介质(0x46)
   
   入口
   AH = 0x46
   AL = 0 保留
   DL = 驱动器号 

   返回
   CF = 0
   AH = 0 成功

   错误
   CF = 1
   AH = 错误码
  
   这个调用用来弹出指定的可移动驱动器中的介质. 所有标号大于等于 0x80 的可移动驱动器必须支持
   这个功能. 如果在支持可移动驱动器控制功能子集的固定驱动器上使用这个功能调用, 将会返回错误
   码 AH = 0xB2(介质不可移动). 
   如果试图弹出一个被锁定的介质将返回错误码 AH = 0xB1(介质被锁定).
   如果试图弹出一个没有介质的驱动器, 则返回错误码 Ah = 0x31 (驱动器中没有介质).
   如果试图弹出一个未锁定的可移动驱动器中的介质, Int 0x13会调用Int 0x15(AH = 0x52)来检
   查弹出请求能否执行. 如果弹出请求被拒绝则返回错误码(同Int15h). 如果弹出请求被接受,但出现
   了其他错误, 则返回错误码 AH = B5h

14 扩展定位入口(0x47)

   入口
   AH = 0x47
   DL = 驱动器号
   DS:SI = 磁盘地址数据包(Disk Address Packet)

   返回
   CF = 0
   AH = 0 成功

   错误
   CF = 1
   AH = 错误码

   这个调用将磁头定位到指定扇区.

15 取得驱动器参数(0x48)

   入口
   AH = 0x48
   DL = 驱动器号
   DS:SI = 返回数据缓冲区地址

   返回
   CF = 0
   AH = 0 成功
   DS:SI 驱动器参数数据包地址(DPP)

   错误
   CF = 1
   AH = 错误码

   这个调用返回指定驱动器的参数.

16 取得扩展驱动器介质更换检测线状态

   入口
   AH = 0x49
   DL = 驱动器号 

   返回
   CF = 0
   AH = 0 介质未更换
   
   CF = 1
   AH = 06h 介质可能已更换

   这个调用返回指定驱动器的介质更换状态. 这个调用与 Int13h AH = 16h 子功能调用相同, 
   只是允许任何驱动器标号. 如果对一台支持可移动介质功能子集的固定驱动器使用此功能, 则永
   远返回 CF = 0, AH = 0.
   简单地将可移动介质锁定再解锁就可以激活检测线, 而无须真正更换介质.

17 可移动介质弹出支持(0x52, int 0x15)

   入口
   AH = 0x52
   DL = 驱动器号 

   返回
   CF = 0
   AH = 0 弹出请求可能可以执行

   错误
   CF = 1
   AH = 错误码 B1h 或 B3h 弹出请求不能执行

   这个调用是由 Int 0x13 AH=0x46 弹出介质功能调用内部使用的


